---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Code scraps"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***

This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al., Nature Protocols 2014).

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://bioconductor.org/books/release/OSCA/) by Robert Amezquita, Aaron Lun, Stephanie Hicks, and Raphael Gottardo, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/3.10/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/3.10/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/3.10/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources include [Bioconductor](http://www.bioconductor.org/) (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarthy et al., Bioinformatics 2017), `scran` (Lun et al., F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `edgeR` (Robinson et al., Bioinformatics 2010), `MAST` (Finak, McDavid, Yajima et al., Genome Biology 2015), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008), `UMAP` (McInnes et al., arXiv 2018), and the [Mathematical Statistics and Machine Learning for Life Sciences](https://towardsdatascience.com/tagged/stats-ml-life-sciences) column by Nikolay Oskolkov.

***

Below are some code scraps that have been taken out of the pipeline in favour of other preferred alternatives. They most likely require further adaptations before being reincorporated.

# STEP 1 | Read Data and Metadata
## Step 1.5 | Add gene-based annotations
We can add gene-based annotation by pulling the annotation from `org.Mm.eg.db` to relate the ENSEMBL identifiers to gene symbols. The `mapIds()` function ensures that only one gene symbol is returned if two symbols map to the same ENSEMBL ID.
```{r}
library(org.Mm.eg.db)
gene_symbols <- mapIds(org.Mm.eg.db, keys = rownames(PAG_data), 
                       keytype ="ENSEMBL", column = "SYMBOL")
PAG_gene_annotations <- data.frame(ENSEMBL = rownames(PAG_data), 
                                   gene_symbols = gene_symbols, 
                                   stringsAsFactors = FALSE)
head(PAG_gene_annotations)
```

We can also identify which rows correspond to mitochondrial genes. To do that we need to use extra annotation describing the genomic location of each gene. For ENSEMBL, this involves using the `TxDb.Mmusculus.UCSC.mm10.ensGene` package.
```{r}
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
gene_location <- mapIds(TxDb.Mmusculus.UCSC.mm10.ensGene, keys = rownames(PAG_data), 
                        keytype = "GENEID", column = "CDSCHROM")
PAG_gene_annotations$Chromosome <- gene_location
which(gene_location=="chrM")
table(PAG_gene_annotations$Chromosome)
```

# STEP 2 | Pre-processing and data Quality Control
## Step 2.3 | Cell QC
### 2.3.5 | Xist expression
A final quality check could be to look at the expression of _Xist_, which should only appear in cells obtained from female mice, as it only expresses in the inactive X chromosome:
```{r}
# Log transform the counts for Xist
PAG_sceset$log2_total_counts_Xist <- log2(PAG_sceset$subsets_XIST_sum + 1)
summary(PAG_sceset$log2_total_counts_Xist)

# Plot Expression values of VGAT and VGluT2 in several ways:
plotExpression(PAG_sceset, "Xist", x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "mouse.sex",
               xlab = "Mouse ID")

plotExpression(PAG_sceset, "Xist", x = "mouse.sex", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "cell.type",
               xlab = "Mouse sex")

plotExpression(PAG_sceset[, PAG_sceset$mouse.sex == "M"], "Xist", x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing",
               xlab = "Mouse ID")

plotExpression(PAG_sceset[, PAG_sceset$mouse.sex == "F"], "Xist", x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing",
               xlab = "Mouse ID")

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_Chromosome_X_sum",
            colour_by = "mouse.id",
            other_fields = "mouse.sex") +
  facet_wrap(~mouse.sex) + 
  xlab("Number of detected genes") +
  ylab("X Chromosome counts")

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_Chromosome_Y_sum",
            colour_by = "mouse.id",
            other_fields = "mouse.sex") +
  facet_wrap(~mouse.sex) + 
  xlab("Number of detected genes") +
  ylab("Y Chromosome counts")
```

## Step 2.5 | Gene QC
### 2.5.3 | Identities of the most highly expressed genes
It can also be useful to plot gene expression frequency versus mean expression level to assess the effects of technical dropout in the dataset. The `plotExprsFreqVsMean()` function fits a non-linear least squares curve for the relationship between expression frequency and mean expression and uses this to define the number of genes above high technical dropout and the numbers of genes that are expressed (here defined as at least 4 counts) in at least 50% and at least 25% of cells. A subset of genes to be treated as feature controls can be specified, otherwise any feature controls previously defined are used. 

Plot frequency of expression (number of cells with non-zero expression) against the mean. These two metrics should be positively correlated with each other for most genes. Outliers from the trend may warrant further investigation. For example, alignment errors for pseudo-genes of highly-expressed genes will result in features with low means that are expressed in all cells. Conversely, PCR amplification biases (or the presence of rare populations) may result in genes with very high means that are expressed in very few cells. 

*Check out the "Scater Case Study" by McCarthy et al. 2016 for more information.*
```{r}
plotExprsFreqVsMean(PAG_sceset,
                    control = "is_spike") 
plotExprsFreqVsMean(PAG_sceset[ , colData(PAG_sceset)$use],
                    control = "is_spike")
```

## Step 2.5b | Cell cycle phase [OPTIONAL]
It is possible to classify cells into cell cycle phases based on the gene expression data using the function `cyclone` (Sciealdone et al. 2015). This, however, is not super useful in the brain, as many neuronal cell types are expected to lie in the G0 resting phase, which is distinct from the other phases of the cell cycle (Coller et al., 2006). We run it anyway and observe that all the cells are in G1.

Cells are classified as being in G1 phase if the G1 score is above 0.5 and greater than the G2/M score; in G2/M phase if the G2/M score is above 0.5 and greater than the G1 score; and in S phase if neither score is above 0.5.

*See McCarthy et al. F1000Research 2016 for an explanation of this step and the code.*
```{r}
library(scran)
library(AnnotationDbi)
library(org.Mm.eg.db)
set.seed(1991)

mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran")) 
assignments <- cyclone(PAG_sceset, mm.pairs, gene.names=rowData(PAG_sceset)$ENSEMBL) 
plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", ylab="G2/M score", pch=16, xlim=c(0,1), ylim=c(0,1))
```

We could store the cell cycle phases for future use:
```{r}
PAG_sceset$cycle_phase <- assignments$phases
```

# STEP 3 | Normalization of cell-specific biases
## Step 3.1b | Compute size factors for spike-in transcripts (Bioconductor =< 3.9)
Size factors computed from the counts for endogenous genes are usually not appropriate for normalizing the counts for spike-in transcripts. The normalization we implemented in the previous step corrects for RNA content. HOwever, spike-in transcripts are not affected by RNA content, as we theoretically added the same amount to each sample. Therefore, using gene-based size factors would "over-normalize" spike-ins. To ensure spike-in normalization is performed correctly, we compute a separate set of size factors for the spike-in set. For each cell, the spike-in-specific size factor is defined as the total count across all transcripts in the spike-in set.

These size factors are stored in a separate field of the `SingleCellExperiment` object by setting `general.use=FALSE` in `computeSpikeFactors()`. This ensures that they will only be used with the spike-in transcripts and not the endogenous genes. Although we are only using spike-ins for quality control, we could use the spike-in size factors to normalize all genes by setting `general.use=TRUE`.
```{r}
PAG_sceset_qc <- computeSpikeFactors(PAG_sceset_qc, type = "ERCC", assay.type = "counts", general.use = FALSE)
# The warning "zero spike-in counts during spike-in normalization" appears because some size factors are 0, which below 1e-8 (see https://github.com/MarioniLab/scran/blob/master/R/computeSpikeFactors.R).
summary(sizeFactors(PAG_sceset_qc, "ERCC"))
length(sizeFactors(PAG_sceset_qc, "ERCC"))
which(sizeFactors(PAG_sceset_qc, "ERCC") < 1e-8)

# To overcome this inconvenience, we add 1e-7 to each spike-in size factor. This should be okay as it is a change barely above this limit and it allows us to circumvent the warning and run normalize() later on. Otherwise normalize() requires all size factors to be positive real numbers, and unlike computeSizeFactors(), computeSpikeFactors() does not have a postive=TRUE argument as input.
sizeFactors(PAG_sceset_qc, "ERCC") <- sizeFactors(PAG_sceset_qc, "ERCC") + 1e-8
summary(sizeFactors(PAG_sceset_qc, "ERCC"))
which(sizeFactors(PAG_sceset_qc, "ERCC") < 1e-8)
```

The two sets of size factors tend to agree less due to the effects of heterogeneity in total RNA content between cells - this is expected.
```{r}
plot(sizeFactors(PAG_sceset_qc, 'ERCC'), 
     sizeFactors(PAG_sceset_qc),
     log = "xy", 
     xlab = "Size factor (ERCC)", 
     ylab = "Size factor (genes)", 
     col = c(rgb(255, 119, 124, 255/2, maxColorValue = 255), rgb(0, 156, 181, 255/3, maxColorValue = 255))[factor(PAG_sceset_qc$cell.type)],
     type = "p", pch = 19, cex = 1.25)
legend("bottomleft", col = c(rgb(255, 119, 124, 255/2, maxColorValue = 255), rgb(0, 156, 181, 255/3, maxColorValue = 255)), pch = 19, cex = 1.25,  bty = "n",
       legend = levels(factor(PAG_sceset_qc$cell.type)))
```

_If we were to apply the the spike-in factors to all counts, we would set `general.use=TRUE` and use the `computeSpikeFactors` method to estimate size factors for all cells. This would compute the total count over all spike-in transcripts in each cell, and calculate size factors to equalize the total spike-in count across cells. Finally, running normalize would use the spike-in-based size factors to compute normalized log-expression values, and unlike what we actually did, we would not have to define separate size factors for the spike-in transcripts, as the relevant factors would already be used for all genes and spike-in transcripts when `general.use=TRUE`._

# STEP 4 | Modelling technical and biological variability in gene expression to identify highly variable genes
## PATH "A" to feature selection - trendVar (Bioconductor =< 3.9)
### Step 4a.1 | Modelling the technical component of variation
Variability in the observed expression values across genes can be driven by genuine biological heterogeneity or uninteresting technical noise. To distinguish between these two possibilties, we need to model the technical component of the variance of the expression values for each gene. 

We will use the `trendVar()` function to fit a mean-variance trend to the read counts.

* We can set `block=` to block on the plate/animal of origin for each cell, to ensure that technical differences between plates do not inflate the variances. This involves estimating the mean and variance of the log-expression separately in each plate, followed by fitting a single trend to the plate-specific means and variances of all spike-in transcripts. In doing so, we implicitly assume that the trend is the same between plates. The use of `block=` also assumes that the average size factor within each plate is close to unity for both endogenous genes and spike-in transcripts.
* Some tuning of trend parameters such as `span` may be required to achieve a suitable fit (default is 0.75).
* Setting `parametric=TRUE` is especially useful for modelling the expected wave-like shape of the mean-variance relationship. (This is not the default setting as it is not robust for arbitrary trend shapes.)

In addition, the `trendVar` function automatically filters out low-abundance genes prior to trend fitting. This ensures that low-abundance genes do not interfere with the fit due to discreteness, which biases the estimate of variability of the variances around the trend; or due to the frequency of low-abundance genes, which reduces the sensitivity of span-based smoothing algorithms at higher abundances. The internal choice of filtering strategy involves a number of considerations:

* Filtering uses the average of log-expression values rather than the (library size-adjusted) average count. The mean log-expression is independent of the variance estimate in a linear modelling framework (Bourgon, Gentleman, and Huber 2010), which ensures that the filter does not introduce spurious trends in the variances at the filter boundary.
* The filter threshold is specified with the `min.mean` argument in `trendVar`. We use the default threshold of 0.1 (`min.mean`) based on the appearance of discrete patterns in the variance estimates for simulated Poisson-distributed counts. Lower thresholds of 0.001-0.01 may be more suitable for very sparse data, e.g., from droplet-based protocols.
* The filter used in `trendVar` is not applied in `decomposeVar` by default. Retention of all genes ensures that weak biological signal from rare subpopulations is not discarded. To apply the filter in `decomposeVar`, users should set `subset.row=rowMeans(logcounts(sce)) > 0.1` in the function call.

__One last comment from Aaron Lun__: On occasion, users may observe a warning from `trendVar()` about the lack of centering in the size factors. Recall that the trend is fitted to the mean and variances of the spike-in transcripts, and the technical component for each endogenous gene is estimated by interpolation. This assumes that an endogenous gene is comparable to a spike-in transcript of the same abundance. In particular, we assume that variation is primarily driven by the magnitude of the counts, based on the well-known mean-variance relationships in count models. Thus, we need to ensure that similarities in the average counts are preserved in the normalized expression values. This is achieved by centering the gene- and spike-in-based size factors in `normalize()`, such that features with similar average counts will also have similar normalized abundances. However, if the `SingleCellExperiment` object was manipulated (e.g., subsetted) after `normalize()` and before `trendVar()`, centering may not be preserved - hence the warning.

#### 4a.1.1 | Using spike-ins
One way to do so is using the set of spike-in transcripts. These were in theory added in the same quantity to each cell. Thus, the spike-in transcripts should exhibit non-biological variability, i.e., any variance in their counts should be technical in origin.

We use the `trendVar()` function to fit a mean-dependent trend to the variances of the log-expression values for the spike-in transcripts. Given the mean abundance of a gene, the fitted value of the trend is then used as an estimate of the technical component for that gene. The biological component of the variance is finally calculated by subtracting the technical component from the total variance of each gene with the `decomposeVar` function.
```{r}
# Fit variance-mean trend without blocking
start_time <- Sys.time() # Takes around 1s
var_fit_spikes <- trendVar(PAG_sceset_qc_norm,
                           #method="loess",
                           use.spikes=TRUE, 
                           parametric=TRUE,
                           min.mean=0.1,
                           loess.args=list(span=0.3)
                           ) 

var_out_spikes <- decomposeVar(PAG_sceset_qc_norm, var_fit_spikes)
head(var_out_spikes)
end_time <- Sys.time()
end_time - start_time

# Fit variance-mean trend blocking on mouse.id
start_time <- Sys.time() # Takes around 2s
var_fit_spikes_mouseid <- trendVar(PAG_sceset_qc_norm,
                                   #method="loess",
                                   use.spikes=TRUE, 
                                   parametric=TRUE, 
                                   block=PAG_sceset_qc_norm$mouse.id, # Try PAG_sceset_qc_norm$mouse.id/batch.processing
                                   min.mean=0.1,
                                   loess.args=list(span=0.3)
                                   ) 

var_out_spikes_mouseid <- decomposeVar(PAG_sceset_qc_norm, var_fit_spikes_mouseid)
head(var_out_spikes_mouseid)
end_time <- Sys.time()
end_time - start_time

# Fit variance-mean trend blocking on batch.processing
start_time <- Sys.time() # Takes around 2s
var_fit_spikes_batch <- trendVar(PAG_sceset_qc_norm,
                                 #method="loess",
                                 use.spikes=TRUE, 
                                 parametric=TRUE, 
                                 block=PAG_sceset_qc_norm$batch.processing, # Try PAG_sceset_qc_norm$mouse.id/batch.processing
                                 min.mean=0.1,
                                 loess.args=list(span=0.3)
                                 ) 

var_out_spikes_batch <- decomposeVar(PAG_sceset_qc_norm, var_fit_spikes_batch)
head(var_out_spikes_batch)
end_time <- Sys.time()
end_time - start_time
```

We visually inspect the trend to confirm that it corresponds to the spike-in variances. A wave-like shape is typical of the mean-variance trend for log-expression values. A linear increase in the variance is observed as the mean increases from zero, as larger variances are possible when the counts increase. At very high abundances, the effect of sampling noise decreases due to the law of large numbers, resulting in a decrease in the variance.
```{r}
# Plot variance-mean trend without blocking
plot(var_out_spikes$mean, 
     var_out_spikes$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression",
     ylab="Variance of log-expression")

curve(var_fit_spikes$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm)
points(var_out_spikes$mean[current_spikes], var_out_spikes$total[current_spikes], col="red", pch=16)

# Plot variance-mean trend blocking on mouse.id
plot(var_out_spikes_mouseid$mean, 
     var_out_spikes_mouseid$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression - block on mouse.id",
     ylab="Variance of log-expression")

curve(var_fit_spikes_mouseid$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm)
points(var_out_spikes_mouseid$mean[current_spikes], var_out_spikes_mouseid$total[current_spikes], col="red", pch=16)

# Plot variance-mean trend blocking on batch.processing
plot(var_out_spikes_batch$mean, 
     var_out_spikes_batch$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression - block on batch.processing",
     ylab="Variance of log-expression")

curve(var_fit_spikes_batch$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm)
points(var_out_spikes_batch$mean[current_spikes], var_out_spikes_batch$total[current_spikes], col="red", pch=16)
```

***
Notes from Aaron Lun's `simpleSingleCell` workflow:

* In practice, trend fitting is complicated by the small number of spike-in transcripts and the uneven distribution of their abundances. In the absence of spike-ins or as an alternative approach, we can set `use.spikes=FALSE` to fit a trend to the variances of the endogenous genes (see 4.1.2). Another alternative would be to create a trend based on the assumption of Poisson technical noise.
* Negative biological components are often obtained from `decomposeVar`. These are intuitively meaningless as it is impossible for a gene to have total variance below technical noise. Nonetheless, such values occur due to imprecise estimation of the total variance, especially for low numbers of cells.
* `decomposeVar` also yields p-values that can be used to define highly variable genes (HVGs) at a specific threshold for the false discovery rate (FDR). We will discuss this in more detail later, as formal detection of HVGs is not necessary for feature selection during data exploration.

#### 4a.1.2 | Without spike-ins
Ideally, the technical component would be estimated by fitting a mean-variance trend to the spike-in transcripts using the `trendVar` function as we have seen before. In practice, this strategy is compromised by the small number of spike-in transcripts, the uneven distribution of their abundances, and (for low numbers of cells) the imprecision of their variance estimates. This makes it difficult to accurately fit a complex mean-dependent trend to the spike-in variances. In some datasets, spike-in RNA may not have been added in appropriate quantities (or indeed at all). It may also be inappropriate to assume Poisson technical noise with `makeTechTrend()`, especially for read count data where amplification noise is non-negligible. In such cases, an alternative approach is to fit the trend to the variance estimates of the endogenous genes, using the `use.spikes=FALSE` setting. This assumes that the majority of genes are not variably expressed, such that the technical component dominates the total variance for those genes. The fitted value of the trend is then used as an estimate of the technical component. 

__NB__: fitting the trend to the variances of the genes with `use.spikes=FALSE` probably overestimates the technical component.
```{r}
# Fit variance-mean trend without blocking
start_time <- Sys.time() # Takes around 5s
var_fit_no_spikes <- trendVar(PAG_sceset_qc_norm, 
                              method="loess", 
                              use.spikes=FALSE,
                              parametric=TRUE,
                              #block=PAG_sceset_qc_norm$mouse.id, # Try PAG_sceset_qc_norm$mouse.id/batch.processing
                              min.mean=0.1,
                              loess.args=list(span=0.3)
                              ) 
var_out_no_spikes <- decomposeVar(PAG_sceset_qc_norm, var_fit_no_spikes)
head(var_out_no_spikes)
end_time <- Sys.time()
end_time - start_time

# Fit variance-mean trend blocking on mouse.id
start_time <- Sys.time() # Takes around 20min
var_fit_no_spikes_mouseid <- trendVar(PAG_sceset_qc_norm, 
                                      method="loess", 
                                      use.spikes=FALSE,
                                      parametric=TRUE,
                                      block=PAG_sceset_qc_norm$mouse.id, # Try PAG_sceset_qc_norm$mouse.id/batch.processing
                                      min.mean=0.1,
                                      loess.args=list(span=0.3)
                                      ) 
var_out_no_spikes_mouseid <- decomposeVar(PAG_sceset_qc_norm, var_fit_no_spikes_mouseid)
head(var_out_no_spikes_mouseid)
end_time <- Sys.time()
end_time - start_time

# Fit variance-mean trend blocking on batch.processing
start_time <- Sys.time() # Takes around 20min
var_fit_no_spikes_batch <- trendVar(PAG_sceset_qc_norm, 
                                    method="loess", 
                                    use.spikes=FALSE,
                                    parametric=TRUE,
                                    block=PAG_sceset_qc_norm$batch.processing, # Try PAG_sceset_qc_norm$mouse.id/batch.processing
                                    min.mean=0.1,
                                    loess.args=list(span=0.3)
                                    ) 
var_out_no_spikes_batch  <- decomposeVar(PAG_sceset_qc_norm, var_fit_no_spikes_batch)
head(var_out_no_spikes_batch)
end_time <- Sys.time()
end_time - start_time
```

We assess the suitability of the trend fitted to the endogenous variances by examining whether it is consistent with the spike-in variances. If the trend passes through or close to most of the spike-in variances, this indicates that our assumption (that most genes have low levels of biological variability) is valid. This strategy exploits the large number of endogenous genes to obtain a stable trend, with the spike-in transcripts used as diagnostic features rather than in the trend fitting itself. However, if our assumption does not hold, we would instead fit the trend directly to the spike-in variances with the default use.spikes=TRUE. This sacrifices stability to reduce systematic errors in the estimate of the biological component for each gene.
```{r}
# Plot variance-mean trend without blocking
plot(var_out_no_spikes$mean, 
     var_out_no_spikes$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression", 
     ylab="Variance of log-expression")

curve(var_fit_no_spikes$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm) 
points(var_out_no_spikes$mean[current_spikes], var_out_no_spikes$total[current_spikes], col="red", pch=16)

# Plot variance-mean trend blocking on mouse.id
plot(var_out_no_spikes_mouseid$mean, 
     var_out_no_spikes_mouseid$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression - block on mouse.id", 
     ylab="Variance of log-expression")

curve(var_fit_no_spikes_mouseid$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm) 
points(var_out_no_spikes_mouseid$mean[current_spikes], var_out_no_spikes_mouseid$total[current_spikes], col="red", pch=16)

# Plot variance-mean trend blocking on batch.processing
plot(var_out_no_spikes_batch$mean, 
     var_out_no_spikes_batch$total, 
     pch=16, cex=0.6, 
     xlab="Mean log-expression - block on batch.processing", 
     ylab="Variance of log-expression")

curve(var_fit_no_spikes_batch$trend(x), add=TRUE, col="dodgerblue", lwd=2)
current_spikes <- isSpike(PAG_sceset_qc_norm) 
points(var_out_no_spikes_batch$mean[current_spikes], var_out_no_spikes_batch$total[current_spikes], col="red", pch=16)
```

### Step 4a.2 | Identifying highly variable genes
HVGs are defined as genes with biological components that are significantly greater than zero. These genes are interesting as they drive differences in the expression profiles between cells, and should be prioritized for further investigation. Formal detection of HVGs allows us to avoid genes that are highly variable due to technical factors such as sampling noise during RNA capture and library preparation. This adds another level of statistical rigour to our previous analyses, in which we only modelled the technical component.

Identifying HVGs requires estimation of the variance in expression for each gene, followed by decomposition of the variance into biological and technical components (done in the previous step). HVGs are then identified as those genes with the largest biological components. 

We define HVGs as genes with biological components that are significantly greater than zero at a false discovery rate (FDR) of 5% or 1%. These genes are interesting as they drive differences in the expression profiles between cells, and should be prioritized for further investigation. In addition, we could consider a gene to be a HVG only if it has a biological component greater than or equal to 0.5. For transformed expression values on the log2 scale, this would mean that the average difference in true expression between any two cells will be at least 2-fold. (This reasoning assumes that the true log-expression values are Normally distributed with variance of 0.5. The root-mean-square of the difference between two values is treated as the average log2-fold change between cells and is equal to unity.) We rank the results by the biological component to focus on genes with larger biological variability.
```{r}
# Consider playing with the $FDR threshold and the $bio threshold, try reducing/increasing them to make them more stringent or to get more genes.

# from trendVar with spikes
hvg_out_spikes <- var_out_spikes[which(var_out_spikes$FDR <= 0.05 & var_out_spikes$bio > 0.5), ]
nrow(hvg_out_spikes)

hvg_out_spikes_mouseid <- var_out_spikes_mouseid[which(var_out_spikes_mouseid$FDR <= 0.05 & var_out_spikes_mouseid$bio > 0.5), ]
nrow(hvg_out_spikes_mouseid)

hvg_out_spikes_batch <- var_out_spikes_batch[which(var_out_spikes_batch$FDR <= 0.05 & var_out_spikes_batch$bio > 0.5), ]
nrow(hvg_out_spikes_batch)


# from trendVar without spikes
hvg_out_no_spikes <- var_out_no_spikes[which(var_out_no_spikes$FDR <= 0.05 & var_out_no_spikes$bio > 0.5), ]
nrow(hvg_out_no_spikes)

hvg_out_no_spikes_mouseid <- var_out_no_spikes_mouseid[which(var_out_no_spikes_mouseid$FDR <= 0.05 & var_out_no_spikes_mouseid$bio > 0.5), ]
nrow(hvg_out_no_spikes_mouseid)

hvg_out_no_spikes_batch <- var_out_no_spikes_batch[which(var_out_no_spikes_batch$FDR <= 0.05 & var_out_no_spikes_batch$bio > 0.5), ]
nrow(hvg_out_no_spikes_batch)
```

#### 4a.2.1 | Rank and filter the results
We rank the results to focus on genes with larger biological components. This highlights an interesting aspect of the underlying hypothesis test, which is based on the ratio of the total variance to the expected technical variance. Ranking based on p-value tends to prioritize HVGs that are more likely to be true positives but, at the same time, less likely to be interesting. This is because the ratio can be very large for HVGs that have very low total variance and do not contribute much to the cell-cell heterogeneity.
```{r}
# from trendVar with spikes
hvg_out_spikes <- hvg_out_spikes[order(hvg_out_spikes$bio, decreasing=TRUE), ]
nrow(hvg_out_spikes)
head(hvg_out_spikes)

hvg_out_spikes_mouseid <- hvg_out_spikes_mouseid[order(hvg_out_spikes_mouseid$bio, decreasing=TRUE), ]
nrow(hvg_out_spikes_mouseid)
head(hvg_out_spikes_mouseid)

hvg_out_spikes_batch <- hvg_out_spikes_batch[order(hvg_out_spikes_batch$bio, decreasing=TRUE), ]
nrow(hvg_out_spikes_batch)
head(hvg_out_spikes_batch)

# from trendVar without spikes
hvg_out_no_spikes <- hvg_out_no_spikes[order(hvg_out_no_spikes$bio, decreasing=TRUE), ]
nrow(hvg_out_no_spikes)
head(hvg_out_no_spikes)

hvg_out_no_spikes_mouseid <- hvg_out_no_spikes_mouseid[order(hvg_out_no_spikes_mouseid$bio, decreasing=TRUE), ]
nrow(hvg_out_no_spikes_mouseid)
head(hvg_out_no_spikes_mouseid)

hvg_out_no_spikes_batch <- hvg_out_no_spikes_batch[order(hvg_out_no_spikes_batch$bio, decreasing=TRUE), ]
nrow(hvg_out_no_spikes_batch)
head(hvg_out_no_spikes_batch)
```

__One important thing...__
Before moving on to downstream analysis, we consider dropping any Ribosomal, Mitochondrial, ERCC, sex-specific genes (e.g. XIST), transgenes (EYFP, tdTomato, Cre, TSO concatemers) and genes used for transgenic labeling of cells (VGAT and VGluT2) from the dataset, as some of them are not be biologically informative and others have been used to select the cells. We do so for both our `SingleCellExperiment` object and for the different HVGs:
```{r}
# Identify the genes we want to drop:
is_X_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "X") # Find which genes correspond to chromosome X 
is_Y_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "Y") # Find which genes correspond to chromosome Y
is_feature_control_qc_norm <- (rowData(PAG_sceset_qc_norm)$is_feature_control) # Find genes assigned to feature controls (ERCC, Mitochondrial, Ribosomal, tdTomato, EYFP, Cre, TSO concatemers, VGAT, VGluT2)

filter_genes_qc_norm <- !(is_X_qc_norm | is_Y_qc_norm | is_feature_control_qc_norm)

# Apply the filter to the SingleCellExperiment object:
dim(PAG_sceset_qc_norm)
PAG_sceset_qc_norm_filt <- PAG_sceset_qc_norm[filter_genes_qc_norm, ]
dim(PAG_sceset_qc_norm_filt)

# Apply the filter to the HVGs:
filt_hvg_1 <- rownames(hvg_out_spikes) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_spikes_filt <- hvg_out_spikes[filt_hvg_1, ]
nrow(hvg_out_spikes_filt)

filt_hvg_2 <- rownames(hvg_out_spikes_mouseid) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_spikes_mouseid_filt <- hvg_out_spikes_mouseid[filt_hvg_2,]
nrow(hvg_out_spikes_mouseid_filt)

filt_hvg_3 <- rownames(hvg_out_spikes_batch) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_spikes_batch_filt <- hvg_out_spikes_batch[filt_hvg_3,]
nrow(hvg_out_spikes_batch_filt)

filt_hvg_4 <- rownames(hvg_out_no_spikes) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_no_spikes_filt <- hvg_out_no_spikes[filt_hvg_4,]
nrow(hvg_out_no_spikes_filt)

filt_hvg_5 <- rownames(hvg_out_no_spikes_mouseid) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_no_spikes_mouseid_filt <- hvg_out_no_spikes_mouseid[filt_hvg_5,]
nrow(hvg_out_no_spikes_mouseid_filt)

filt_hvg_6 <- rownames(hvg_out_no_spikes_batch) %in% rownames(PAG_sceset_qc_norm_filt)
hvg_out_no_spikes_batch_filt <- hvg_out_no_spikes_batch[filt_hvg_6,]
nrow(hvg_out_no_spikes_batch_filt)
```

#### 4a.2.2 | Visualize, store, and export HVGs
Now that we have removed the genes we are not interested in, we can use `limma` and `vennDiagram` to compare how many genes we get in each condition with or without spike-ins, and with or without blocking:
```{r}
library(limma)
#####
# Inspect the overlap between HVGs obtained with or without using spike-ins to fit a variance trend:
sum(rownames(hvg_out_spikes_filt) %in% rownames(hvg_out_no_spikes_filt))
sum(rownames(hvg_out_no_spikes_mouseid_filt) %in% rownames(hvg_out_spikes_mouseid_filt))
sum(rownames(hvg_out_no_spikes_batch_filt) %in% rownames(hvg_out_spikes_batch_filt))
venn_diag_spikes_nospikes <- vennCounts(cbind(rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_filt),
                                              rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_filt))
                                        )

vennDiagram(venn_diag_spikes_nospikes,
            names = c("Spikes", "No_Spikes"),
            circle.col = c("#E69F00", "#56B4E9")
            )
venn_diag_spikes_nospikes_mouseid <- vennCounts(cbind(rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_mouseid_filt),
                                                      rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_mouseid_filt))
                                                )

vennDiagram(venn_diag_spikes_nospikes_mouseid,
            names = c("Spikes_MouseID", "No_Spikes_MouseID"),
            circle.col = c("#E69F00", "#56B4E9")
            )

venn_diag_spikes_nospikes_batch <- vennCounts(cbind(rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_batch_filt),
                                                    rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_batch_filt))
                                              )
vennDiagram(venn_diag_spikes_nospikes_batch,
            names = c("Spikes_Batch", "No_Spikes_Batch"),
            circle.col = c("#E69F00", "#56B4E9")
            )

#####
# Inspect the overlap between HVGs obtained using spike-ins to fit a variance trend, and with or without blocking:
sum(rownames(hvg_out_spikes_filt) %in% rownames(hvg_out_spikes_mouseid_filt))
sum(rownames(hvg_out_spikes_batch_filt) %in% rownames(hvg_out_spikes_mouseid_filt))
sum(rownames(hvg_out_spikes_filt) %in% rownames(hvg_out_spikes_batch_filt))
venn_diag_spikes <- vennCounts(cbind(rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_filt),
                                     rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_mouseid_filt),
                                     rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_spikes_batch_filt))
                               )
vennDiagram(venn_diag_spikes,
            names = c("Spikes", "Spikes_MouseID", "Spikes_Batch"),
            circle.col = c("#E69F00", "#56B4E9", "#009E73")
            )

#####
# Inspect the overlap between HVGs obtained without using spike-ins to fit a variance trend, and with or without blocking:
sum(rownames(hvg_out_no_spikes_mouseid_filt) %in% rownames(hvg_out_no_spikes_filt))
sum(rownames(hvg_out_no_spikes_batch_filt) %in% rownames(hvg_out_no_spikes_filt))
sum(rownames(hvg_out_no_spikes_batch_filt) %in% rownames(hvg_out_no_spikes_mouseid_filt))
venn_diag_no_spikes <- vennCounts(cbind(rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_filt),
                                        rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_mouseid_filt),
                                        rownames(PAG_sceset_qc_norm_filt) %in% rownames(hvg_out_no_spikes_batch_filt))
                                  )
vennDiagram(venn_diag_no_spikes,
            names = c("No_Spikes", "No_Spikes_MouseID", "No_Spikes_Batch"),
            circle.col = c("#E69F00", "#56B4E9", "#009E73")
            )
```

Taking into account the above Venn Diagrams, the plots of the mean-variance trend we obtained in `Step 4a.1`, and the profiles and total numbers of HVGs selected by each approach, we will proceed by using the HVGs obtained without using spike-ins and without blocking, the trend and variance-mean plot of which achieves the best compromise between spike-ins and endogenous genes.

Before we store the identified HVGs in our `SingleCellExperiment` object, we check the distribution of expression values for the genes with the largest biological components to ensure that the variance estimate is not being dominated by one or two outlier cells.
```{r}
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))

#plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_spikes_filt)[1:20]) + fontsize
#plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_spikes_mouseid_filt)[1:20]) + fontsize
#plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_spikes_batch_filt)[1:20]) + fontsize

plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_no_spikes_filt)[1:50]) + fontsize
#plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_no_spikes_mouseid_filt)[1:20]) + fontsize
#plotExpression(PAG_sceset_qc_norm_filt, features=rownames(hvg_out_no_spikes_batch_filt)[1:20]) + fontsize
```

Now that we have ordered, filtered, and inspected the identified HVGs we can add the results into the `metadata` component of the `PAG_sceset_qc_norm_filt` object. The metadata component can hold any object, as it is a list container. Any results that we’d like to keep are safe to store here, and a great way to save or share intermediate results that would otherwise be kept in separate objects. Even though we have decided to use the HVGs identified by fitting `trendVar` to the endogenous genes (i.e. without using spike-ins) without any blocking factor, we store the HVGs from the different approaches we used (even without filtering) so we can go back and find them again for any future comparisons we might want to do:
```{r}
# hvg_out_spikes
metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes <- rownames(hvg_out_spikes)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_filt <- rownames(hvg_out_spikes_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_filt)

# hvg_out_spikes_mouseid
metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_mouseid <- rownames(hvg_out_spikes_mouseid)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_mouseid)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_mouseid_filt <- rownames(hvg_out_spikes_mouseid_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_mouseid_filt)

# hvg_out_spikes_batch
metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_batch <- rownames(hvg_out_spikes_batch)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_batch)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_batch_filt <- rownames(hvg_out_spikes_batch_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_spikes_batch_filt)

# hvg_out_no_spikes
metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes <- rownames(hvg_out_no_spikes)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_filt <- rownames(hvg_out_no_spikes_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_filt)

# hvg_out_no_spikes_mouseid
metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_mouseid <- rownames(hvg_out_no_spikes_mouseid)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_mouseid)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_mouseid_filt <- rownames(hvg_out_no_spikes_mouseid_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_mouseid_filt)

# hvg_out_no_spikes_batch
metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_batch <- rownames(hvg_out_no_spikes_batch)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_batch)

metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_batch_filt <- rownames(hvg_out_no_spikes_batch_filt)
length(metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_batch_filt)
```

We can also export them into a `.tsv` file:
```{r}
# Before filtering unwanted genes:
#write.table(file="PAG_hvg_out_spikes.tsv", hvg_out_spikes, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_spikes_mouseid.tsv", hvg_out_spikes_mouseid, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_spikes_batch.tsv", hvg_out_spikes_batch, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_no_spikes.tsv", hvg_out_no_spikes, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_no_spikes_mouseid.tsv", hvg_out_no_spikes_mouseid, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_no_spikes_batch.tsv", hvg_out_no_spikes_batch, sep="\t", quote=FALSE, col.names=NA)

# After filtering unwanted genes:
#write.table(file="PAG_hvg_out_spikes_filt.tsv", hvg_out_spikes_filt, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_spikes_mouseid_filt.tsv", hvg_out_spikes_mouseid_filt, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_spikes_batch_filt.tsv", hvg_out_spikes_batch_filt, sep="\t", quote=FALSE, col.names=NA)
write.table(file="PAG_hvg_out_no_spikes_filt.tsv", hvg_out_no_spikes_filt, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_no_spikes_mouseid_filt.tsv", hvg_out_no_spikes_mouseid_filt, sep="\t", quote=FALSE, col.names=NA)
#write.table(file="PAG_hvg_out_no_spikes_batch_filt.tsv", hvg_out_no_spikes_batch_filt, sep="\t", quote=FALSE, col.names=NA)
```

***
Notes from Aaron Lun's `simpleSingleCell` workflow:

One reason to use the variance of the log-expression values is the fact that the log-transformation protects against genes with strong expression in only one or two cells. This reduces the risk that the set of top HVGs is not dominated by genes with (mostly uninteresting) outlier expression patterns. There are, however, many other strategies for defining HVGs, based on a variety of metrics:

* the coefficient of variation, using the `technicalCV2()` function (Brennecke et al. 2013) or the `DM()` function (Kim et al. 2015) in _scran_.
* the dispersion parameter in the negative binomial distribution, using the `estimateDisp()` function in _edgeR_ (McCarthy, Chen, and Smyth 2012).
* a proportion of total variability, using methods in the _BASiCS_ package (Vallejos, Marioni, and Richardson 2015).

### Step 4a.3 | Identifying correlated gene pairs with Spearman's rho
Another useful procedure is to identify the HVGs that are highly correlated with one another. This distinguishes between HVGs caused by random noise and those involved in driving systematic differences between subpopulations. Correlations between genes can be quantified by computing Spearman's rho, which accommodates non-linear relationships in the expression values. Gene pairs with significantly large positive or negative values of rho are identified using the `correlatePairs()` function. We only apply this function to the set of HVGs, because these genes have large biological components and are more likely to exhibit strong correlations driven by biology. In contrast, calculating correlations for all possible gene pairs would require too much computational time and increase the severity of the multiple testing correction. It may also prioritize uninteresting genes that have strong correlations but low variance, e.g., tightly co-regulated house-keeping genes.
```{r}
# Takes around 1 min
set.seed(1991)
library(scran)

start_time_c1 <- Sys.time()
var.cor <- correlatePairs(PAG_sceset_qc_norm_filt, 
                          subset.row=metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_filt) 
write.table(file="PAG_correlated_genes.tsv", var.cor, sep="\t", quote=FALSE, row.names=FALSE) 
head(var.cor)
end_time_c1 <- Sys.time()
end_time_c1 - start_time_c1
```

The significance of each correlation is determined using a permutation test. For each pair of genes, the null hypothesis is that the expression profiles of two genes are independent. Shuffling the profiles and recalculating the correlation yields a null distribution that is used to obtain a p-value for each observed correlation value (Phipson & Smyth, 2010). Correction for multiple testing across many gene pairs is performed by controlling the FDR at 5%. Correlated gene pairs can be directly used for experimental validation with orthogonal techniques (e.g., fluorescence-activated cell sorting, immunohistochemistry or RNA fluorescence in situ hybridization) to verify that these expression patterns are genuinely present across the cell population.
```{r}
sig.cor <- var.cor$FDR <= 0.05 
summary(sig.cor)
```

The use of `correlatePairs()` is primarily intended to identify correlated gene pairs for validation studies. Obviously, non-zero correlations do not provide evidence for a direct regulatory interaction, let alone specify causality. To construct regulatory networks involving many genes, we suggest using dedicated packages such as _[WGCNA](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/)_.

#### 4a.4.1 | Larger sets of genes
Larger sets of correlated genes are assembled by treating genes as nodes in a graph and each pair of genes with significantly large correlations as an edge. In particular, an undirected graph is constructed using methods in the `RBGL` package. Highly connected subgraphs are then identified and defined as gene sets. This provides a convenient summary of the pairwise correlations between genes.
```{r}
# Takes around 15 min
library(RBGL) 
start_time_c2 <- Sys.time()
g <- ftM2graphNEL(cbind(var.cor$gene1, var.cor$gene2)[sig.cor,], W=NULL, V=NULL, edgemode="undirected")
cl <- highlyConnSG(g)$clusters # Time consuming step
cl <- cl[order(lengths(cl), decreasing=TRUE)] 
head(cl)
end_time_c2 <- Sys.time()
end_time_c2 - start_time_c2
```

Significant correlations provide evidence for substructure in the dataset, i.e., subpopulations of cells with systematic differences in their expression profiles. The number of significantly correlated HVG pairs represents the strength of the substructure. If many pairs were significant, this would indicate that the subpopulations were clearly defined and distinct from one another. 

## PATH "B" to feature selection - M3Drop
__Based on the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group).__

We continue using the `PAG_sceset_qc_norm` after normalization. We should thus have a `logcounts` slot in`assays`:
```{r}
# If starting from stored results, load saved filtered dataset from previous Step:
set.seed(1991)
options(stringsAsFactors = FALSE)
library(SingleCellExperiment)
library(scater)
library(scran)
library(matrixStats)
library(M3Drop)

PAG_sceset_qc_norm <- readRDS("PAG_sceset_qc_norm.rds") # Contains filtered cells and genes, and normalized data
assayNames(PAG_sceset_qc_norm)
PAG_sceset_qc_norm
```

scRNA-seq is capable of measuring the expression of many thousands of genes in every cell. However, in most situations only a portion of those will show a response to the biological condition of interest, e.g. differences in cell-type, drivers of differentiation, respond to an environmental stimulus. Most genes detected in a scRNA-seq experiment will only be detected at different levels due to technical noise. One consequence of this is that technical noise and batch effects can obscure the biological signal of interest. Thus, it is often advantageous to perform feature selection to remove those genes which only exhibit technical noise from downstream analysis. Not only does this generally increase the signal:noise ratio in the data; it also reduces the computational complexity of analyses, by reducing the total amount of data to be processed.

For scRNA-seq data, we will be focusing on unsupervised methods of feature selection which don’t require any a priori information, such as cell-type labels or biological group, since they may not be available, or may be unreliable, for many experiments. In contrast, differential expression can be considered a form of supervised feature selection since it uses the known biological label of each sample to identify features (i.e. genes) which are expressed at different levels across groups.

__One important thing...__
Before identifying HVGs, consider dropping any Ribosomal, Mitochondrial, ERCC, sex-specific genes (e.g. XIST), transgenes (EYFP, tdTomato, Cre, TSO concatemers) and genes used for transgenic labeling of cells (VGAT and VGluT2) from the dataset before proceeding to downstream analysis, as some of them are not be biologically informative and others have been used to select the cells.
```{r}
dim(PAG_sceset_qc_norm)

is_X_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "X") # Find which genes correspond to chromosome X 
is_Y_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "Y") # Find which genes correspond to chromosome Y
is_feature_control_qc_norm <- (rowData(PAG_sceset_qc_norm)$is_feature_control) # Find which genes correspond to feature controls (Ribosomal, Mitochondrial, ERCC, transgenes)

filter_genes_qc_norm <- !(is_X_qc_norm | is_Y_qc_norm | is_feature_control_qc_norm)
PAG_sceset_qc_norm <- PAG_sceset_qc_norm[filter_genes_qc_norm, ]
dim(PAG_sceset_qc_norm)
```

Feature selection is performed after QC. `M3Drop` contains two different feature selection methods `M3DropFeatureSelection` which is based on a Michaelis-Menten curve and is designed for full-transcript single-cell RNA-seq data (such as Smart-seq2) and `NBumiFeatureSelectionCombinedDrop` which is based on a negative binomial model and is designed for UMI count data. We will use the former.

`M3Drop` feature selection runs on a normalized (but not log-transformed) expression matrix. This can be extracted from our `SingleCellExperiment` object using the command below. This function is compatible with most single-cell RNA-seq analysis packages including: `scater`, `SingleCellExperiment`, `monocle`, and `Seurat`. It can also convert an existing expression matrix to the correct form (removing undetected genes & normalizing/delogging) if you specify whether the matrix is raw counts, or log transformed. Check the manual for details.
```{r}
#expr_matrix <- M3Drop::M3DropConvertData(PAG_sceset_qc_norm) #
#expr_matrix <- M3DropConvertData(PAG_sceset_qc_norm@assays[["logcounts_raw"]], is.log=TRUE, is.counts=FALSE)
expr_matrix <- M3DropConvertData(PAG_sceset_qc_norm@assays[["counts"]], is.log=FALSE, is.counts=TRUE)
nrow(counts(PAG_sceset_qc_norm)) - nrow(expr_matrix) # check the ConvertData function has dropped undetected genes
```

### Step 4b.1 | Identifying genes vs a Null Model
There are two main approaches to unsupervised feature selection. The first is to identify genes which behave differently from a null model describing just the technical noise expected in the dataset.

If the dataset contains spike-in RNAs they can be used to directly model technical noise. However, measurements of spike-ins may not experience the same technical noise as endogenous transcripts (Svensson et al., 2017). In addition, scRNA-seq experiments often contain only a small number of spike-ins which reduces our confidence in fitted model parameters. We will not use spike-in transcripts beyond QC in our analysis.

#### 4b.1.1 | Highly Variable Genes
The first method proposed to identify features in scRNA-seq datasets was to identify highly variable genes (HVG). HVG assumes that if genes have large differences in expression across cells some of those differences are due to biological difference between the cells rather than technical noise. However, because of the nature of count data, there is a positive relationship between the mean expression of a gene and the variance in the read counts across cells. This relationship must be corrected for to properly identify HVGs.
```{r}
# Plot the relationship between mean expression and variance for all genes in this dataset:
plot(
    rowMeans(expr_matrix), 
    rowVars(expr_matrix), 
    log="xy", 
    pch=16,
    xlab="Mean Expression", 
    ylab="Variance", 
    main=""
)
```

A popular method to correct for the relationship between variance and mean expression was proposed by [Brennecke et al. 2013](http://www.nature.com/nmeth/journal/v10/n11/full/nmeth.2645.html). To use the Brennecke method, we first normalize for library size and then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A quadratic curve is fit to the relationship between these two variables for the ERCC spike-in, and then a chi-square test is used to find genes significantly above the curve. This method is included in the `M3Drop` package as the `Brennecke_getVariableGenes(counts, spikes)` function. If the dataset does not contain spike-ins we can use the entire dataset to estimate the technical noise.

In the figure below the red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction.
```{r}
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(expr_matrix,
                                                   fdr = 0.01,
                                                   minBiolDisp = 0.5
                                                   )
```

This function returns a matrix of significant genes as well as their estimated effect size (difference between observed and expected coefficient of variation), and their significance as raw p.values and FDR corrected q.values. For now we will just keep the names of the significant HVG genes.
```{r}
HVG_genes <- Brennecke_HVG$Gene
length(HVG_genes)
```

#### 4b.1.2 | High Dropout Genes
An alternative to finding HVGs is to identify genes with unexpectedly high numbers of zeros. The frequency of zeros, known as the "dropout rate", is very closely related to expression level in scRNASeq data. Zeros are the dominant feature of single-cell RNASeq data, typically accounting for over half of the entries in the final expression matrix. These zeros predominantly result from the failure of mRNAs failing to be reversed transcribed (Andrews and Hemberg, 2016). Reverse transcription is an enzyme reaction thus can be modelled using the Michaelis-Menten equation: Pdropout=1−S/(K+S) where S is the mRNA concentration in the cell (we will estimate this as average expression) and K is the Michaelis-Menten constant.

Because the Michaelis-Menten equation is a convex non-linear function, genes which are differentially expression across two or more populations of cells in our dataset will be shifted up/right of the Michaelis-Menten model. We use M3Drop to identify significant outliers to the right of the MM curve. We also apply 1% FDR multiple testing correction:
```{r}
M3Drop_genes <- M3DropFeatureSelection(expr_matrix,
                                       mt_method = "fdr",
                                       mt_threshold = 0.01
                                       )
M3Drop_genes <- M3Drop_genes$Gene
length(M3Drop_genes)
```

### Step 4b.2 | Correlated Expression
A completely different approach to feature selection is to use gene-gene correlations. This method is based on the idea that multiple genes will be differentially expressed between different cell-types or cell-states. Genes which are expressed in the same cell-population will be positively correlated with each other where as genes expressed in different cell-populations will be negatively correated with each other. Thus important genes can be identified by the magnitude of their correlation with other genes.

The limitation of this method is that it assumes technical noise is random and independent for each cell, thus shouldn't produce gene-gene correlations, but this assumption is violated by batch effects which are generally systematic between different experimental batches and will produce gene-gene correlations. As a result it is more appropriate to take the top few thousand genes as ranked by gene-gene correlation than consider the significance of the correlations.
```{r}
cor_feat <- M3Drop::corFS(expr_matrix) # Takes a long time
Cor_genes <- names(cor_feat)[1:1500]
```

### Step 4b.3 | PCA loadings
Lastly, another common method for feature selection in scRNASeq data is to use PCA loadings. Genes with high PCA loadings are likely to be highly variable and correlated with many other variable genes, thus may be relevant to the underlying biology. However, as with gene-gene correlations PCA loadings tend to be susceptible to detecting systematic variation due to batch effects; thus it is recommended to plot the PCA results to determine those components corresponding to the biological variation rather than batch effects.
```{r}
# PCA is typically performed on log-transformed expression data
pca <- prcomp(log(expr_matrix + 1) / log(2))

# plot projection
plot(
    pca$rotation[,1], 
    pca$rotation[,2], 
    pch = 16
)
```

```{r}
# calculate loadings for components 1 and 2
score <- rowSums(abs(pca$x[,c(1,2)])) 
names(score) <- rownames(expr_matrix)
score <- score[order(-score)]
PCA_genes <- names(score[1:1500])
```

```{r}
#Consider the top 5 principal components. Which ones appear to be most biologically relevant? How do the top 1,500 features change if you consider the loadings for those components?
plot(
    pca$rotation[,2], 
    pca$rotation[,3], 
    pch = 16
)

plot(
    pca$rotation[,3], 
    pca$rotation[,4], 
    pch = 16
)

# calculate loadings for components 1 and 2
score <- rowSums(abs(pca$x[,c(2, 3, 4)]))
names(score) <- rownames(expr_matrix)
score <- score[order(-score)]
PCA_genes2 = names(score[1:1500])
```

### Step 4b.4 | Comparing Methods
We can check whether the identified features really do represent genes differentially expressed between cell-types in this dataset.
```{r}
M3DropExpressionHeatmap(M3Drop_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(HVG_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(Cor_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(PCA_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(PCA_genes2,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

We can also consider how consistent each feature selection method is with the others using the Jaccard Index:
```{r}
list_of_features <- list(M3Drop_genes,
                         HVG_genes, 
                         Cor_genes, 
                         PCA_genes, 
                         PCA_genes2
                         )

Out <- matrix(0, 
              ncol = length(list_of_features), 
              nrow = length(list_of_features)
              )

for(i in 1:length(list_of_features) ) {
    for(j in 1:length(list_of_features) ) {
        Out[i,j] <- sum(list_of_features[[i]] %in% list_of_features[[j]])/
            length(unique(c(list_of_features[[i]], list_of_features[[j]])))
     }
}

colnames(Out) <- rownames(Out) <- c("M3Drop", "HVG", "Cor", "PCA", "PCA2")
Out
```

# STEP 5 | Identifying confounding factors, correcting batch effects, and dimensionality reduction
## Step 5.3 | Dimensionality reduction
### 5.3.3 | Denoising expression values using PCA
Another strategy is to retain all PCs until the percentage of total variation explained reaches some threshold. For example, we might retain the top set of PCs that explains 80% of the total variation in the data. Of course, it would be pointless to swap one arbitrary parameter `d` for another `T`. Instead, we derive a suitable value for `T` by calculating the proportion of variance in the data that is attributed to the biological component. This is done using the `denoisePCA()` function with the variance modelling results from `modelGeneVar()` or related functions, where `T` is defined as the ratio of the sum of the biological components to the sum of total variances. Here, explicit feature selection is not strictly necessary, as `denoisePCA()` will automatically restrict the PCA to genes with positive biological components to ensure that `T` is always a positive value. The function returns a `SingleCellExperiment` object containing the PC scores for each cell in the `reducedDims` slot, where cells are rows and PCs are columns. The aim is to eliminate technical noise and enrich for biological signal in the retained PCs. This improves resolution of the underlying biology during downstream procedures such as clustering.

Importantly, this method tends to perform best when the mean-variance trend reflects the actual technical noise, i.e., when it is estimated by `modelGeneVarByPoisson()` or `modelGeneVarWithSpikes()` instead of `modelGeneVar()`. Variance modelling results from `modelGeneVar()` tend to understate the actual biological variation, especially in highly heterogeneous datasets where secondary factors of variation inflate the fitted values of the trend. Fewer PCs are subsequently retained because `T` is artificially lowered. We will thus not be using this method, as we couldn't use spike-ins for our variance modelling.
```{r}
set.seed(1991)

# Run denoisePCA for hvg_var_out_no_spikes_filt
dim(PAG_sceset_qc_norm_filt)
dim(var_model_no_spikes)
var_model_no_spikes$filter <- rownames(var_model_no_spikes) %in% rownames(PAG_sceset_qc_norm_filt)
dim(var_model_no_spikes)
var_model_no_spikes_filt <- var_model_no_spikes[var_model_no_spikes$filter==TRUE, ]
dim(var_model_no_spikes_filt)

PAG_var_denoised <- denoisePCA(PAG_sceset_qc_norm_filt,
                               technical = var_model_no_spikes_filt, 
                               subset.row = metadata(PAG_sceset_qc_norm_filt)$hvg_var_out_no_spikes_filt,
                               assay.type = "logcounts")

print(ncol(reducedDim(PAG_var_denoised, "PCA")))

plotReducedDim(PAG_var_denoised,
               dimred = "PCA",
               colour_by = "cell.type",
               shape_by = "PAG.arearegistration",
               by_exprs_values = "logcounts")

# Run denoisePCA for hvg_var_out_no_spikes_block_filt
dim(PAG_sceset_qc_norm_filt)
dim(var_model_no_spikes_block)
var_model_no_spikes_block$filter <- rownames(var_model_no_spikes_block) %in% rownames(PAG_sceset_qc_norm_filt)
dim(var_model_no_spikes_block)
var_model_no_spikes_block_filt <- var_model_no_spikes_block[var_model_no_spikes_block$filter==TRUE, ]
dim(var_model_no_spikes_block_filt)

PAG_var_block_denoised <- denoisePCA(PAG_sceset_qc_norm_filt,
                                     technical = var_model_no_spikes_block_filt, 
                                     subset.row = metadata(PAG_sceset_qc_norm_filt)$hvg_var_out_no_spikes_block_filt,
                                     assay.type = "logcounts")

print(ncol(reducedDim(PAG_var_block_denoised, "PCA")))

plotReducedDim(PAG_var_block_denoised,
               dimred = "PCA",
               colour_by = "cell.type",
               shape_by = "PAG.arearegistration",
               by_exprs_values = "logcounts")
```

### 5.3.6 | Correlating PCs with experimental and QC variables of interest
`scater` allows us to identify principal components that correlate with experimental and QC variables of interest (it ranks principle components by R^2^ from a linear model regressing PC value against any variable or annotation we have associated with each cell) to see which factor is driving a particular principal component.
```{r}
plotExplanatoryPCs(PAG_sceset_qc_norm_filt,
                   dimred = "PCA_HVG_var_logcounts",
                   n_dimred = 20,
                   nvars_to_plot = 17,
                   npcs_to_plot = 20,                 
                   variables = c("mouse.id",
                                 "mouse.sex",
                                 "mouse.age",
                                 "mouse.singlehousedays",
                                 "cell.type",
                                 "cell.fluorophor",
                                 "slice.number",
                                 "slice.depth",
                                 "PAG.areacollection",
                                 "PAG.hemisphere",
                                 "PAG.APaxis",
                                 "time.sinceslicinghour",
                                 "PAGarea_celltype",
                                 "batch.processing",
                                 "batch.sequencing_round",
                                 "detected",
                                 "total"
                                 )
                   )
```

# STEP 6 | Clustering
## Step 6.1 | Graph-based clustering
### 6.1.2 | Assessing cluster separation
One useful approach is to use the ratio matrix to form another graph where the nodes are clusters rather than cells. Edges between nodes are weighted according to the ratio of observed to expected edge weights between cells in those clusters. We can then repeat our graph operations on this new cluster-level graph. For example, we could obtain clusters of clusters, or we could simply create a new cluster-based layout for visualization. This is analogous to the “graph abstraction” approach described by Wolf et al. 2017.
```{r}
set.seed(1991)
cluster_graph_var_rank <- igraph::graph_from_adjacency_matrix(log2(ratio_var_rank + 1), mode = "upper", weighted = TRUE, diag = FALSE)
# Increasing the weight to increase the visibility of the lines.
plot(cluster_graph_var_rank, edge.width = igraph::E(cluster_graph_var_rank)$weight*5, layout = igraph::layout_with_lgl)

cluster_graph_var_jaccard <- igraph::graph_from_adjacency_matrix(log2(ratio_var_jaccard + 1), mode = "upper", weighted = TRUE, diag = FALSE)
# Increasing the weight to increase the visibility of the lines.
plot(cluster_graph_var_jaccard, edge.width = igraph::E(cluster_graph_var_jaccard)$weight*5, layout = igraph::layout_with_lgl)

cluster_graph_cv2_rank <- igraph::graph_from_adjacency_matrix(log2(ratio_cv2_rank + 1), mode = "upper", weighted = TRUE, diag = FALSE)
plot(cluster_graph_cv2_rank, edge.width = igraph::E(cluster_graph_cv2_rank)$weight*5, layout = igraph::layout_with_lgl)

cluster_graph_cv2_jaccard <- igraph::graph_from_adjacency_matrix(log2(ratio_cv2_jaccard + 1), mode = "upper", weighted = TRUE, diag = FALSE)
plot(cluster_graph_cv2_jaccard, edge.width = igraph::E(cluster_graph_cv2_jaccard)$weight*5, layout = igraph::layout_with_lgl)
```

The graph itself can be visualized using a force-directed layout. This yields a dimensionality reduction result that is closely related to t-SNE and UMAP.
```{r}
set.seed(1991)
reducedDim(PAG_sceset_qc_norm_filt_corr, "force_var") <- igraph::layout_with_fr(graph_var)
plotReducedDim(PAG_sceset_qc_norm_filt_corr, colour_by = "SNN_clusters_var", dimred = "force_var")

reducedDim(PAG_sceset_qc_norm_filt_corr, "force_cv2") <- igraph::layout_with_fr(graph_cv2)
plotReducedDim(PAG_sceset_qc_norm_filt_corr, colour_by = "SNN_clusters_cv2", dimred = "force_cv2")
```

## Step 6.1b | Subclustering or Cell-type specific Graph-based clustering
Another approach to improving resolution is to repeat the feature selection and clustering within a single cluster. This aims to select HVGs and PCs that are more relevant to internal structure, improving resolution by avoiding noise from unnecessary features. Subsetting also encourages clustering methods to separate cells according to more modest heterogeneity in the absence of distinct subpopulations. We can repeat the steps we have done after normalization but subsetting the `SingleCellExperiment` object in excitatory and inhibitory cells:
```{r}
PAG_sceset_qc_norm_filt_corr_VGAT <- PAG_sceset_qc_norm_filt_corr[, PAG_sceset_qc_norm_filt_corr$cell.type=="VGAT"]
PAG_sceset_qc_norm_filt_corr_VGluT2 <- PAG_sceset_qc_norm_filt_corr[, PAG_sceset_qc_norm_filt_corr$cell.type=="VGluT2"]
```

### 6.1b.1 | Implementation of graph-based clustering
```{r}
library(scran)
# Using HVG from Var with rank-based weights
graph_var_rank_VGAT <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGAT,
                                     k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                     #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                     type = "rank", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                     subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_var_out_no_spikes_block_filt,
                                     assay.type = "logcounts",
                                     use.dimred = "PCA_HVG_var_logcounts")
clusters_var_rank_VGAT <- igraph::cluster_walktrap(graph_var_rank_VGAT)$membership
PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_var_rank_VGAT <- factor(clusters_var_rank_VGAT)
table(PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_var_rank_VGAT)

graph_var_rank_VGluT2 <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGluT2,
                                       k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                       #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                       type = "rank", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                       subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_var_out_no_spikes_block_filt,
                                       assay.type = "logcounts",
                                       use.dimred = "PCA_HVG_var_logcounts")
clusters_var_rank_VGluT2 <- igraph::cluster_walktrap(graph_var_rank_VGluT2)$membership
PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_var_rank_VGluT2 <- factor(clusters_var_rank_VGluT2)
table(PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_var_rank_VGluT2)

# Using HVG from Var with jaccard-based weights
graph_var_jaccard_VGAT <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGAT,
                                        k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                        #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                        type = "jaccard", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                        subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_var_out_no_spikes_block_filt,
                                        assay.type = "logcounts",
                                        use.dimred = "PCA_HVG_var_logcounts")
clusters_var_jaccard_VGAT <- igraph::cluster_louvain(graph_var_jaccard_VGAT)$membership
PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_var_jaccard_VGAT <- factor(clusters_var_jaccard_VGAT)
table(PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_var_jaccard_VGAT)

graph_var_jaccard_VGluT2 <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGluT2,
                                          k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                          #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                          type = "jaccard", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                          subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_var_out_no_spikes_block_filt,
                                          assay.type = "logcounts",
                                          use.dimred = "PCA_HVG_var_logcounts")
clusters_var_jaccard_VGluT2 <- igraph::cluster_louvain(graph_var_jaccard_VGluT2)$membership
PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_var_jaccard_VGluT2 <- factor(clusters_var_jaccard_VGluT2)
table(PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_var_jaccard_VGluT2)
 
# Using HVG from CV2 with rank-based weights
graph_cv2_rank_VGAT <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGAT,
                                     k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                     #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                     type = "rank", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                     subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_cv2_out_no_spikes_filt,
                                     assay.type = "logcounts",
                                     use.dimred = "PCA_HVG_cv2_logcounts")
clusters_cv2_rank_VGAT <- igraph::cluster_walktrap(graph_cv2_rank_VGAT)$membership
PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_cv2_rank_VGAT <- factor(clusters_cv2_rank_VGAT)
table(PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_cv2_rank_VGAT)

graph_cv2_rank_VGluT2 <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGluT2,
                                       k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                       #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                       type = "rank", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                       subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_cv2_out_no_spikes_filt,
                                       assay.type = "logcounts",
                                       use.dimred = "PCA_HVG_cv2_logcounts")
clusters_cv2_rank_VGluT2 <- igraph::cluster_walktrap(graph_cv2_rank_VGluT2)$membership
PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_cv2_rank_VGluT2 <- factor(clusters_cv2_rank_VGluT2)
table(PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_cv2_rank_VGluT2)

# Using HVG from CV2 with jaccard-based weights
graph_cv2_jaccard_VGAT <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGAT,
                                        k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                        #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                        type = "jaccard", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                        subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_cv2_out_no_spikes_filt,
                                        assay.type = "logcounts",
                                        use.dimred = "PCA_HVG_cv2_logcounts")
clusters_cv2_jaccard_VGAT <- igraph::cluster_louvain(graph_cv2_jaccard_VGAT)$membership
PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_cv2_jaccard_VGAT <- factor(clusters_cv2_jaccard_VGAT)
table(PAG_sceset_qc_norm_filt_corr_VGAT$SNN_clusters_cv2_jaccard_VGAT)

graph_cv2_jaccard_VGluT2 <- buildSNNGraph(PAG_sceset_qc_norm_filt_corr_VGluT2,
                                          k = 10, # An integer scalar specifying the number of nearest neighbors to consider during graph construction.
                                          #d = 50, # An integer scalar specifying the number of dimensions to use for the search.
                                          type = "jaccard", # A string specifying the type of weighting scheme to use for shared neighbors. Try "rank" or "jaccard"
                                          subset.row = metadata(PAG_sceset_qc_norm_filt_corr)$hvg_cv2_out_no_spikes_filt,
                                          assay.type = "logcounts",
                                          use.dimred = "PCA_HVG_cv2_logcounts")
clusters_cv2_jaccard_VGluT2 <- igraph::cluster_louvain(graph_cv2_jaccard_VGluT2)$membership
PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_cv2_jaccard_VGluT2 <- factor(clusters_cv2_jaccard_VGluT2)
table(PAG_sceset_qc_norm_filt_corr_VGluT2$SNN_clusters_cv2_jaccard_VGluT2)
```

```{r}
# VGAT cells
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGAT, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "PAG.arearegistration", shape_by = "VGAT_VGluT2_expression") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from Var with rank-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGAT, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_var_rank_VGAT", text_by = "SNN_clusters_var_rank_VGAT") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from Var with jaccard-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGAT, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_var_jaccard_VGAT", text_by = "SNN_clusters_var_jaccard_VGAT") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from CV2 with rank-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGAT, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_cv2_rank_VGAT", text_by = "SNN_clusters_cv2_rank_VGAT") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from CV2 with jaccard-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGAT, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_cv2_jaccard_VGAT", text_by = "SNN_clusters_cv2_jaccard_VGAT") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")

# VGluT2 cells
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGluT2, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "PAG.arearegistration", shape_by = "VGAT_VGluT2_expression") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from Var with rank-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGluT2, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_var_rank_VGluT2", text_by = "SNN_clusters_var_rank_VGluT2") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from Var with jaccard-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGluT2, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_var_jaccard_VGluT2", text_by = "SNN_clusters_var_jaccard_VGluT2") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from CV2 with rank-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGluT2, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_cv2_rank_VGluT2", text_by = "SNN_clusters_cv2_rank_VGluT2") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
## Using HVG from CV2 with jaccard-based weights
plotReducedDim(PAG_sceset_qc_norm_filt_corr_VGluT2, dimred = "UMAP_var_logcounts_10_neighbors_0.05_min_dist",
               colour_by = "SNN_clusters_cv2_jaccard_VGluT2", text_by = "SNN_clusters_cv2_jaccard_VGluT2") + ggtitle("UMAP_var_logcounts_10_neighbors_0.05_min_dist")
```

### 6.1b.2 | Assessing cluster separation
```{r}
# VGAT
ratio_var_rank_VGAT <- clusterModularity(graph_var_rank_VGAT, clusters_var_rank_VGAT, as.ratio = TRUE)
ratio_var_rank_VGAT

ratio_var_jaccard_VGAT <- clusterModularity(graph_var_jaccard_VGAT, clusters_var_jaccard_VGAT, as.ratio = TRUE)
ratio_var_jaccard_VGAT

ratio_cv2_rank_VGAT <- clusterModularity(graph_cv2_rank_VGAT, clusters_cv2_rank_VGAT, as.ratio = TRUE)
ratio_cv2_rank_VGAT

ratio_cv2_jaccard_VGAT <- clusterModularity(graph_cv2_jaccard_VGAT, clusters_cv2_jaccard_VGAT, as.ratio = TRUE)
ratio_cv2_jaccard_VGAT

# VGluT2
ratio_var_rank_VGluT2 <- clusterModularity(graph_var_rank_VGluT2, clusters_var_rank_VGluT2, as.ratio = TRUE)
ratio_var_rank_VGluT2

ratio_var_jaccard_VGluT2 <- clusterModularity(graph_var_jaccard_VGluT2, clusters_var_jaccard_VGluT2, as.ratio = TRUE)
ratio_var_jaccard_VGluT2

ratio_cv2_rank_VGluT2 <- clusterModularity(graph_cv2_rank_VGluT2, clusters_cv2_rank_VGluT2, as.ratio = TRUE)
ratio_cv2_rank_VGluT2

ratio_cv2_jaccard_VGluT2 <- clusterModularity(graph_cv2_jaccard_VGluT2, clusters_cv2_jaccard_VGluT2, as.ratio = TRUE)
ratio_cv2_jaccard_VGluT2
```

```{r}
library(pheatmap)
# VGAT
pheatmap(log2(ratio_var_rank_VGAT + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_var_jaccard_VGAT + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_cv2_rank_VGAT + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_cv2_jaccard_VGAT + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

# VGluT2
pheatmap(log2(ratio_var_rank_VGluT2 + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_var_jaccard_VGluT2 + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_cv2_rank_VGluT2 + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))

pheatmap(log2(ratio_cv2_jaccard_VGluT2 + 1), 
         cluster_cols = FALSE, cluster_rows = FALSE,
         color = colorRampPalette(c("white", "blue"))(100))
         #col = rev(heat.colors(100)))
```

## Step 6.4 | Consensus clustering with SC3
### 6.4.10 | SC3 Clustering using ion channels genes
Here we will run the same clustering approach but using only ion channel genes instead of all the genes. First we load the list of ion channel genes and keep the ones that are present in our dataset:
```{r}
PAG_ionchannels <- PAG_scRNAseq_gene_lists$genes.ionchannels
sum(PAG_scRNAseq_gene_lists$genes.ionchannels != "") # Ion Channel genes present in the list

# Filter any genes not present in our dataset by comparing the gene names with the rownames of our expression matrix (which contains gene names)
PAG_ionchannels <- PAG_ionchannels[(PAG_ionchannels %in% rownames(PAG_sceset_qc))]
length(PAG_ionchannels) # Ion Channel genes present in the dataset
```

Generate a SCE object with only ion channel genes:
```{r}
# Keep only the rows that correspond to ion channel genes:
PAG_sceset_qc_ionchannels <- PAG_sceset_qc[rownames(PAG_sceset_qc) %in% PAG_ionchannels, ]
dim(PAG_sceset_qc_ionchannels)
```

Estimate K:
```{r}
PAG_sceset_qc_ionchannels <- sc3_estimate_k(PAG_sceset_qc_ionchannels)
metadata(PAG_sceset_qc_ionchannels)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_ionchannels)$feature_symbol <- rownames(PAG_sceset_qc_ionchannels)
PAG_sceset_qc_ionchannels <- sc3(PAG_sceset_qc_ionchannels, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
library(shiny)
sc3_interactive(PAG_sceset_qc_ionchannels)
```

For k=2
```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_ionchannels, 
                   k = 2, 
                   show_pdata = "cell.type"
)

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_ionchannels, 
                 k = 2,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_ionchannels, 
                 k = 2,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

```

Figures for k=3
```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_ionchannels, 
                   k = 3, 
                   show_pdata = "cell.type"
                   )

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_ionchannels, 
                 k = 3,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_ionchannels, 
                 k = 3,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = c("cell.type", "PAG.areacollection")
                 )
```

### 6.4.11 | SC3 Clustering using Neuropeptides and Neuromodulators
Here we will run the same clustering approach but using only ion channel genes instead of all the genes. First we load the list of ion channel genes and keep the ones that are present in our dataset:
```{r}
PAG_Neuromodulators_Peptides <- PAG_scRNAseq_gene_lists$genes.NeuromodulatorsPeptides
length(PAG_Neuromodulators_Peptides) # This won't be the length of the $genes.ionchannels column but the one of the longest column of the .csv file (there will be a lot of empty cells).
#typeof(PAG_ionchannels)

# Filter any genes not present in our dataset by comparing the gene names with the rownames of our expression matrix (which contains gene names)
PAG_Neuromodulators_Peptides <- PAG_Neuromodulators_Peptides[(PAG_Neuromodulators_Peptides %in% rownames(PAG_sceset_qc))]
length(PAG_Neuromodulators_Peptides)
```

Generate a SCE object with only ion channel genes:
```{r}
# Keep only the rows that correspond to ion channel genes:
PAG_sceset_qc_Neuromodulators_Peptides <- PAG_sceset_qc[rownames(PAG_sceset_qc) %in% PAG_Neuromodulators_Peptides, ]
dim(PAG_sceset_qc_Neuromodulators_Peptides)
```

Estimate K:
```{r}
PAG_sceset_qc_Neuromodulators_Peptides <- sc3_estimate_k(PAG_sceset_qc_Neuromodulators_Peptides)
metadata(PAG_sceset_qc_Neuromodulators_Peptides)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_Neuromodulators_Peptides)$feature_symbol <- rownames(PAG_sceset_qc_Neuromodulators_Peptides)
PAG_sceset_qc_Neuromodulators_Peptides <- sc3(PAG_sceset_qc_Neuromodulators_Peptides, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
sc3_interactive(PAG_sceset_qc_Neuromodulators_Peptides)
```

```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_Neuromodulators_Peptides, 
                   k = 2, 
                   show_pdata = "cell.type"
                   )

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_Neuromodulators_Peptides, 
                 k = 2,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_Neuromodulators_Peptides, 
                 k = 2,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )
```

### 6.4.12 | SC3 Clustering ion channels genes instead of cells (need to transpose matrix in a new SCE object)
Run STEP 5.1.2 first, so you already have the subset of genes and the SCE object. Then transpose the SCE object with only ion channel genes you generated in the previous step:
```{r}
# Keep only the rows that correspond to ion channel genes:
dim(PAG_sceset_qc_ionchannels)
# Trying to transpose a SCEset as follows doesn't work, so we have to transpose the original data prior to creating the SCEset
# PAG_sceset_qc_ionchannels_T <- PAG_sceset_qc_ionchannels[colData(PAG_sceset_qc_ionchannels), rowData(PAG_sceset_qc_ionchannels)]
dim(PAG_sceset_qc_ionchannels_T)
```

```{r}
head(PAG_data)
head(PAG_metadata)
PAG_sceset_qc
PAG_sceset_transposed <- SingleCellExperiment(
  assays = list(counts = as.matrix(PAG_data)), 
  colData = PAG_metadata, 
  rowData = PAG_gene_information
)
```

Estimate K:
```{r}
PAG_sceset_qc_ionchannels <- sc3_estimate_k(PAG_sceset_qc_ionchannels)
metadata(PAG_sceset_qc_ionchannels)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_ionchannels)$feature_symbol <- rownames(PAG_sceset_qc_ionchannels)
PAG_sceset_qc_ionchannels <- sc3(PAG_sceset_qc_ionchannels, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
sc3_interactive(PAG_sceset_qc_ionchannels)
```

### 6.4.13 | SC3 Clustering VGAT and VGluT2 cells separately
Do this when you are ready for downstream analysis, after quality checks.  
```{r}
# Is this the best way to subset the data? Probably not, there must be a way to do it without creating a new SCE object.
VGAT_sceset <- PAG_sceset[,grep("^[I]", colnames(PAG_sceset), value=TRUE)]

VGluT2_sceset <- PAG_sceset[,grep("^[E]", colnames(PAG_sceset), value=TRUE)]
```

## Step 6.7 | clusterExperiment [not yet implemented]
## Step 6.8 | bigSCale2
bigSCale is an analytical framework for big-scale single-cell data, available [here](https://github.com/iaconogi/bigSCale2).

```{r}
library(bigscale)
PAG_sceset_qc <- bigscale(PAG_sceset_qc)
```

OR, if you want to run it step by step:
```{r}
# Pre-process the data and generate the model:
PAG_sceset_qc = preProcess(PAG_sceset_qc)
PAG_sceset_qc = storeNormalized(PAG_sceset_qc) # stores normalized data
PAG_sceset_qc = setModel(PAG_sceset_qc) # computes the numerical model
PAG_sceset_qc = storeTransformed(PAG_sceset_qc) # stores transformed expression data (needed for some plots)
viewModel(PAG_sceset_qc) # check the model

# Compute the highly variable genes and we calculate cell to cell distances. 
PAG_sceset_qc = setODgenes(PAG_sceset_qc, min_ODscore=2.33) # min_ODscore is the Z-score treshold for selecting the genes (default 2.33). Increase it to be more stringent (less genes) and viceversa.
viewODgenes(PAG_sceset_qc) # visually inspect the selected highly variable genes

# Compute the distances and the t-SNE:
PAG_sceset_qc = setDistances(PAG_sceset_qc)
PAG_sceset_qc = storeTsne(PAG_sceset_qc)

# Cluster the data
PAG_sceset_qc = setClusters(PAG_sceset_qc)

# Make pseudotime analysis:
PAG_sceset_qc = storePseudo(PAG_sceset_qc)

# Compute the differential expression for all genes. Select speed.preset='slow' for maximum accuracy with long computational time.
PAG_sceset_qc = computeMarkers(PAG_sceset_qc, speed.preset='slow')

# Organize all the genes into markers and signatures of co-expression. cutoff is a Z-score which filters the genes and retains only those with significant changes of expression. Inrease it if you want to be more stringent or viceversa.
PAG_sceset_qc = setMarkers(PAG_sceset_qc, cutoff=3)

# Restore some matrices from the virtual memory to complete the analysis.
PAG_sceset_qc = restoreData(PAG_sceset_qc)
```

Plot of the clusters and signatures of coexpressed genes and visualise:

* The dendrogram representing how the cells are phenotypically organized and clustered.
* Colored bars representing the clusters, the library size (meant as a proxy to transcriptome size/complexity) and the pseudotime of the cells. An additional color bar is displayed for any user custom `colData()` (for example, sample batches, conditions and so on ...). For custom user `colData`, the color codes are automatically chosen upoen the type of data (numeric or factor).
* The clustered signatures of coexpressed genes alogside their size. Here, all the genes differentially expressed are organized in signatures of co-expressed genes.
```{r}
viewSignatures(PAG_sceset_qc)
```

We can also inspect the markers of a specific cluster, with markers of level 1 being the most specific to a given cluster.
```{r}
viewSignatures(PAG_sceset_qc, selected.cluster=2)
```

Barplots and violin plots of selected genes to visualize gene expression at single cell level with colored clusters:
```{r}
viewGeneBarPlot(PAG_sceset_qc, gene.list = c('Aqp4','Olig1','Thy1'))
```

```{r}
viewGeneViolin(PAG_sceset_qc, 'Asic4')
```

t-SNE and UMAP plots:

* If you want to color the cell according to some custom annotation you can pass a `factor` variable in place of a gene name. If you want to visualize a UMAP plot first compute the UMAP data with `sce=storeUMAP(sce)` and then `viewReduced(sce,method = 'UMAP')`
```{r}
viewReduced(PAG_sceset_qc) # to see t-SNE with clusters
viewReduced(PAG_sceset_qc, color.by = 'Stmn2') # to see t-SNE with gene expression
```

Browsing markers:
* To have a look to the markers found by bigscale we retrive `Mlist` from the single cell object. `Mlist` is a 2 dimensional list containing for each cluster the markers of the different levels. Let's inspect the markers of level 1 (most specific) of cluster 4. We will take advantage of the package `DT` for interactive visualization. Running the next command line we will see the markers specific to cluster 4 sorted from the highest (most significant) to the lowest (less significant) Zscore.
```{r}
Mlist = getMarkers(PAG_sceset_qc)
DT::datatable(Mlist[[4,1]])
```

Browsing signatures:
* Alternatevely to a cluster-based organization of the markers (as shown before, we have clusters and we have levels) there is also a more compact organization of markers into lists of co-expressed genes. This are the same lists shown with `viewSignatures(sce)`.
```{r}
Signatures = getSignatures(PAG_sceset_qc)
DT::datatable(Signatures[[1]])
```

## Step 6.9 | BackSPIN - biclustering hierarchical [MATLAB/Python]
The BackSPIN biclustering algorithm was developed by Amit Zeisel and is described in Zeisel et al. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq Science 2015 (PMID: 25700174, doi: 10.1126/science.aaa1934). Please cite this paper if you use the BackSPIN algorithm in your work.

Original MATLAB implementation by Amit Zeisel. This repo contains a standalone command-line version of BackSPIN, implemented in Python by Gioele La Manno (https://github.com/linnarsson-lab/BackSPIN)

## Step 6.10 | SINCERA (hierarchical clustering) [not yet implemented]
It performs a gene-level z-score transformation before doing clustering.
It can also identify k as the minimum height of the hierarchical tree that generates no more than a specified number of singleton clusters (clusters containing only 1 cell).

SINCERA: a computational pipeline for SINgle CEll RNA-seq profiling Analysis, can be used for processing scRNA-seq data from a whole organ or sorted cells. The pipeline supports the analysis for: 1) the distinction and identification of major cell types; 2) the identification of cell type specific gene signatures; and 3) the determination of driving forces of given cell types.

Website: https://research.cchmc.org/pbge/sincera.html
Paper: https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004575

## Step 6.11 | pcaReduce [not yet implemented, but very stochastic and does not provide a stable result] 
pcaReduce combines PCA, k-means and iterative hierarchical clustering. Starting from a large number of clusters pcaReduce iteratively merges similar clusters; after each merging event it removes the principle component explaning the least variance in the data.

pcaReduce operates directly on the expression matrix. It is recommended to use a gene filter and log transformation before running pcaReduce. We will use the default SC3 gene filter (note that the exprs slot of a scater object is log-transformed by default).
```{r}
# use the same gene filter as in SC3
library(pcaReduce) # You need to install PCAReduce first
input <- logcounts(PAG_sceset_qc[rowData(PAG_sceset_qc)$sc3_gene_filter, ])
```

There are several parameters used by pcaReduce: nbt defines a number of pcaReduce runs (it is stochastic and may have different solutions after different runs). q defines number of dimensions to start clustering with. The output will contain partitions for all k from 2 to q+1. method defines a method used for clustering. S - to perform sampling based merging, M - to perform merging based on largest probability.
```{r}
# run pcaReduce 1 time creating hierarchies from 1 to 30 clusters
pca.red <- PCAreduce(t(input), nbt = 1, q = 30, method = 'S')[[1]]
colData(PAG_sceset_qc)$pcaReduce <- as.character(pca.red[,32 - 10])
plotPCA(PAG_sceset_qc, colour_by = "pcaReduce")
```

# STEP 7 | Differential Expression Analysis
## Step 7.1 (old) | Identifying marker genes between subpopulations
### 7.1a.1 | Identify cluster-specific marker genes
We first take a look at the main parameters we will need for our call to `findMarkers()` and reset them to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We can run the following chunk of code several times, changing the parameters for the `test.type`, `pval.type`, `direction`, `lfc`, and others to extract the results of the comparison we want into a .csv file. We also assign the results to separate variables so we can plot them later on.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k8

# Set the string to be added to the filename when saving the results:
results_name <- "SNN_clusters_cv2_jaccard_k8_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
SNN_clusters_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "SNN_clusters/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]]
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
        
        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set) # Assign the results to the created variable
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "SNN_clusters/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        # Populate the summary data.frame:        
        SNN_clusters_marker_set_summary = rbind(SNN_clusters_marker_set_summary,
                                                data.frame(marker_set = marker_set,
                                                           group = levels(groups)[chosen_group],
                                                           test = test,
                                                           comparisons = comparisons,
                                                           direction = direction,
                                                           genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                           genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
      }
    }
  }
}

# Check out the summary: 
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="t",]
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="wilcox",]
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="binom",]
```

If you do all loops you get 297 files. Remove direction "any" as it is the same as having "up" and "down" separately to get 198.

### 7.1a.2 | Marker genes for cell type
Once we have performed pairwise comparisons between the identified clusters, we can move on to perform comparisons according to our experimental design. For this, we will continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_marker_set_summary = rbind(celltype_marker_set_summary,
                                        data.frame(marker_set = marker_set,
                                                   group = levels(groups)[chosen_group],
                                                   test = test,
                                                   comparisons = comparisons,
                                                   direction = direction,
                                                   genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                   genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_marker_set_summary
```

```{r}
#names(metadata(PAG_sceset_qc_norm_filt_corr_clust_de))

VGAT_de_genes <- rownames(marker_set_VGAT_wilcox_all_up[marker_set_VGAT_wilcox_all_up$FDR<0.1, ]) 
VGluT2_de_genes <- rownames(marker_set_VGluT2_wilcox_all_up[marker_set_VGluT2_wilcox_all_up$FDR<0.1, ]) 

print("Ion Channels")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]

print("Neuromodulators and Neuropeptides")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]

print("Monoamines")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]

print("Neurotransmitters")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]

print("Transporters")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]

print("Transcription Factors")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
```

### 7.1a.3 | Marker genes for cell type within PAG subdivision
_We can repeat the same strategy used for `PAG.area`, but this time using only either VGAT+ or VGluT2+ neurons. This will test for differences across subdivisions within a particular cell type, thus highlighting genes relevant to either inhibitory or excitatory neurons, which will be less stringent than taking all the groups together._

#### Marker genes for cell type in dmPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_dmpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_dmpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_dmpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_dmpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_dmpag_marker_set_summary = rbind(celltype_dmpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_dmpag_marker_set_summary
```

_Subsetting like this gives the same as using restrict_
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$celltype_PAGarea
restrict <- c("dmpag_VGAT", "dmpag_VGluT2") # the levels of groups for which to perform pairwise comparisons.

#### Marker genes for cell type in dlPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_dlpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_dlpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_dlpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_dlpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_dlpag_marker_set_summary = rbind(celltype_dlpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_dlpag_marker_set_summary
```

#### Marker genes for cell type in lPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_lpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_lpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_lpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_lpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_lpag_marker_set_summary = rbind(celltype_lpag_marker_set_summary,
                                             data.frame(marker_set = marker_set,
                                                        group = levels(groups)[chosen_group],
                                                        test = test,
                                                        comparisons = comparisons,
                                                        direction = direction,
                                                        genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                        genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_lpag_marker_set_summary
```

#### Marker genes for cell type in vlPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_vlpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_vlpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_vlpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_vlpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_vlpag_marker_set_summary = rbind(celltype_vlpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_vlpag_marker_set_summary
```

### 7.1a.4 | Marker genes for PAG subdivisions
We will now perform pairwise comparisons to identify marker genes for PAG subdivisions. For this, we continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `PAG.area` comparisons, 

_we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want._
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_marker_set_summary = rbind(PAGarea_marker_set_summary,
                                           data.frame(marker_set = marker_set,
                                                      group = levels(groups)[chosen_group],
                                                      test = test,
                                                      comparisons = comparisons,
                                                      direction = direction,
                                                      genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                      genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
      }
    }
  }
}

# Check out the summary: 
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="t",]
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="wilcox",]
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="binom",]
```

```{r}
dmpag_de_genes <- rownames(marker_set_dmpag_wilcox_some_up[marker_set_dmpag_wilcox_some_up$FDR<0.05, ])
dlpag_de_genes <- rownames(marker_set_dlpag_wilcox_some_up[marker_set_dlpag_wilcox_some_up$FDR<0.05, ])
lpag_de_genes <- rownames(marker_set_lpag_wilcox_some_up[marker_set_lpag_wilcox_some_up$FDR<0.05, ])
vlpag_de_genes <- rownames(marker_set_vlpag_wilcox_some_up[marker_set_vlpag_wilcox_some_up$FDR<0.05, ])


print("Ion Channels")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]

print("Neuromodulators and Neuropeptides")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]

print("Monoamines")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]

print("Neurotransmitters")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]

print("Transporters")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]

print("Transcription Factors")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
```

### 7.1a.5 | Marker genes for PAG subdivision within cell type
We can repeat the same strategy used for `PAG.area`, but this time using only either VGAT+ or VGluT2+ neurons. This will test for differences across subdivisions within a particular cell type, thus highlighting genes relevant to either inhibitory or excitatory neurons, which will be less stringent than taking all the groups together.

#### Marker genes for PAG subdivision in VGAT+ neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We first check, __FILL WITH SOMETHING MEANINGFUL__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"]$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_vgat_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_VGAT_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"]$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"],
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea_vgat/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea_vgat/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_VGAT_marker_set_summary = rbind(PAGarea_VGAT_marker_set_summary,
                                                data.frame(marker_set = marker_set,
                                                           group = levels(groups)[chosen_group],
                                                           test = test,
                                                           comparisons = comparisons,
                                                           direction = direction,
                                                           genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                           genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="t",]
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="wilcox",]
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="binom",]
```

#### Marker genes for PAG subdivision in VGluT2+ neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We first check, __FILL WITH SOMETHING MEANINGFUL__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"]$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_vglut2_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_VGluT2_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"]$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"],
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea_vglut2/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea_vglut2/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_VGluT2_marker_set_summary = rbind(PAGarea_VGluT2_marker_set_summary,
                                                  data.frame(marker_set = marker_set,
                                                             group = levels(groups)[chosen_group],
                                                             test = test,
                                                             comparisons = comparisons,
                                                             direction = direction,
                                                             genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                             genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="t",]
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="wilcox",]
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="binom",]
```

### 7.1a.6 | Marker genes for celltype_PAGarea
We will now perform pairwise comparisons to identify marker genes for `celltype_PAGarea`. For this, we continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `celltype_PAGarea` comparisons, __FILL IN__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$celltype_PAGarea

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_PAGarea_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_PAGarea_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_PAGarea/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_PAGarea/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        celltype_PAGarea_marker_set_summary = rbind(celltype_PAGarea_marker_set_summary,
                                                    data.frame(marker_set = marker_set,
                                                               group = levels(groups)[chosen_group],
                                                               test = test,
                                                               comparisons = comparisons,
                                                               direction = direction,
                                                               genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                               genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="t",]
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="wilcox",]
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="binom",]
```

### 7.1a.7 | Marker genes for PAG AP axis

### 7.1a.8 | Marker genes for cell type along AP axis

### 7.1a.9 | Marker genes for cell type according to VGAT or VGluT2 expression

### 7.1b.1 | Using pairwise t-tests
The Welch t-test is a statistical method that allows us to test for differences in expression between clusters. It is quickly computed and has good statistical properties for large numbers of cells (Soneson and Robinson 2018). The `findMarkers()` function from the `scran` package provides a convenience wrapper for marker gene identification between groups of cells, based on running `pairwiseTTests` or related functions and passing the result to `combineMarkers()`. We can use the `findMarkers()` function to perform pairwise comparisons between clusters for each gene (the function performs Welch t-tests on the normalised log-expression values for every gene and between every pair of clusters), which returns a list of `DataFrame`s containing ranked candidate markers for each cluster. The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters. Importantly, besides looking at the clustering results, we can also apply this approach to identify genes driving differences between other factors of our metadata, such as `cell.type` or `PAG.area`.

The choice of `pval.type` determines whether the highly ranked genes are those that are DE between the current group and: (1) any other group ("any"), (2) all other groups ("all"), or (3) some other groups ("some"). The result is a named list of `DataFrame`s, each of which contains a sorted marker gene list for the corresponding group. In each `DataFrame`, the top genes are chosen to enable separation of that group from all other groups. Log-fold changes are reported as differences in average x between groups (usually in base 2, depending on the transformation applied to x).
```{r}
library(scran)
marker_genes_standard <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                     groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10#, # clustering results or any other group assignements for each cell.
                                     #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                     #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                     #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                                     #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                     #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                     #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                     #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                     #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                     #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                     #get.spikes = FALSE,
                                     #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                     #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                     #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                     #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                     #direction = c("any", "up", "down"), # the direction of log-fold changes to be considered in the alternative hypothesis.
                                     #lfc = 0, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                     #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                     #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                     )
marker_genes_standard
```

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table. The relevant `DataFrame` contains log2-fold changes of expression in cluster X over each other cluster, along with several statistics obtained by combining p-values (Simes 1986) across the pairwise comparisons involving X. This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters. For example, to construct a marker set for cluster X from the top 10 genes of each comparison, we could filter `marker_set` to retain rows with `Top` less than or equal to 10. Other statistics are also reported for each gene, including the adjusted p-values and the log-fold changes relative to every other cluster.
```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_standard[[chosen_group]]
  print(paste0("marker_set_standard_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_standard_cluster_", chosen_group)
  assign(marker_set, marker_genes_standard[[chosen_group]])
}
```

Of particular interest is the `Top` field. The set of genes with `Top ≤ X` is the union of the top X genes (ranked by p-value) from each pairwise comparison involving our chosen cluster. For example, the set of all genes with `Top` values of 1 contains the gene with the lowest p-value from each comparison. Similarly, the set of genes with `Top` values less than or equal to 10 contains the top 10 genes from each comparison. The `Top` field represents `findMarkers()`’s approach to consolidating multiple pairwise comparisons into a single ranking for each cluster; each `DataFrame` produced by `findMarkers()` will order genes based on the `Top` value by default.
```{r}
colnames(marker_set_standard_cluster_4)

# Check what Top represents:
marker_set_standard_cluster_4[marker_set_standard_cluster_4$Top <= 1,]
marker_set_standard_cluster_4[1:10, 1:5]
```

We can use the `Top` field to identify a set of genes that is guaranteed to distinguish cluster X from any other cluster. If we take all genes with `Top <= 6`, this is equivalent to the union of the top 6 genes from each pairwise comparison.
```{r}
library(pheatmap)
best_set_standard_cluster_4 <- marker_set_standard_cluster_4[marker_set_standard_cluster_4$Top <= 6,]
#best_set_standard_cluster_4
logFCs_standard <- as.matrix(best_set_standard_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_standard
colnames(logFCs_standard) <- sub("logFC.", "", colnames(logFCs_standard)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_standard

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_standard, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | any)")

# Alternative plot - will plot expression of the marker genes
best_set_standard_cluster_4_names <- rownames(best_set_standard_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_standard_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | any)")
```

Each `DataFrame` also contains several other statistics that may be of interest. The `p.value` field contains the combined p-value that is obtained by applying Simes’s method to the pairwise p-values for each gene and represents the evidence against the joint null hypothesis, i.e., that the gene is not DE between cluster X and any other cluster. In a future version of `scran`, the `summary.logFC` field provides a convenient summary of the direction and effect size for each gene, and is defined here as the log-fold change from the comparison with the lowest p-value. Examination of these statistics permits a quick evaluation of the suitability of a candidate marker; if both of these metrics are poor (small log-fold change, large p-value), the gene can most likely be dismissed.

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells. The latter approach is sensitive to the population composition, potentially resulting in substantially different sets of markers when cell type abundances change in different contexts. In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations. Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by each gene.

### 7.1b.2 | Using the log-fold change
The previous `findMarkers()` call considers both up- and downregulated genes to be potential markers. However, downregulated genes are less appealing as markers as it is more difficult to interpret and experimentally validate an absence of expression. To focus on up-regulated markers, we can instead perform a one-sided t-test to identify genes that are upregulated in each cluster compared to the others. This is achieved by setting `direction = "up"` in the `findMarkers()` call.
```{r}
marker_genes_up <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                               groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results or any other group assignements for each cell.
                               #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                               #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                               #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                               #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                               #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                               #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                               #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                               #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                               #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                               #get.spikes = FALSE,
                               #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                               #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                               #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                               #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                               direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                               #lfc = 0, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                               #std.lfc = FALSE, # whether log-fold changes should be standardized.
                               #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                               )
marker_genes_up
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up[[chosen_group]]
  print(paste0("marker_set_up_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_cluster_", chosen_group)
  assign(marker_set, marker_genes_up[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_cluster_4 <- marker_set_up_cluster_4[marker_set_up_cluster_4$Top <= 6,]
#best_set_up_cluster_4
logFCs_up <- as.matrix(best_set_up_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_up
colnames(logFCs_up) <- sub("logFC.", "", colnames(logFCs_up)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_up

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_up, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | up)")

# Alternative plot - will plot expression of the marker genes
best_set_up_cluster_4_names <- rownames(best_set_up_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | up)")
```

The t-test also allows us to specify a non-zero log-fold change as the null hypothesis. This allows us to consider the magnitude of the log-fold change in our p-value calculations, in a manner that is more rigorous than simply filtering directly on the log-fold changes (McCarthy and Smyth 2009). (Specifically, a simple threshold does not consider the variance and can enrich for genes that have both large log-fold changes and large variances.) We perform this by setting `lfc=` in our `findMarkers()` call - when combined with `direction=`, this tests for genes with log-fold changes that are significantly greater than 1:
```{r}
marker_genes_up_logFC <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                     groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results or any other group assignements for each cell.
                                     #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                     #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                     #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                                     #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                     #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                     #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                     #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                     #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                     #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                     #get.spikes = FALSE,
                                     #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                     #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                     #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                     #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                     direction = "up", # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                     lfc = 1#, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                     #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                     #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                     )
marker_genes_up_logFC
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_logFC[[chosen_group]]
  print(paste0("marker_set_up_logFC_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_logFC_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_logFC[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_logFC_cluster_4 <- marker_set_up_logFC_cluster_4[marker_set_up_logFC_cluster_4$Top <= 6,]
#best_set_up_logFC_cluster_4
logFCs_up_logFC <- as.matrix(best_set_up_logFC_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_up_logFC
colnames(logFCs_up_logFC) <- sub("logFC.", "", colnames(logFCs_up_logFC)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_up_logFC

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_up_logFC, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | up logFC)")

# Alternative plot - will plot expression of the marker genes
best_set_up_logFC_cluster_4_names <- rownames(best_set_up_logFC_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_logFC_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | up logFC)")
```

These two settings yield a more focused set of candidate marker genes that are upregulated in cluster X. This increased stringency, however, is not without cost. If only upregulated genes are requested from `findMarkers()`, any cluster defined by downregulation of a marker gene will not contain that gene among the top set of features in its `DataFrame`. This is occasionally relevant for subtypes or other states that are distinguished by high versus low expression of particular genes. Similarly, setting an excessively high log-fold change threshold may discard otherwise useful genes. For example, a gene upregulated in a small proportion of cells of a cluster will have a small log-fold change but can still be an effective marker if the focus is on specificity rather than sensitivity.

### 7.1b.3 | Finding cluster-specific markers
By default, `findMarkers()` will give a high ranking to genes that are differentially expressed in any pairwise comparison. This is because a gene only needs a very low p-value in a single pairwise comparison to achieve a low `Top` value. A more stringent approach would only consider genes that are differentially expressed in all pairwise comparisons involving the cluster of interest. To achieve this, we set `pval.type="all"` in `findMarkers()` to use an intersection-union test (Berger and Hsu 1996) where the combined p-value for each gene is the maximum of the p-values from all pairwise comparisons. A gene will only achieve a low combined p-value if it is strongly DE in all comparisons to other clusters. Combined with `direction="up"`, this can be used to identify unique markers for each cluster. However, this is sensitive to overclustering, as unique marker genes will no longer exist if a cluster is split into two smaller subclusters.

This strategy will only report genes that are highly specific to the cluster of interest. When it works, it can be highly effective as it generates a small focused set of candidate markers. However, any gene that is expressed at the same level in two or more clusters will simply not be detected. This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation (such as different clusters within a cell type). To give a concrete example, consider a mixed population of CD4+-only, CD8+-only, double-positive and double-negative T cells. With `pval.type="all"`, neither Cd4 or Cd8 would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations. In comparison, `pval.type="any"` will detect both of these genes as they will be DE between at least one pair of subpopulations.

If `pval.type="all"` is too stringent yet `pval.type="any"` is too generous, a compromise is to set `pval.type="some"`. For each gene, we apply the Holm-Bonferroni correction across its p-values and take the middle-most value as the combined p-value. This effectively tests the global null hypothesis that at least 50% of the individual pairwise comparisons exhibit no DE. We then rank the genes by their combined p-values to obtain an ordered set of marker candidates. The aim is to improve the conciseness of the top markers for defining a cluster while mitigating the risk of discarding useful genes that are not DE to all other clusters. The downside is that taking this compromise position sacrifices the theoretical guarantees offered at the other two extremes.

_Only relevant for the newer `scran` version, which returns a column with `summary.logFC`._ In both cases, a different method is used to compute the summary effect size compared to `pval.type="any"`. For `pval.type="all"`, the summary log-fold change is defined as that corresponding to the pairwise comparison with the largest p-value, while for `pval.type="some"`, it is defined as the log-fold change for the comparison with the middle-most p-value. This reflects the calculation of the combined p-value and avoids focusing on genes with strong changes in only one comparison.

We can prepare code for our different comparisons and then modify the `pval.type` to compare the different approaches.

#### pval.type = "all"
##### Across clusters
We can first look at cluster-specific markers:
```{r}
marker_genes_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_all_clusters[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_all_clusters_cluster_4 <- marker_set_up_all_clusters_cluster_4[1:30,]
best_set_up_all_clusters_cluster_4_names <- rownames(best_set_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | all | up)")
```

##### Across cell types
We can next look at cell-type-specific markers:
```{r}
marker_genes_up_all_celltype <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$cell.type, # clustering results or any other group assignements for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise to zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_celltype
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_celltype <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                           colour_by = "cell.type") + labs(title = "UMAP (cv2) - Cell type", 
                                                                                                              x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_celltype)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$cell.type)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype[[chosen_group]])
}
```

```{r}
library(pheatmap)
# VGAT cells
best_set_up_all_celltype_VGAT <- marker_set_up_all_celltype_1[1:30,]
best_set_up_all_celltype_VGAT_names <- rownames(best_set_up_all_celltype_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGAT marker genes (t-test | all | up)")

# VGluT2 cells
best_set_up_all_celltype_VGluT2 <- marker_set_up_all_celltype_2[1:30,]
best_set_up_all_celltype_VGluT2_names <- rownames(best_set_up_all_celltype_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGluT2 marker genes (t-test | all | up)")
```

##### Across PAG subdivisions
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_PAGareas <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$PAG.area, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_PAGareas
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "PAG.area", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$PAG.area)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_PAGareas[[chosen_group]]
  print(paste0("marker_set_up_all_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_PAGareas[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG
best_set_up_all_PAGareas_dm <- marker_set_up_all_PAGarea_1[1:30,]
best_set_up_all_PAGareas_dm_names <- rownames(best_set_up_all_PAGareas_dm)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dm_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG marker genes (t-test | all | up)")

# dlPAG
best_set_up_all_PAGareas_dl <- marker_set_up_all_PAGarea_2[1:30,]
best_set_up_all_PAGareas_dl_names <- rownames(best_set_up_all_PAGareas_dl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG marker genes (t-test | all | up)")

# lPAG
best_set_up_all_PAGareas_l <- marker_set_up_all_PAGarea_3[1:30,]
best_set_up_all_PAGareas_l_names <- rownames(best_set_up_all_PAGareas_l)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_l_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG marker genes (t-test | all | up)")

# vlPAG
best_set_up_all_PAGareas_vl <- marker_set_up_all_PAGarea_4[1:30,]
best_set_up_all_PAGareas_vl_names <- rownames(best_set_up_all_PAGareas_vl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_vl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG marker genes (t-test | all | up)")
```

##### Across celltype_PAGarea
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_celltype_PAGarea <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                                    groups = PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea, # clustering results for each cell.
                                                    #test.type = c("t", "wilcox", "binom"), # t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                                    pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                                    #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                                    #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                                    #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                                    #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                                    #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each output DataFrames.
                                                    #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                                    #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                                    #get.spikes = FALSE,
                                                    #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                                    #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                                    #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                                    #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                                    direction = "up"#, # direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                                    #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                                    #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                                    #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                                    )
marker_genes_up_all_celltype_PAGarea
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "celltype_PAGarea", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions and cell types", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype_PAGarea[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype_PAGarea[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG_VGAT
best_set_up_all_dmPAG_VGAT<- marker_set_up_all_celltype_PAGarea_1[1:30,]
best_set_up_all_dmPAG_VGAT_names <- rownames(best_set_up_all_dmPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGAT marker genes (t-test | all | up)")

# dlPAG_VGAT
best_set_up_all_dlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_2[1:30,]
best_set_up_all_dlPAG_VGAT_names <- rownames(best_set_up_all_dlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGAT marker genes (t-test | all | up)")

# lPAG_VGAT
best_set_up_all_lPAG_VGAT<- marker_set_up_all_celltype_PAGarea_3[1:30,]
best_set_up_all_lPAG_VGAT_names <- rownames(best_set_up_all_lPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGAT marker genes (t-test | all | up)")

# vlPAG_VGAT
best_set_up_all_vlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_4[1:30,]
best_set_up_all_vlPAG_VGAT_names <- rownames(best_set_up_all_vlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGAT marker genes (t-test | all | up)")

# dmPAG_VGluT2
best_set_up_all_dmPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_5[1:30,]
best_set_up_all_dmPAG_VGluT2_names <- rownames(best_set_up_all_dmPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGluT2 marker genes (t-test | all | up)")

# dlPAG_VGluT2
best_set_up_all_dlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_6[1:30,]
best_set_up_all_dlPAG_VGluT2_names <- rownames(best_set_up_all_dlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGluT2 marker genes (t-test | all | up)")

# lPAG_VGluT2
best_set_up_all_lPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_7[1:30,]
best_set_up_all_lPAG_VGluT2_names <- rownames(best_set_up_all_lPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGluT2 marker genes (t-test | all | up)")

# vlPAG_VGluT2
best_set_up_all_vlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_8[1:30,]
best_set_up_all_vlPAG_VGluT2_names <- rownames(best_set_up_all_vlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGluT2 marker genes (t-test | all | up)")
```

#### pval.type = "some"
##### Across clusters
We can first look at cluster-specific markers:
```{r}
marker_genes_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_all_clusters[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_all_clusters_cluster_4 <- marker_set_up_all_clusters_cluster_4[1:30,]
best_set_up_all_clusters_cluster_4_names <- rownames(best_set_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | all | up)")
```

##### Across cell types
We can next look at cell-type-specific markers:
```{r}
marker_genes_up_all_celltype <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$cell.type, # clustering results or any other group assignements for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise to zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_celltype
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_celltype <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                           colour_by = "cell.type") + labs(title = "UMAP (cv2) - Cell type", 
                                                                                                              x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_celltype)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$cell.type)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype[[chosen_group]])
}
```

```{r}
library(pheatmap)
# VGAT cells
best_set_up_all_celltype_VGAT <- marker_set_up_all_celltype_1[1:30,]
best_set_up_all_celltype_VGAT_names <- rownames(best_set_up_all_celltype_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGAT marker genes (t-test | all | up)")

# VGluT2 cells
best_set_up_all_celltype_VGluT2 <- marker_set_up_all_celltype_2[1:30,]
best_set_up_all_celltype_VGluT2_names <- rownames(best_set_up_all_celltype_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGluT2 marker genes (t-test | all | up)")
```

##### Across PAG subdivisions
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_PAGareas <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$PAG.area, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_PAGareas
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "PAG.area", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$PAG.area)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_PAGareas[[chosen_group]]
  print(paste0("marker_set_up_all_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_PAGareas[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG
best_set_up_all_PAGareas_dm <- marker_set_up_all_PAGarea_1[1:30,]
best_set_up_all_PAGareas_dm_names <- rownames(best_set_up_all_PAGareas_dm)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dm_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG marker genes (t-test | all | up)")

# dlPAG
best_set_up_all_PAGareas_dl <- marker_set_up_all_PAGarea_2[1:30,]
best_set_up_all_PAGareas_dl_names <- rownames(best_set_up_all_PAGareas_dl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG marker genes (t-test | all | up)")

# lPAG
best_set_up_all_PAGareas_l <- marker_set_up_all_PAGarea_3[1:30,]
best_set_up_all_PAGareas_l_names <- rownames(best_set_up_all_PAGareas_l)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_l_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG marker genes (t-test | all | up)")

# vlPAG
best_set_up_all_PAGareas_vl <- marker_set_up_all_PAGarea_4[1:30,]
best_set_up_all_PAGareas_vl_names <- rownames(best_set_up_all_PAGareas_vl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_vl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG marker genes (t-test | all | up)")
```

##### Across celltype_PAGarea
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_celltype_PAGarea <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                                    groups = PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea, # clustering results for each cell.
                                                    #test.type = c("t", "wilcox", "binom"), # t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                                    pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                                    #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                                    #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                                    #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                                    #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                                    #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each output DataFrames.
                                                    #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                                    #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                                    #get.spikes = FALSE,
                                                    #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                                    #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                                    #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                                    #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                                    direction = "up"#, # direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                                    #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                                    #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                                    #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                                    )
marker_genes_up_all_celltype_PAGarea
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "celltype_PAGarea", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions and cell types", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype_PAGarea[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype_PAGarea[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG_VGAT
best_set_up_all_dmPAG_VGAT<- marker_set_up_all_celltype_PAGarea_1[1:30,]
best_set_up_all_dmPAG_VGAT_names <- rownames(best_set_up_all_dmPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGAT marker genes (t-test | all | up)")

# dlPAG_VGAT
best_set_up_all_dlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_2[1:30,]
best_set_up_all_dlPAG_VGAT_names <- rownames(best_set_up_all_dlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGAT marker genes (t-test | all | up)")

# lPAG_VGAT
best_set_up_all_lPAG_VGAT<- marker_set_up_all_celltype_PAGarea_3[1:30,]
best_set_up_all_lPAG_VGAT_names <- rownames(best_set_up_all_lPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGAT marker genes (t-test | all | up)")

# vlPAG_VGAT
best_set_up_all_vlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_4[1:30,]
best_set_up_all_vlPAG_VGAT_names <- rownames(best_set_up_all_vlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGAT marker genes (t-test | all | up)")

# dmPAG_VGluT2
best_set_up_all_dmPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_5[1:30,]
best_set_up_all_dmPAG_VGluT2_names <- rownames(best_set_up_all_dmPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGluT2 marker genes (t-test | all | up)")

# dlPAG_VGluT2
best_set_up_all_dlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_6[1:30,]
best_set_up_all_dlPAG_VGluT2_names <- rownames(best_set_up_all_dlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGluT2 marker genes (t-test | all | up)")

# lPAG_VGluT2
best_set_up_all_lPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_7[1:30,]
best_set_up_all_lPAG_VGluT2_names <- rownames(best_set_up_all_lPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGluT2 marker genes (t-test | all | up)")

# vlPAG_VGluT2
best_set_up_all_vlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_8[1:30,]
best_set_up_all_vlPAG_VGluT2_names <- rownames(best_set_up_all_vlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGluT2 marker genes (t-test | all | up)")
```

### 7.1b.4 | Using the Wilcoxon rank sum test
The Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test) is another widely used method for pairwise comparisons between groups of observations. Its strength lies in the fact that it directly assesses separation between the expression distributions of different clusters. The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster. In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the t-test only does so indirectly via the difference in the means and the intra-group variance.

We can perform WMW tests using the `findMarkers()` function, setting `test="wilcox"`. This returns a list of `DataFrames` containing ranked candidate markers for each cluster. The `direction=`, `lfc=` and `pval.type=` arguments can be specified and have the same interpretation as described for t-tests. Again, to explore the results in more detail, we can focus on the `DataFrame` for group X. The interpretation of `Top` is the same as described for t-tests, and Simes’s method is again used to combine p-values across pairwise comparisons. If we want more focused sets, we can also change `pval.type=` as previously described.

We can first look at cluster-specific markers:
```{r}
markers_wilcox_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                              groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                              test.type = "wilcox", # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                              pval.type = "any", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
                                              #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                              #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                              #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                              #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                              #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                              #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                              #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                              #get.spikes = FALSE,
                                              #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                              #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                              #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                              #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                              direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                              #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                              #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                              #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                              )
markers_wilcox_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- markers_wilcox_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_wilcox_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:3])
  marker_set <- paste0("marker_set_wilcox_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, markers_wilcox_up_all_clusters[[chosen_group]])
}
```

The `DataFrame` contains the AUCs from comparing group X to every other group. A value greater than 0.5 indicates that the gene is upregulated in the current cluster compared to the other cluster, while values less than 0.5 correspond to downregulation. We would typically expect AUCs of 0.7-0.8 for a strongly upregulated candidate marker.
```{r}
library(pheatmap)
best_set_wilcox_up_all_clusters_cluster_4 <- marker_set_wilcox_up_all_clusters_cluster_4[marker_set_wilcox_up_all_clusters_cluster_4$Top <= 6,]
#best_set_wilcox_up_all_clusters_cluster_4
AUCs_wilcox_up <- as.matrix(best_set_wilcox_up_all_clusters_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#AUCs_wilcox_up
colnames(AUCs_wilcox_up) <- sub("AUC.", "", colnames(AUCs_wilcox_up)) # Remove "AUC." from the colnames, to leave the cluster number alone
#AUCs_wilcox_up

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(AUCs_wilcox_up, breaks = seq(0, 1, length.out = 21), color = viridis::viridis(21),
         main = "Heatmap for Cluster 4 AUCs (wilcoxon | all | up)")

# Alternative plot - will plot expression of the marker genes
best_set_wilcox_up_all_clusters_cluster_4_names <- rownames(best_set_wilcox_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_wilcox_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
             main = "Heatmap for Cluster 4 marker genes (wilcoxon | all | up)")
```

One practical advantage of the WMW test over the Welch t-test is that it is symmetric with respect to differences in the size of the groups being compared. This means that, all else being equal, the top-ranked genes on each side of a DE comparison will have similar expression profiles regardless of the number of cells in each group. In contrast, the t-test will favor genes where the larger group has the higher relative variance as this increases the estimated degrees of freedom and decreases the resulting p-value. This can lead to unappealing rankings when the aim is to identify genes upregulated in smaller groups. The WMW test is not completely immune the variance effects - for example, it will slightly favor detection of DEGs at low average abundance where the greater number of ties at zero deflates the approximate variance of the rank sum statistic - but this is relatively benign as the selected genes are still fairly interesting.
```{r}
marker.lawlor.t <- findMarkers(sce.lawlor, groups=sce.lawlor$`cell type`, 
                               direction="up", restrict=c("Alpha", "Gamma/PP"))
marker.lawlor.w <- findMarkers(sce.lawlor, groups=sce.lawlor$`cell type`, 
                               direction="up", restrict=c("Alpha", "Gamma/PP"), test.type="wilcox")

# Upregulated in alpha:
marker.alpha.t <- marker.lawlor.t$Alpha
marker.alpha.w <- marker.lawlor.w$Alpha
chosen.alpha.t <- rownames(marker.alpha.t)[1:20]
chosen.alpha.w <- rownames(marker.alpha.w)[1:20]
u.alpha.t <- setdiff(chosen.alpha.t, chosen.alpha.w)
u.alpha.w <- setdiff(chosen.alpha.w, chosen.alpha.t)

# Upregulated in gamma:
marker.gamma.t <- marker.lawlor.t$`Gamma/PP`
marker.gamma.w <- marker.lawlor.w$`Gamma/PP`
chosen.gamma.t <- rownames(marker.gamma.t)[1:20]
chosen.gamma.w <- rownames(marker.gamma.w)[1:20]
u.gamma.t <- setdiff(chosen.gamma.t, chosen.gamma.w)
u.gamma.w <- setdiff(chosen.gamma.w, chosen.gamma.t)

# Examining all uniquely detected markers in each direction.
library(scater)
subset <- sce.lawlor[,sce.lawlor$`cell type` %in% c("Alpha", "Gamma/PP")]
gridExtra::grid.arrange(plotExpression(subset, x="cell type", features=u.alpha.t, ncol=2) +
                          ggtitle("Upregulated in alpha, t-test-only"),
                        plotExpression(subset, x="cell type", features=u.alpha.w, ncol=2) +
                          ggtitle("Upregulated in alpha, WMW-test-only"),
                        plotExpression(subset, x="cell type", features=u.gamma.t, ncol=2) +
                          ggtitle("Upregulated in gamma, t-test-only"),
                        plotExpression(subset, x="cell type", features=u.gamma.w, ncol=2) +
                          ggtitle("Upregulated in gamma, WMW-test-only"),
                        ncol=2
                        )
```

The main disadvantage of the WMW test is that the AUCs are much slower to compute compared to t-statistics. This may be inconvenient for interactive analyses involving multiple iterations of marker detection. We can mitigate this to some extent by parallelizing these calculations using the `BPPARAM=` argument in `findMarkers()`.

### 7.1b.5 | Using the binomial test
The binomial test *identifies genes that differ in the proportion of expressing cells between clusters*. This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero. The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle “tuning” effects from changing the expression of an active gene. From a practical perspective, a binary measure of presence/absence is easier to validate.

We can perform pairwise binomial tests between clusters using the `findMarkers()` function with `test="binom"`. This returns a list of `DataFrames` containing marker statistics for each cluster such as the `Top` rank and its p-value. Here, the effect size is reported as the log-fold change in this proportion between each pair of clusters. Large positive log-fold changes indicate that the gene is more frequently expressed in one cluster compared to the other. We can focus on genes that are upregulated in each cluster compared to the others by setting `direction="up"`.

The disadvantage of the binomial test is that its increased stringency can lead to the loss of good candidate markers. Another property of the binomial test is that it will not respond to scaling normalisation. Systematic differences in library size between clusters will not be considered when computing p-values or effect sizes. This is not necessarily problematic for marker gene detection - users can treat this as retaining information about the total RNA content, analogous to spike-in normalisation.

```{r}
library(scran)
# Parameters defaults:
test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
lfc = 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

groups = NULL # clustering results or group for each cell.
block = NULL # factor specifying the blocking level for each cell.
design = NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict = NULL # the levels of groups for which to perform pairwise comparisons.
exclude = NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

Find cell type specific markers:
```{r}
# Set the parameters:
results_name <- "cell_type_" # String to be added to the filename when saving the results.
# "SNN_jaccard_k8_cluster_", "PAG_subdivisions_", "celltype_", "celltype_PAGarea_", "celltype_PAGAPaxis_"

test <- "binom" # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

groups <- PAG_sceset_qc_norm_filt_corr_clust_de$cell.type # clustering results or group for each cell.
block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.

# Run findMarkers:
marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                            groups = groups,
                            test.type = test,
                            pval.type = comparisons,
                            direction = direction,
                            lfc = lfc,
                            assay.type = "logcounts",
                            block = block,
                            restrict = restrict,
                            exclude = exclude
                            )
marker_genes

# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(groups)))

# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes[[chosen_group]]
  print(str_c("marker_set_", test, "_", comparisons, "_", direction, "_", levels(groups)[chosen_group]))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- str_c("marker_set_", test, "_", comparisons, "_", direction, "_", levels(groups)[chosen_group])
  assign(marker_set, temp_marker_set)
  write.csv(temp_marker_set, file = str_c(path_for_figures, "PAG_DE_results_", test, "_", comparisons, "_", direction, "_", results_name, levels(groups)[chosen_group], ".csv"),
            quote = FALSE, row.names = TRUE)
}
```

```{r}
library(scater)
top_VGAT_genes <- head(rownames(marker_set_binom_all_up_VGAT))
plotExpression(PAG_sceset_qc_norm_filt_corr_clust_de, x = "cell.type", features = top_VGAT_genes)

top_VGluT2_genes <- head(rownames(marker_set_binom_all_up_VGluT2))
plotExpression(PAG_sceset_qc_norm_filt_corr_clust_de, x = "cell.type", features = top_VGluT2_genes)
```

### 7.1b.6 | Using custom DE methods
It is also possible to perform marker gene detection based on precomputed DE statistics, which allows us to take advantage of more sophisticated tests in dedicated DE analysis packages in the Bioconductor ecosystem. To demonstrate, consider the `voom()` approach from the limma package (Law et al. 2014). We first process our `SingleCellExperiment` to obtain a `fit` object as shown below.
```{r}
library(limma)
library(scran)
design <- model.matrix(~0 + cluster + Plate, data=colData(sce.pbmc))
colnames(design)

# Removing very low-abundance genes.
keep <- calculateAverage(sce.pbmc) > 0.1 
summary(keep)

y <- convertTo(sce.pbmc, subset.row=keep)
v <- voom(y, design)
fit <- lmFit(v, design)
```

We then perform pairwise comparisons between clusters using the TREAT strategy (McCarthy and Smyth 2009) to test for log-fold changes that are significantly greater than 0.5. For each comparison, we store the corresponding data frame of statistics in `all.results`, along with the identities of the clusters involved in `all.pairs`.
```{r}
nclust <- length(unique(sce.pbmc$cluster))
all.results <- all.pairs <- list()
counter <- 1L

# Iterating across the first 'nclust' coefficients in design,
# and comparing them to each other in a pairwise manner.
for (x in seq_len(nclust)) {
    for (y in seq_len(x-1L)) {
        con <- integer(ncol(design))
        con[x] <- 1
        con[y] <- -1
        fit2 <- contrasts.fit(fit, con)
        fit2 <- treat(fit2, robust=TRUE, lfc=0.5)

        res <- topTreat(fit2, n=Inf, sort.by="none")
        all.results[[counter]] <- res
        all.pairs[[counter]] <- colnames(design)[c(x, y)]
        counter <- counter+1L

        # Also filling the reverse comparison.
        res$logFC <- -res$logFC
        all.results[[counter]] <- res
        all.pairs[[counter]] <- colnames(design)[c(y, x)]
        counter <- counter+1L
    }
}
```

These custom results are consolidated into a single marker list for each cluster with the `combineMarkers()` function. This combines test statistics across all pairwise comparisons involving a single cluster, yielding a per-cluster `DataFrame` that can be interpreted in the same manner as discussed previously.
```{r}
all.pairs <- do.call(rbind, all.pairs)
combined <- combineMarkers(all.results, all.pairs, pval.field="P.Value")

# Inspecting results for our cluster of interest again.
interesting.voom <- combined[[paste0("cluster", chosen)]] 
colnames(interesting.voom)

head(interesting.voom[,1:3])
```

By default, we do not use custom DE methods to perform marker detection, for several reasons. Many of these methods rely on empirical Bayes shrinkage to share information across genes in the presence of limited replication. However, this is unnecessary when there are large numbers of “replicate” cells in each group. These methods also make stronger assumptions about the data (e.g., equal variances for linear models, the distribution of variances during empirical Bayes) that are more likely to be violated in noisy scRNA-seq contexts. From a practical perspective, they require more work to set up and take more time to run. Nonetheless, some custom methods (e.g., MAST) may provide a useful point of difference from the simpler tests, in which case they can be converted into a marker detection scheme as described above.

## Step 7.2 | Differential Expression workflow with DESeq2 and edgeR (EBI-EMBL Course, Charlotte Soneson)
Count-based statistical methods such as _DESeq2_ (Love, Huber, and Anders 2014), _edgeR_ (Robinson, McCarthy, and Smyth 2009), _limma_ with the _voom_ method (Law et al. 2014), _DSS_ (Wu, Wang, and Wu 2013), _EBSeq_ (Leng et al. 2013), _BaySeq_ (Hardcastle and Kelly 2010) and _DEXSeq_ (Anders, Reyes, and Huber 2012) expect input data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment in the form of a matrix of integer values, or `counts`. The value in the i-th row and the j-th column of the matrix tells how many reads (or fragments, for paired-end RNA-seq) have been assigned to feature i in sample j. For RNA-seq, a feature is typically a gene, a transcript or an exon.

The fact that the values in the matrix are counts of sequencing reads (in the case of single-end sequencing) or fragments (for paired-end sequencing) is important for the count-based statistical models, e.g. _DESeq2_ or _edgeR_, as only the counts allow assessing the measurement precision correctly. It is important to _never_ provide counts that have been normalised for sequencing depth/library size to these packages, as the statistical model is most powerful when applied to counts, and is designed to account for library size differences internally.

The most common model of RNASeq data is the negative binomial model. However, a raw negative binomial model does not fit full-length transcript data as well due to the high dropout rates relative to the non-zero read counts. For this type of data a variety of zero-inflated negative binomial models have been proposed (e.g. MAST, SCDE). The model that makes more biological sense and with more experimental support (Kim and Marioni, 2013) is the Poisson-Beta distribution, based on a mechanistic model of transcriptional bursting.

An alternative to using actual counts of reads or fragments aligned to the genome is to use estimated counts from software that use pseudo-alignment to the transcriptome. Since these represent expected counts rather than observed counts they are not necessarily integers, and thus may need to be rounded before they are fed to the count-based pipelines. In any case, we start the DE workflow from a gene-vs-sample matrix, where raw reads have been quality controlled and gene expression quantified, and we make sure to add a new assay slot that will contain rounded raw counts, as some of the methods may only work if integers are provided:
```{r}
# Round the counts to ensure they are integers:
assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded") <- round(assay(PAG_sceset_qc_norm_filt_corr_clust, "counts")) # NOT the normalised counts
# Check you have rounded counts in your object:
assayNames(PAG_sceset_qc_norm_filt_corr_clust)
```

```{r}
# Quickly check the millions of reads that were uniquely aligned to genes (the second argument of round tells how many decimal points to keep).
round(colSums(assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded")) / 1e6, 1)
```

Once we have a gene-level count matrix and the relevant metadata we can branch out and use a variety of Bioconductor packages for exploration and DE analysis. Each of the packages we will use for differential expression has a specific class of object used to store the summarization of the RNA-seq experiment and the intermediate quantities that are calculated during the statistical analysis of the data. `DESeq2` uses a `DESeqDataSet` and `edgeR` uses a `DGEList`.

### 7.2.1 | DEseq2 and the DESeqDatSet
In _DESeq2_, the custom class is called _DESeqDataSet_. It is built on top of the _SummarizedExperiment_ class, and it is easy to convert _SummarizedExperiment_ objects into _DESeqDataSet_ objects. 

* One of the two main differences compared to a _SummarizedExperiment_ object is that the `assay` slot is instead accessed using the `counts` accessor function, and the _DESeqDataSet_ class enforces that the values in this matrix are non-negative integers.
* A second difference is that the _DESeqDataSet_ has an associated _design formula_. The experimental design is specified at the beginning of the analysis, as it will inform many of the _DESeq2_ functions how to treat the samples in the analysis (one exception is the size factor estimation, i.e., the adjustment for differing library sizes, which does not depend on the design formula). The design formula tells which columns in the sample information table (`colData`) specify the experimental design and how these factors should be used in the analysis.

We have two types of cells, _VGAT_ and _VGluT2_, across four different anatomical subdivisions.
```{r}
table(PAG_sceset_qc_norm_filt_corr_clust$cell.type, PAG_sceset_qc_norm_filt_corr_clust$PAG.area)
table(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)
```

__Note__: it could be helpful for us if the first level of a factor is the reference level (e.g. control, or untreated samples). The reason is that by specifying this, functions further in the pipeline can be used and will give comparisons such as "treatment vs control", without needing to specify additional arguments. However, in our case it doesn't make much sense, as we are not comparing treatments or conditions in a time sequence, and there is no clear reference level for `cell.type` or `mouse.id`. We can, however, relevel the `PAG.area` so that `dmpag` and not `dlpag` is the top level, as we did in _Part I_ of the pipeline. We don't need to run this again.

We want to find differences in expression of genes (1) across *cell-types irrespective of PAG subdivision*, (2) across *PAG subdivisions irrespective of cell-type*, (3) across *subdivisions within a given cell-type*, and (4) across *cell-types within a given subdivision*. Importantly, each transgenic mouse (`mouse.id`) only allows us to capture one of the two cell-types, so the _mouse ID_ will be completely confounded with one or the other _cell type_. We would like to control for differences due to `mouse.sex` and `batch.processing`, as we are not interested in differences due to these. 

* An example of a design to explore differences in gene expression associated to `cell.type` but controling for differences between `mouse.sex` is obtained by writing `~ mouse.sex + cell.type`. By including `mouse.sex`, terms will be added to the model which account for differences across mice, and by adding `cell.type` we get a single term which explains the differences between cell types. Make sure the levels in the factors only contain letters, numbers, underscores and periods. The variable of interest should go at the end of the formula (the `results` function will by default pull the `cell.type` results unless `contrast` or `name` arguments are specified).
* We use R's formula notation to express any fixed-effects experimental design for _edgeR_ or _DESeq2_. If the research aim is to determine for which genes the effect of a treatment is different across groups, then interaction terms can be included and tested using a design such as `~ group + treatment + group:treatment`. See the vignettes of `DESeq2` and `edgeR` for more examples.

__Contrasts__: A contrast is a linear combination of estimated log2 fold changes, which can be used to test if differences between groups are equal to zero. The simplest use case for contrasts is an experimental design containing a factor with three levels, say A, B and C. Contrasts enable the user to generate results for all 3 possible differences: log2 fold change of B vs A, of C vs A, and of C vs B.

__Interactions__: Interaction terms can be added to the design formula, in order to test, for example, if the log2 fold change attributable to a given condition is different based on another factor, for example if the condition effect differs across genotype. However, nothe the following: Many users begin to add interaction terms to the design formula, when in fact a much simpler approach would give all the results tables that are desired. If the comparisons of interest are, for example, the effect of a condition for different sets of samples, a simpler approach than adding interaction terms explicitly to the design formula is to perform the following steps:

* combine the factors of interest into a single factor with all combinations of the original factors
* change the design to include just this factor, e.g. `~ group`

Using this design is similar to adding an interaction term, in that it models multiple condition effects which can be easily extracted with results. Suppose we have two factors `genotype` (with values I, II, and III) and `condition` (with values A and B), and we want to extract the condition effect specifically for each genotype. To adapt this to our data, we could think of this as the following: our two factors will be `cell.type` (with values _VGAT_ and _VGluT2_) and `PAG.area` (with values _dmpag_, _dlpag_, _lpag_, _vlpag_). To obtain the `PAG.area` effect for a specific `cell.type` we could merge both factors into a combined one (`celltype_PAGarea`), and use that in the model instead of the other two with an interaction term. We will do both approaches.

__A note on multi-factor designs:__
Experiments with more than one factor influencing the counts can be analyzed using design formula that include the additional variables. In fact, `DESeq2` can analyze any possible experimental design that can be expressed with fixed effects terms (multiple factors, designs with interactions, designs with continuous variables, splines, and so on are all possible).

By adding variables to the design, one can control for additional variation in the counts. For example, if the condition samples are balanced across experimental batches, by including the `batch` factor to the design, one can increase the sensitivity for finding differences due to `condition`. There are multiple ways to analyze experiments when the additional variables are of interest and not just controlling factors.

We will now generate a `DESeqDataSet` from a count matrix and a table of sample information (metadata) and specify different designs we want to test:
```{r}
library(DESeq2)
#### Design 0 ####
PAG_DESeq_set_0 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), 
                                          colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                          design = ~ mouse.sex + batch.processing + batch.sequencing_round)

#### Design 1 ####
PAG_DESeq_set_1 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), 
                                          colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                          design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type)

#### Design 2 ####
PAG_DESeq_set_2 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"),
                                          colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                          design = ~ mouse.sex + batch.processing + batch.sequencing_round + PAG.area)

#### Design 1&2 ####
PAG_DESeq_set_12 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), 
                                           colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                           design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.area)

#### Design 1&2 with interaction ####
PAG_DESeq_set_12a <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), 
                                            colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                            design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.area + cell.type:PAG.area)

#### Design 3 ####
PAG_DESeq_set_3 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), 
                                          colData = colData(PAG_sceset_qc_norm_filt_corr_clust),
                                          design = ~ mouse.sex + batch.processing + batch.sequencing_round + celltype_PAGarea)
```

Initial designs we tried
```{r}
# library(DESeq2)
# #### Design 0 ####
# PAG_DESeq_set_0 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                           colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                           design = ~ mouse.sex + batch.processing + batch.sequencing_round)
# 
# #### Design 1 ####
# PAG_DESeq_set_1 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                           colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                           design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type)
# 
# #### Design 2 ####
# PAG_DESeq_set_2 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"),
#                                           colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                           design = ~ mouse.sex + batch.processing + batch.sequencing_round + PAG.arearegistration)
# 
# #### Design 3 ####
# PAG_DESeq_set_3 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                           colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                           design = ~ mouse.sex + batch.processing + batch.sequencing_round + PAG.APaxis)
# 
# #### Design 1&2 ####
# PAG_DESeq_set_12 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                            colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                            design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.arearegistration)
# 
# #### Design 1&2 with interaction ####
# PAG_DESeq_set_12a <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                             colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                             design = ~ mouse.sex + batch.processing + batch.sequencing_round + group)
# 
# #### Design 1&3 ####
# PAG_DESeq_set_13 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                            colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                            design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.APaxis)
# 
# #### Design 1&3 with interaction ####
# PAG_DESeq_set_13b <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                             colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                             design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.APaxis + cell.type:PAG.APaxis)
# 
# #### Design 2&3 ####
# PAG_DESeq_set_23 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                            colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                            design = ~ mouse.sex + batch.processing + batch.sequencing_round + PAG.arearegistration + PAG.APaxis)
# 
# #### Design 2&3 with interaction #### --> Can't be done as PAG.APaxis:PAG.arearegistrations seems to be a linear combination of the others
# #PAG_DESeq_set_23c <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                             #colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                             #design = ~ mouse.sex + batch.processing + batch.sequencing_round + PAG.arearegistration + PAG.APaxis + PAG.APaxis:PAG.arearegistration)
# 
# #### Design 1&2&3 ####
# PAG_DESeq_set_123 <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                             colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                             design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.arearegistration + PAG.APaxis)
# 
# #### Design 1&2&3 with interaction ####
# PAG_DESeq_set_123ab <- DESeqDataSetFromMatrix(countData = assay(PAG_sceset_qc_norm_filt_corr, "counts_rounded"), 
#                                                colData = colData(PAG_sceset_qc_norm_filt_corr),
#                                                design = ~ mouse.sex + batch.processing + batch.sequencing_round + cell.type + PAG.arearegistration + PAG.APaxis + cell.type:PAG.arearegistration + cell.type:PAG.APaxis)
```

There are two separate analysis paths we can follow from here: visual exploration of sample relationships (transformation, distance calculation, plotting) and statistical testing for differences attributable to our conditions. Importantly, the statistical testing methods rely on original count data (not scaled or transformed) for calculating the precision of measurements. However, for visualization and exploratory analysis, transformed counts are typically more suitable. Thus, it is critical to separate the two workflows and use the appropriate input data for each of them.

#### Exploratory analysis and visualisation
Many common statistical methods for exploratory analysis of multidimensional data, for example clustering and principal components analysis (PCA), work best for data that generally has the same range of variance at different ranges of the mean values. When the expected amount of variance is approximately the same across different mean values, the data is said to be _homoskedastic_. For RNA-seq raw counts, however, the variance grows with the mean. For example, if one performs PCA directly on a matrix of size-factor-normalised read counts, the result typically depends only on the few most strongly expressed genes because they show the largest absolute differences between samples. A simple and often used strategy to avoid this is to take the logarithm of the normalised count values plus a small pseudocount; however, now the genes with the very lowest counts will tend to dominate the results because, due to the strong Poisson noise inherent to small count values, and the fact that the logarithm amplifies differences for the smallest values, these low count genes will show the strongest relative differences between samples.

As a solution, _DESeq2_ offers two transformations for count data that stabilize the variance across the mean: the _variance stabilizing transformation_ (`VST`) for negative binomial data with a dispersion-mean trend (Anders and Huber 2010), implemented in the `vst` function, and the _regularized-logarithm_ transformation (`rlog`) (Love, Huber, and Anders 2014). These have slightly different implementations, discussed a bit in the _DESeq2_ paper and in the vignette, but a similar goal of stabilizing the variance across the range of values. Both produce log2-like values for high counts. For genes with high counts, both the `VST` and the `rlog` will give similar results to the ordinary log2 transformation of normalised counts. For genes with lower counts, however, the values are shrunken towards a middle value. The VST or rlog-transformed data then become approximately _homoskedastic_ (more flat trend in the `meanSdPlot`), and can be used directly for computing distances between samples, making PCA plots, or as input to downstream methods which perform best with homoskedastic data. The VST transformation should be used for datasets with n > 30. We will therefore use the variance stabilizing transformation implemented with the `vst` function.
```{r}
start_time <- Sys.time() # Takes around 30min
PAG_DESeq_vsd <- DESeq2::vst(PAG_DESeq_set, blind = FALSE) 
end_time <- Sys.time()
end_time - start_time
# see ?varianceStabilizingTransformation for choice of blind

# This returns a DESeqTransform object containing the column metadata attached to the DESeqDataSet:
class(PAG_DESeq_vsd)
head(assay(PAG_DESeq_vsd), 3)
head(colData(PAG_DESeq_vsd))
```

Specifying `blind = FALSE` means that differences between `mouse.id` and `cell.type` (and the rest of the variables in the _design_) will not contribute to the expected variance-mean trend of the experiment. The experimental design is not used directly in the transformation, only in estimating the global amount of variability in the counts. For a fully unsupervised transformation, one can set `blind = TRUE` (which is the default).

***
**Sample distances:**
A useful first step in an RNA-seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment's design?

We can use the R function `dist` to calculate the Euclidean distance between samples. To ensure we have a roughly equal contribution from all genes, we use it on the _VST_ data. We need to transpose the matrix of values using `t`, because the `dist` function expects the different samples to be rows of its argument, and different dimensions (here, genes) to be columns.
```{r}
sampleDists <- dist(t(assay(PAG_DESeq_vsd)))
head(sampleDists)
```

We visualize the distances in a heatmap in a figure below, using the function `pheatmap` from the `pheatmap` package. In order to plot the sample distance matrix with the rows/columns arranged by the distances in our distance matrix, we manually provide `sampleDists` to the `clustering_distance` argument of the `pheatmap` function. Otherwise the `pheatmap` function would assume that the matrix contains the data values themselves, and would calculate distances between the rows/columns of the distance matrix, which is not desired. We also manually specify a blue color palette using the `colorRampPalette` function from the `RColorBrewer` package.
```{r}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(PAG_DESeq_vsd$group)
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)
```

***
**PCA plot:**
One way to visualize sample-to-sample distances is a principal components analysis (PCA). In this ordination method, the data points (here, the samples) are projected onto the 2D plane such that they spread out in the two directions that explain most of the differences. The x-axis (the first principal component, or PC1) is the direction that separates the data points the most (i.e., the direction with the largest variance). The y-axis (the second principal component, or PC2) represents the direction with largest variance subject to the constraint that it must be orthogonal to the first direction. The percent of the total variance that is contained in the direction is printed in the axis label. Note that these percentages do not sum to 100%, because there are more dimensions that contain the remaining variance (although each of these remaining dimensions will explain less than the two that we see).
```{r}
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "mouse.id")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "mouse.sex")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "batch.processing")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "batch.sequencing_round")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "PAG.PaxinosAPmanual")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "cell.type")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "PAG.area")
DESeq2::plotPCA(PAG_DESeq_vsd, intgroup = "group")
```

#### Differential expression testing with DESeq2
As we have already specified an experimental design when we created the _DESeqDataSet_, we can run the differential expression pipeline on the raw counts with a single call to the function `DESeq`. This function will carry out: the estimation of size factors (controlling for differences in the sequencing depth of the samples), the estimation of dispersion values for each gene, and fitting a generalized linear model. A _DESeqDataSet_ is returned that contains all the fitted parameters within it, and we can plot the estimated dispersions from it. We have several designs to test, so this will take a long time. To speed things up a bit, we will paralellise the analysis and filter lowly expressed genes. We have around 50 samples per `cell.type` per `PAG.area`, so if we are a bit conservative we keep only genes with at least 5 counts in at least 5 cells (around 10% of each condition). Recommendations for use of `DESeq2` for single-cell datasets are available in the `DESeq2` vignette, specially with regards to additional arguments to set in the `DEseq` function.
```{r}
#### Design 0 ####
keep_0 <- rowSums(counts(PAG_DESeq_set_0) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_0)
PAG_DESeq_set_0 <- PAG_DESeq_set_0[keep_0,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 1.40 hours
PAG_DESeq_set_0 <- DESeq2::DESeq(PAG_DESeq_set_0, test = "LRT", sfType = "poscounts", reduced = ~ 1, 
                                 minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_0)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_0, file = "PAG_DESeq_set_0.rds")

#### Design 1 ####
keep_1 <- rowSums(counts(PAG_DESeq_set_1) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_1)
PAG_DESeq_set_1 <- PAG_DESeq_set_1[keep_1,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 2.07 hours
PAG_DESeq_set_1 <- DESeq2::DESeq(PAG_DESeq_set_1, test = "LRT", sfType = "poscounts", reduced = ~ mouse.sex + batch.processing + batch.sequencing_round, 
                                 minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_1)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_1, file = "PAG_DESeq_set_1.rds")

#### Design 2 ####
keep_2 <- rowSums(counts(PAG_DESeq_set_2) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_2)
PAG_DESeq_set_2 <- PAG_DESeq_set_2[keep_2,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 2.33 hours
PAG_DESeq_set_2 <- DESeq2::DESeq(PAG_DESeq_set_2, test = "LRT", sfType = "poscounts", reduced = ~ mouse.sex + batch.processing + batch.sequencing_round,
                                 minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_2)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_2, file = "PAG_DESeq_set_2.rds")

#### Design 1&2 ####
keep_12 <- rowSums(counts(PAG_DESeq_set_12) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_12)
PAG_DESeq_set_12 <- PAG_DESeq_set_12[keep_12,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 2.42 hours
PAG_DESeq_set_12 <- DESeq2::DESeq(PAG_DESeq_set_12, test = "LRT", sfType = "poscounts", reduced = ~ mouse.sex + batch.processing + batch.sequencing_round,
                                  minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_12)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_12, file = "PAG_DESeq_set_12.rds")

#### Design 1&2 with interaction ####
keep_12a <- rowSums(counts(PAG_DESeq_set_12a) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_12a)
PAG_DESeq_set_12a <- PAG_DESeq_set_12a[keep_12a,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 2.68 hours
PAG_DESeq_set_12a <- DESeq2::DESeq(PAG_DESeq_set_12a, test = "LRT", sfType = "poscounts", reduced = ~ mouse.sex + batch.processing + batch.sequencing_round,
                                   minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_12a)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_12a, file = "PAG_DESeq_set_12a.rds")

#### Design 3 ####
keep_3 <- rowSums(counts(PAG_DESeq_set_3) >= 5) >= 5 # Identify genes with 5 copies in at least 5 cells.
summary(keep_3)
PAG_DESeq_set_3 <- PAG_DESeq_set_3[keep_3,] # Remove lowly expressed genes.

start_time <- Sys.time() # Takes around 2.65 hours
PAG_DESeq_set_3 <- DESeq2::DESeq(PAG_DESeq_set_3, test = "LRT", sfType = "poscounts", reduced = ~ mouse.sex + batch.processing + batch.sequencing_round,
                                 minReplicatesForReplace = Inf, useT = TRUE, minmu = 1e-6, parallel = TRUE)
DESeq2::plotDispEsts(PAG_DESeq_set_3)
end_time <- Sys.time()
end_time - start_time
saveRDS(PAG_DESeq_set_3, file = "PAG_DESeq_set_3.rds")

# Once you have run DESeq, make sure you save the resulting file at every step so you don't need to run it again even if it crashes.
print("Saved!")
```

Plotting the dispersion estimates is a useful diagnostic. A typical dispersion plot can be found in the `DESeq2` vignette, with the final estimates shrunk from the gene-wise estimates towards the fitted estimates. Some gene-wise estimates are flagged as outliers and not shrunk towards the fitted value (this outlier detection is described in the manual page for `estimateDispersionsMAP`). The amount of shrinkage can be more or less than seen here, depending on the sample size, the number of coefficients, the row mean and the variability of the gene-wise estimates.

#### Examining and Plotting the results
Results tables are generated using the function results, which extracts a results table with log2 fold changes, _p_ values and adjusted _p_ values. With no additional arguments to _results_, the log2 fold change and Wald test _p value_ will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the reference level. However, the order of the variables of the design do not matter so long as the user specifies the comparison to build a results table for, using the `name` or `contrast` arguments of results.

Next, calling `results` without any arguments will extract the estimated log2-fold changes and _p values_ for the last variable in the `design` formula. If there are more than 2 levels for this variable, `results` will extract the results table for a comparison of the last level over the first level.
```{r}
resultsNames(PAG_DESeq_set_1)
levels(PAG_sceset_qc_norm_filt_corr_clust$cell.type)
PAG_DESeq_results_1_wald <- DESeq2::results(PAG_DESeq_set_1, 
                                            contrast = c("cell.type", "VGluT2", "VGAT"), 
                                            test = "Wald",
                                            lfcThreshold = 0, alpha = 0.05, pAdjustMethod = "BH", parallel = TRUE)
head(PAG_DESeq_results_1_wald)
#mcols(PAG_DESeq_results_1, use.names = TRUE)
DESeq2::plotMA(PAG_DESeq_results_1_wald, ylim = c(-5, 5))
```

`PAG_DESeq_results_0` is a _DataFrame_ object, so it contains metadata with information:

* The first column, `baseMean`, is a just the average of the normalised count values, dividing by size factors, taken over all samples in the _DESeqDataSet_. The remaining four columns refer to a specific contrast, for example the comparison of the `VGAT` level over the `VGluT2` level for the factor variable `cell.type`.
* The column `log2FoldChange` is the effect size estimate. It tells us how much the gene's expression seems to have changed due to our specified codition. This value is reported on a logarithmic scale to base 2: for example, a log2 fold change of 1.5 means that the gene's expression is increased by a multiplicative factor of `2^1.5 ~ 2.82`.
* Of course, this estimate has an uncertainty associated with it, which is available in the column `lfcSE`, the standard error estimate for the log2 fold change estimate. 
* We can also express the uncertainty of a particular effect size estimate as the result of a statistical test. The purpose of a test for differential expression is to test whether the data provide sufficient evidence to conclude that this value is really different from zero. _DESeq2_ performs for each gene a hypothesis test to see whether evidence is sufficient to decide against the null hypothesis that there is zero effect of the treatment on the gene and that the observed difference between treatment and control was merely caused by experimental variability (i.e., the type of variability that you can expect between different samples in the same treatment group). As usual in statistics, the result of this test is reported as a _p value_, and it is found in the column `pvalue`. Remember that a _p value_ indicates the probability that an effect as strong as the observed one, or even stronger, would be seen under the situation described by the null hypothesis.

We can also summarize the results as follows:
```{r}
summary(PAG_DESeq_results_1_wald)
hist(PAG_DESeq_results_1_wald$pvalue)

## We can also add a couple of extra columns that will be useful for the interactive visualization later
PAG_DESeq_results_1_wald$log10BaseMean <- log10(PAG_DESeq_results_1_wald$baseMean)
PAG_DESeq_results_1_wald$mlog10PValue <- -log10(PAG_DESeq_results_1_wald$pvalue)
rowData(PAG_DESeq_set_1)$log10Dispersion <- log10(rowData(PAG_DESeq_set_3)$dispersion)
rowData(PAG_DESeq_set_1)$DESeq2_VGluT2_VGAT <- PAG_DESeq_results_1_wald # Or any other comparison you called using results
```

There are two ways to be more strict about which set of genes are considered significant:
* Lower the false discovery rate threshold (the threshold on `padj` in the results table)
* Raise the log2 fold change threshold from 0 using the `lfcThreshold` argument of _results_

If we lower the false discovery rate threshold, we should also tell this value to `results()` when we run it, so that the function will use an alternative threshold for the optimal independent filtering step:
```{r}
PAG_DESeq_results_3_05 <- DESeq2::results(PAG_DESeq_set_3, alpha = 0.05)
table(PAG_DESeq_results_1_wald$padj < 0.05)
```

If we want to raise the log2 fold change threshold, so that we test for genes that show more substantial changes due to our condition of interest, we simply supply a value on the log2 scale. For example, by specifying `lfcThreshold = 1`, we test for genes that show significant effects of treatment on gene counts more than doubling or less than halving, because `2^1 = 2`.
```{r}
PAG_DESeq_results_1_LFC1 <- results(PAG_DESeq_set_1, lfcThreshold = 1)
summary(PAG_DESeq_results_1_LFC1)
table(PAG_DESeq_results_1_LFC1$padj < 0.1)
```

Sometimes a subset of the p values in `DESeq_results` will be `NA` (not available). This is DESeq's way of reporting that all counts for this gene were zero, and hence no test was applied. In addition, _p values_ can be assigned `NA` if the gene was excluded from analysis because it contained an extreme count outlier. For more information, see the outlier detection section of the DESeq2 vignette.

***
__Multiple Testing__
In high-throughput biology, we are careful to not use the _p values_ directly as evidence against the null hypothesis, but to correct for multiple testing. _DESeq2_ and _edgeR_ use the Benjamini-Hochberg (BH) adjustment (Benjamini and Hochberg 1995) as implemented in the base R `p.adjust` function; in brief, this method calculates for each gene an adjusted p value that answers the following question: if one called significant all genes with an adjusted p value less than or equal to this gene's adjusted p value threshold, what would be the fraction of false positives (the false discovery rate, FDR) among them, in the sense of the calculation outlined above? These values, called the BH-adjusted p values, are given in the column `padj` of the `res` object from _DESeq2_, and in the `FDR` column in the `TopTags` object from _edgeR_.

The FDR is a useful statistic for many high-throughput experiments, as we are often interested in reporting or focusing on a set of interesting genes, and we would like to put an upper bound on the percent of false positives in this set. Hence, if we consider a fraction of 5% false positives acceptable, we can consider all genes with an adjusted p value below 5% = 0.05 as significant. 
```{r}
sum(PAG_DESeq_results_1_wald$padj < 0.05, na.rm = TRUE)
```

We subset the results table to these genes and then sort it by the log2 fold change estimate to get the significant genes:
```{r}
resSig <- subset(PAG_DESeq_results_1_wald, padj < 0.05)
head(resSig[ order(resSig$log2FoldChange), ]) #  with the strongest down-regulation
head(resSig[ order(resSig$log2FoldChange, decreasing = TRUE), ]) # with the strongest up-regulation
```

#### Plotting results
***
__Counts plot__
A quick way to visualize the counts for a particular gene is to use the `plotCounts` function that takes as arguments the `DESeqDataSet`, a gene name, and the group over which to plot the counts.
```{r}
plotCounts(PAG_DESeq_set_1, gene = "Col6a6", intgroup = "cell.type", 
           normalized = TRUE, transform = FALSE)

topGene <- rownames(PAG_DESeq_results_1_wald)[which.min(PAG_DESeq_results_1_wald$padj)]
plotCounts(PAG_DESeq_set_1, gene = topGene, intgroup=c("cell.type"))
```

We can also make custom plots using the `ggplot` function from the `ggplot2` package.
```{r}
library("ggbeeswarm")
geneCounts <- plotCounts(PAG_DESeq_set_1, gene = topGene, intgroup = c("PAG.area","cell.type"),
                         returnData = TRUE)

ggplot(geneCounts, aes(x = PAG.area, y = count, color = cell.type)) +
  scale_y_log10() +  geom_beeswarm(cex = 3)

ggplot(geneCounts, aes(x = PAG.area, y = count, color = cell.type, group = cell.type)) +
  scale_y_log10() + geom_point(size = 3) + geom_line()
```

***
__MA-plot__
An MA-plot (Dudoit et al. 2002) provides a useful overview for the distribution of the estimated coefficients in the model, e.g. the comparisons of interest, across all genes. On the y-axis, the "M" stands for "minus" - subtraction of log values is equivalent to the log of the ratio - and on the x-axis, the "A" stands for "average." You may hear this plot also referred to as a mean-difference plot, or a Bland-Altman plot. Each gene is represented with a dot. Genes with an adjusted p value below a threshold (the default with DESeq2 is 0.1) are shown in red.

Before making the MA-plot, we use the `lfcShrink` function to shrink the log2 fold changes for the comparison of choice. There are three types of shrinkage estimators in DESeq2, which are covered in the DESeq2 vignette. Here we specify the `apeglm` method for shrinking coefficients, which is good for shrinking the noisy LFC estimates while giving low bias LFC estimates for true large differences (Zhu, Ibrahim, and Love 2018). To use `apeglm` we specify a coefficient from the model to shrink, either by name or number as the coefficient appears in `resultsNames(dds)`.
```{r}
library("apeglm")
resultsNames(PAG_DESeq_set_1) # Check to see which coef to choose
```

```{r}
PAG_DESeq_results_1_LFC <- lfcShrink(PAG_DESeq_set_1, coef="cell.type_VGluT2_vs_VGAT", 
                                     type="apeglm",
                                     lfcThreshold = 0, parallel = TRUE)
PAG_DESeq_results_1_LFC
DESeq2::plotMA(PAG_DESeq_results_1_LFC, ylim = c(-2, 2))
```

We can label individual points on the MA-plot as well. Here we use the `with` R function to plot a circle and text for a selected row of the results object. Within the `with` function, only the `baseMean` and `log2FoldChange` values for the selected rows of `PAG_DESeq_results_0` are used.
```{r}
plotMA(PAG_DESeq_results_1_wald, ylim = c(-5,5))
topGene <- rownames(PAG_DESeq_results_1_wald)[which.min(PAG_DESeq_results_3$padj)]
with(PAG_DESeq_results_1_wald[topGene, ], {
  points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
  text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})
```

Another useful diagnostic plot is the histogram of the p values. This plot is best formed by excluding genes with very small counts, which otherwise generate spikes in the histogram.
```{r}
hist(PAG_DESeq_results_1_wald$pvalue[PAG_DESeq_results_1_wald$baseMean > 1], breaks = 0:20/20,
     col = "grey50", border = "white")
```

After calling plotMA, one can use the function identify to interactively detect the row number of individual genes by clicking on the plot. One can then recover the gene identifiers by saving the resulting indices:
```{r}
plotMA(PAG_DESeq_results_1_wald, ylim = c(-5, 5))
idx <- identify(PAG_DESeq_results_1_wald$baseMean, PAG_DESeq_results_1_wald$log2FoldChange)
rownames(PAG_DESeq_results_1_wald)[idx]
```

***
__Gene clustering__
Another way of representing the results of a differential expression analysis is to construct a heatmap of the top differentially expressed genes. A heatmap is a color coded expression matrix, where the rows and columns are clustered using hierarchical clustering. Typically, it should not be applied to counts, but works better with transformed values. Here we show how it can be applied to the variance-stabilized values generated above. We choose the top 30 differentially expressed genes. There are many functions in R that can generate heatmaps, here we show the one from the `pheatmap` package.

In the sample distance heatmap made previously, the dendrogram at the side shows us a hierarchical clustering of the samples. Such a clustering can also be performed for the genes. Since the clustering is only relevant for genes that actually carry a signal, one usually would only cluster a subset of the most highly variable genes. For example, let us select the 30 genes with the highest variance across samples. We will work with the VST data. In addition, the heatmap becomes more interesting if we do not look at absolute expression strength but rather at the amount by which each gene deviates in a specific sample from the gene's average across all samples. Hence, we center each gene's values across samples, and plot a heatmap. We provide a `data.frame` that instructs the `pheatmap` function how to label the columns.
```{r}
library(pheatmap)

PAG_DESeq_mat <- assay(PAG_DESeq_vsd)[head(order(PAG_DESeq_results$padj), 30), ] # Top 30 DE genes
PAG_DESeq_mat <- PAG_DESeq_mat - rowMeans(PAG_DESeq_mat)
anno <- as.data.frame(colData(PAG_DESeq_vsd)[, c("mouse.id", "cell.type", "PAG.area")])
pheatmap(PAG_DESeq_mat, annotation_col = anno)
```

***
__Independent filtering__
The MA plot highlights an important property of RNA-seq data. For weakly expressed genes, we have no chance of seeing differential expression, because the low read counts suffer from such high Poisson noise that any biological effect is drowned in the uncertainties from the sampling at a low rate. We can also show this by examining the ratio of small p values (say, less than 0.05) for genes binned by mean normalised count. We will use the results table subjected to the threshold to show what this looks like in a case when there are few tests with small p value.

In the following code chunk, we create bins using the quantile function, bin the genes by base mean using cut, rename the levels of the bins using the middle point, calculate the ratio of p values less than 0.05 for each bin, and finally plot these ratios.
```{r}
qs <- c(0, quantile(PAG_DESeq_results_LFC1$baseMean[PAG_DESeq_results_LFC1$baseMean > 0], 0:6/6))
bins <- cut(PAG_DESeq_results_LFC1$baseMean, qs)
levels(bins) <- paste0("~", round(signif((qs[-1] + qs[-length(qs)])/2, 2)))
fractionSig <- tapply(PAG_DESeq_results_LFC1$pvalue, bins, function(p)
                          mean(p < .05, na.rm = TRUE))
barplot(fractionSig, xlab = "mean normalised count",
                     ylab = "fraction of small p values")
```

At first sight, there may seem to be little benefit in filtering out these genes. After all, the test found them to be non-significant anyway. However, these genes have an influence on the multiple testing adjustment, whose performance improves if such genes are removed. By removing the low count genes from the input to the FDR procedure, we can find more genes to be significant among those that we keep, and so improved the power of our test. This approach is known as independent filtering.

The DESeq2 software automatically performs independent filtering that maximizes the number of genes with adjusted p value less than a critical value (by default, `alpha` is set to 0.1). This automatic independent filtering is performed by, and can be controlled by, the results function.

The term independent highlights an important caveat. Such filtering is permissible only if the statistic that we filter on (here the mean of normalised counts across all samples) is independent of the actual test statistic (the p value) under the null hypothesis. Otherwise, the filtering would invalidate the test and consequently the assumptions of the BH procedure. The independent filtering software used inside DESeq2 comes from the `genefilter` package, that contains a reference to a paper describing the statistical foundation for independent filtering (Bourgon, Gentleman, and Huber 2010).

#### Annotating and exporting results
Our result table so far only contains the Ensembl gene IDs, but alternative gene names may be more informative for interpretation. Bioconductor's annotation packages help with mapping various ID schemes to each other. We load the `AnnotationDbi` package and the annotation package `org.Mm.eg.db`, the organism annotation package ("org") for Mus musculus ("Mm"), organized as an `AnnotationDbi` database package ("db"), using Entrez Gene IDs ("eg") as primary key. To get a list of all available key types, use:
```{r}
library(AnnotationDbi)
library(org.Mm.eg.db)
columns(org.Mm.eg.db)
```

We can use the `mapIds` function to add individual columns to our results table. We provide the row names of our results table as a key, and specify that `keytype=ENSEMBL`. The column argument tells the `mapIds` function which information we want, and the `multiVals` argument tells the function what to do if there are multiple possible values for a single input value. Here we ask to just give us back the first one that occurs in the database. To add the gene symbol and Entrez ID, we call `mapIds` twice.
```{r}
PAG_DESeq_results_1$symbol <- mapIds(org.Mm.eg.db,
                                   keys = rownames(PAG_DESeq_results_1),
                                   column = "SYMBOL",
                                   keytype = "ENSEMBL",
                                   multiVals = "first")

PAG_DESeq_results_1$entrez <- mapIds(org.Mm.eg.db,
                                   keys = rownames(PAG_DESeq_results_1),
                                   column = "ENTREZID",
                                   keytype = "ENSEMBL",
                                   multiVals = "first")
```

We can easily save the results table in a CSV file that we can then share or load with a spreadsheet program such as Excel (note, however, that Excel sometimes does funny things to gene identifiers (Zeeberg et al. 2004; Ziemann, Eren, and El-Osta 2016)). The call to `as.data.frame` is necessary to convert the `DataFrame` object (`IRanges` package) to a `data.frame` object that can be processed by `write.csv`.
```{r}
PAG_DESeq_results_1_wald_ordered <- PAG_DESeq_results_1_wald[order(PAG_DESeq_results_1_wald$padj), ]
head(PAG_DESeq_results_1_wald_ordered)

PAG_DESeq_results_1_wald_ordered <- as.data.frame(PAG_DESeq_results_1_wald_ordered)[seq_len(sum(PAG_DESeq_results_1_wald$padj < 0.05, na.rm = TRUE)), ] # Exporting the genes with padg<0.05
PAG_DESeq_results_1_wald_ordered <- PAG_DESeq_results_1_wald_ordered[order(PAG_DESeq_results_1_wald_ordered$log2FoldChange, decreasing = TRUE), ]
write.table(cbind(id = rownames(PAG_DESeq_results_1_wald_ordered), PAG_DESeq_results_1_wald_ordered), quote = FALSE, sep = "\t", row.names = FALSE, file = "PAG_DESeq_results_1_wald_ordered.txt")
write.csv(PAG_DESeq_results_1_wald_ordered, file = "PAG_DESeq_results_1_wald_ordered.csv")
```

A more sophisticated way for exporting results the Bioconductor package `ReportingTools` (Huntley et al. 2013). `ReportingTools` will automatically generate dynamic HTML documents, including links to external databases using gene identifiers and boxplots summarizing the normalised counts across groups. See the `ReportingTools` vignettes for full details. The simplest version of creating a dynamic `ReportingTools` report is performed with the following code:
```{r}
library("ReportingTools")
htmlRep <- HTMLReport(shortName="report", title="My report",
                      reportDirectory="./report")
publish(resOrderedDF, htmlRep)
url <- finish(htmlRep)
browseURL(url)
```

### 7.2.2 | edgeR: the DGEList
`edgeR` is designed for bulkRNA and is based on a negative binomial model of gene expression and uses a generalized linear model (GLM) framework, that enables us to include other factors such as `batch` to the model. The _edgeR_ package uses another type of data container, namely a _DGEList_ object. We can create a _DGEList_ object using a count matrix and a table with information about samples, and additionally add information about the genes.
```{r}
library(edgeR)

PAG_genetable <- data.frame(gene.id = rownames(PAG_sceset_qc_norm_filt_corr_clust),
                            stringsAsFactors = FALSE)

stopifnot(all(rownames(colData(PAG_sceset_qc_norm_filt_corr_clust)) == colnames(PAG_sceset_qc_norm_filt_corr_clust)))

PAG_DGE_list <- DGEList(counts = assay(PAG_sceset_qc_norm_filt_corr_clust, "counts_rounded"), # raw read counts, rounded
                        #lib.size = colSums(counts), # numeric vector giving the total count (sequence depth) for each library.
                        #norm.factors = rep(1, length(counts[1,])), # numeric vector of normalisation factors that modify the library sizes (could insert scran size factors here)
                        samples = colData(PAG_sceset_qc_norm_filt_corr_clust), # data frame containing information for each sample
                        group = NULL, # vector or factor giving the experimental group/condition for each sample/library
                        genes = PAG_genetable, # data frame containing annotation information for each gene
                        remove.zeros = FALSE) # logical, whether to remove rows that have 0 total count

names(PAG_DGE_list)
```

Just like the _SummarizedExperiment_ and the _DESeqDataSet_ the _DGEList_ contains all the information we need: the count matrix, information about the samples (the columns of the count matrix), and information about the genes (the rows of the count matrix). One difference compared to the _DESeqDataSet_ is that the experimental design is not defined when creating the _DGEList_, but later in the workflow.

Once a `DGEList` has been created, we calculate between-sample (TMM) normalisation factors, using the `calcNormFactors` function in `edgeR`.
```{r}
PAG_DGE_list <- edgeR::calcNormFactors(PAG_DGE_list, method="TMM")
PAG_DGE_list$samples
```

#### Exploratory analysis and visualization
***
**MDS plot:**
A way to reduce dimensionality, which is in many ways similar to PCA, is _multidimensional scaling_ (MDS). For MDS, we first have to calculate all pairwise distances between our objects (samples in this case), and then create a (typically) two-dimensional representation where these pre-calculated distances are represented as accurately as possible. This means that depending on how the pairwise sample distances are defined, the two-dimensional plot can be very different, and it is important to choose a distance that is suitable for the type of data at hand.

_edgeR_ contains a function `plotMDS`, which operates on a `DGEList` object and generates a two-dimensional MDS representation of the samples. The default distance between two samples can be interpreted as the “typical” log fold change between the two samples, for the genes that are most different between them (by default, the top 500 genes, but this can be modified). We generate an MDS plot from the DGEList object `PAG_DGE_list`, coloring by the `PAG.area` and using different plot symbols for different cell types:
```{r}
plotMDS(PAG_DGE_list, top = 500, labels = NULL, col = as.numeric(PAG_DGE_list$samples$PAG.area), 
        pch = as.numeric(PAG_DGE_list$samples$cell.type), cex = 2, gene.selection = "common")
```

#### Differential expression testing with EdgeR
_edgeR_ is designed for bulkRNA and is based on a negative binomial model of gene expression and uses a generalized linear model (GLM) framework, the enables us to include other factors such as `batch` to the model. We have a `DGEList` object containing all the necessary information. We first define a design matrix, using the same formula syntax as we did for _DESeq2_.
```{r}
names(PAG_DGE_list)
PAG_DGE_design <- model.matrix(~ mouse.sex + batch.processing + batch.sequencing_round + celltype_PAGarea,
                               data = PAG_DGE_list$samples)
```

While _DESeq2_ performs independent filtering of lowly expressed genes internally, this is done by the user before applying _edgeR_. Here, we filter out lowly expressed genes using the `filterByExpr()` function, and then estimate the dispersion for each gene. Note that it is important that we specify the design in the dispersion calculation. Afterwards, we plot the estimated dispersions. By default, the function keeps genes with about 10 read counts or more in a minimum number of samples, where the number of samples is chosen according to the minimum group sample size.

Biological CV (BCV) is the coefficient of variation with which the (unknown) true abundance of the gene varies between replicate RNA samples. It represents the CV that would remain between biological replicates if sequencing depth could be increased indefinitely. The technical CV decreases as the size of the counts increases. BCV on the other hand does not. BCV is therefore likely to be the dominant source of uncertainty for high-count genes, so reliable estimation of BCV is crucial for realistic assessment of differential expression in RNA-Seq experiments. If the abundance of each gene varies between replicate RNA samples in such a way that the genewise standard deviations are proportional to the genewise means, a commonly occurring property of measurements on physical quantities, then it is reasonable to suppose that BCV is approximately constant across genes. We allow however for the possibility that BCV might vary between genes and might also show a systematic trend with respect to gene expression or expected count. The magnitude of BCV is more important than the exact probabilistic law followed by the true gene abundances. For mathematical convenience, we assume that the true gene abundances follow a gamma distributional law between replicate RNA samples. This implies that the read counts follow a negative binomial probability law.
```{r}
start_time <- Sys.time() # Takes around 1.61 hours
DGE_genes_keep <- edgeR::filterByExpr(PAG_DGE_list, PAG_DGE_design, min.count = 5) # Choose a specific gene filter
table(DGE_genes_keep)
PAG_DGE_list <- PAG_DGE_list[DGE_genes_keep, ]
PAG_DGE_list <- edgeR::estimateDisp(PAG_DGE_list, PAG_DGE_design)
saveRDS(PAG_DGE_list, file = "PAG_DGE_list.rds")
end_time <- Sys.time()
end_time - start_time

edgeR::plotBCV(PAG_DGE_list)
```

Finally, we fit the generalized linear model and perform the test. In the `glmQLFTest` function, we indicate which coefficient (which column in the design matrix) we would like to test for. It is possible to test more general contrasts as well, and the user guide contains many examples on how to do this. The `topTags` function extracts the top-ranked genes. You can indicate the adjusted p-value cutoff, and/or the number of genes to keep.

For general experiments, once dispersion estimates are obtained and negative binomial generalized linear models are fitted, we can proceed with testing procedures for determining differential expression using either quasi-likelihood (QL) F-test or likelihood ratio test. While the likelihood ratio test is a more obvious choice for inferences with GLMs, the QL F-test is preferred as it reflects the uncertainty in estimating the dispersion for each gene. It provides more robust and reliable error rate control when the number of replicates is small.

Given raw counts, NB dispersion(s) and a design matrix, `glmQLFit()` fits the negative binomial GLM for each tag and produces an object of class `DGEGLM` with some new components. This `DGEGLM` object can then be passed to `glmQLFTest()` to carry out the QL F-test. User can select one or more coefficients to drop from the full design matrix. This gives the null model against which the full model is compared. Tags can then be ranked in order of evidence for differential expression, based on the p-value computed for each tag.
```{r}
start_time <- Sys.time() # Takes around 40 minutes
fit <- edgeR::glmQLFit(PAG_DGE_list, PAG_DGE_design)
qlf <- edgeR::glmQLFTest(fit, coef = 30:36)
end_time <- Sys.time()
end_time - start_time

PAG_edgeR_results_all <- edgeR::topTags(qlf, n = nrow(PAG_DGE_list), sort.by = "none") # all genes
hist(PAG_edgeR_results_all$table$PValue)

PAG_edgeR_results_tt <- edgeR::topTags(qlf, n = nrow(PAG_DGE_list), p.value = 0.05) # genes with adj.p<0.05
PAG_edgeR_results_tt10 <- edgeR::topTags(qlf) # just the top 10 by default
PAG_edgeR_results_tt10

# Alternative from Hemberg Lab scRNAseq Course:
#res <- glmLRT(fit)
#pVals <- res$table[,4]
#names(pVals) <- rownames(res$table)
#pVals <- p.adjust(pVals, method = "fdr")
```

The columns in the _edgeR_ result data frame are similar to the ones output by _DESeq2_. _edgeR_ represents the overall expression level on the log-CPM scale rather than on the normalised count scale that DESeq2 uses. The `F` column contains the test statistic, and the `FDR` column contains the Benjamini-Hochberg adjusted p-values.

We can also test for significance relative to a fold-change threshold, using the function `glmTreat`. Below we set the log fold-change threshold to 1 (i.e., fold change threshold equal to 2), as for DESeq2 above.
```{r}
PAG_edgeR_results_treat <- edgeR::glmTreat(fit, coef = ncol(PAG_DGE_design), lfc = 1)
PAG_edgeR_results_treat_tt <- edgeR::topTags(PAG_edgeR_results_treat, n = nrow(PAG_DGE_list), sort.by = "none")
```

#### Plotting results
In edgeR, the MA plot is obtained via the `plotSmear` function.
```{r}
edgeR::plotSmear(qlf, de.tags = PAG_edgeR_results_tt$table$gene.id)
```

#### Gene ontology and pathway analysis
The gene ontology (GO) enrichment analysis and the KEGG pathway enrichment analysis are the common downstream procedures to interpret the differential expression results in a biological context. Given a set of genes that are up- or down-regulated under a certain contrast of interest, a GO (or pathway) enrichment analysis will find which GO terms (or pathways) are over- or under-represented using annotations for the genes in that set.

The GO analysis can be performed using the `goana()` function in edgeR. The KEGG pathway analysis can be performed using the `kegga()` function in edgeR. Both `goana()` and `kegga()` take a `DGELRT` or `DGEExact` object. They both use the NCBI RefSeq annotation. Therefore, the Entrez Gene identifier (ID) should be supplied for each gene as the row names of the input object. Also users should set `species` according to the organism being studied. The top set of most enriched GO terms can be viewed with the `topGO()` function, and the top set of most enriched KEGG pathways can be viewed with the `topKEGG()` function.
```{r}
go <- goana(qlf, species="Mm")
topGO(go, sort="up")

keg <- kegga(qlf, species="Mm")
topKEGG(keg, sort="up")
```

### 7.2.3 | Comparing DESeq2 and edgeR results:
We can compare the sets of significantly differentially expressed genes to see how the results from the two packages overlap:
```{r}
PAG_DE_shared <- intersect(rownames(PAG_DESeq_results), PAG_edgeR_results_all$table$gene.id)
table(DESeq2 = PAG_DESeq_results$padj[match(PAG_DE_shared, rownames(PAG_DESeq_results))] < 0.1, 
      edgeR = PAG_edgeR_results_all$table$FDR[match(PAG_DE_shared, PAG_edgeR_results_all$table$gene.id)] < 0.1)
```

We can also compare the two result lists by the ranks:
```{r}
plot(rank(PAG_DESeq_results$pvalue[match(PAG_DE_shared, rownames(PAG_DESeq_results))]), 
     rank(PAG_edgeR_results_all$table$PValue[match(PAG_DE_shared, PAG_edgeR_results_all$table$gene.id)]), 
     cex = 0.1, xlab = "DESeq2", ylab = "edgeR")
```

## Step 7.3 | RNAseq123 Workflow
The [RNAseq123 Workflow](https://bioconductor.org/packages/release/workflows/html/RNAseq123.html) uses the _edgeR_ package (Robinson, McCarthy, and Smyth 2010) to import, organise, filter and normalise the data, and the _limma_ package (Ritchie et al. 2015) with its _voom_ method for linear modelling and empirical Bayes moderation to assess differential expression and perform gene set testing.
```{r}
library(limma)
library(Glimma)
library(edgeR)
library(Mus.musculus)
```

### 7.3.1 | Loading the data
We start the DE workflow from a gene-vs-sample matrix, where raw reads have been quality controlled and gene expression quantified.
```{r}
# Round the counts to ensure they are integers:
PAG_DE_counts <- round(assay(PAG_sceset_qc, "counts")) # NOT the normalised counts
head(PAG_DE_counts)
```

Read the relevant metadata, converting the key annotations `factor`:
```{r}
# Try to keep only the metadata that is relevant for the analysis.
PAG_DE_metadata <- PAG_metadata # Alternatively use colData(PAG_sceset_qc)
PAG_DE_metadata
rownames(PAG_DE_metadata)

# Factorize the relevant annotations for proper usage within the DE packages:
PAG_DE_metadata$mouse.id <- factor(PAG_DE_metadata$mouse.id)
PAG_DE_metadata$cell.type <- factor(PAG_DE_metadata$cell.type)
PAG_DE_metadata$PAG.area <- factor(PAG_DE_metadata$PAG.area)
```

Create a _DGEList_ object as we would do for _edgeR_:
```{r}
PAG_genetable <- data.frame(gene.id = rownames(PAG_DE_counts),
                            stringsAsFactors = FALSE)

stopifnot(all(colnames(PAG_DE_counts) == rownames(PAG_DE_metadata)))
PAG_limma_set <- DGEList(counts = PAG_DE_counts,
                         samples = PAG_DE_metadata, 
                         genes = PAG_genetable)

names(PAG_limma_set)
```

### 7.3.2 | Data pre-processing
Probably already done before, but ideally we should exclude low-quality cells and remove genes with zero counts before proceeding. We also calculate normalisation factors:
```{r}
cpm <- cpm(PAG_limma_set)
lcpm <- cpm(PAG_limma_set, log=TRUE)

PAG_limma_set <- calcNormFactors(PAG_limma_set, method = "TMM")
PAG_limma_set$samples$norm.factors
```

### 7.3.3 | Creating a design matrix and contrasts
For a given experiment, there are usually several equivalent ways to set up an appropriate design matrix. For example, `~0+group+lane` removes the intercept from the first factor, `group`, but an intercept remains in the second factor lane. Alternatively, `~group+lane` could be used to keep the intercepts in both `group` and `lane`. Understanding how to interpret the coefficients estimated in a given model is key here. We choose the first model for our analysis, as setting up model contrasts is more straight forward in the absence of an intercept for `group`. Contrasts for pairwise comparisons between cell populations are set up in limma using the `makeContrasts` function.
```{r}
PAG_limma_design <- model.matrix(~ mouse.id + cell.type + PAG.area,
                                 data = PAG_limma_set$samples)
PAG_limma_design

PAG_limma_contrasts_matrix <- makeContrasts(VGATvsVGluT2 = VGAT-VGluT2,
                                            levels = colnames(PAG_limma_design))
PAG_limma_contrasts_matrix
```

A key strength of limma's linear modelling approach, is the ability accommodate arbitrary experimental complexity. Simple designs, such as the one in this workflow, with cell type and batch, through to more complicated factorial designs and models with interaction terms can be handled relatively easily. Where experimental or technical effects can be modelled using a random effect, another possibility in limma is to estimate correlations using `duplicateCorrelation` by specifying a `block` argument for both this function and in the `lmFit` linear modelling step.

### 7.3.4 | Removing heteroscedascity from count data and linear modelling
RNA-seq data is homoscedastic (the variance is not independent of the mean). Methods that model counts using a Negative Binomial distribution assume a quadratic mean-variance relationship. In limma, linear modelling is carried out on the log-CPM values which are assumed to be normally distributed and the mean-variance relationship is accommodated using precision weights calculated by the voom function.

When operating on a DGEList-object, `voom` converts raw counts to log-CPM values by automatically extracting library sizes and normalisation factors from `PAG_limma_set` itself. Additional normalisation to log-CPM values can be specified within `voom` using the `normalize.method `argument. Typically, the _voom-plot_ shows a decreasing trend between the means and variances resulting from a combination of technical variation in the sequencing experiment and biological variation amongst the replicate samples from different cell populations. Experiments with high biological variation usually result in flatter trends, where variance values plateau at high expression values. Experiments with low biological variation tend to result in sharp decreasing trends.
```{r}
par(mfrow=c(1,2))
PAG_limma_set_voom <- voom(PAG_limma_set, PAG_limma_design, plot=TRUE)
PAG_limma_set_voom
```

Linear modelling in limma is carried out using the `lmFit` and `contrasts.fit` functions originally written for application to microarrays. The functions can be used for both microarray and RNA-seq data and fit a separate model to the expression values for each gene. Next, empirical Bayes moderation is carried out by borrowing information across all the genes to obtain more precise estimates of gene-wise variability (Smyth 2004).
```{r}
PAG_limma_set_voom_fit <- lmFit(PAG_limma_set_voom, PAG_limma_design)
PAG_limma_set_voom_fit <- contrasts.fit(PAG_limma_set_voomfit, contrasts=PAG_limma_contrasts_matrix)
PAG_limma_set_voom_efit <- eBayes(PAG_limma_set_voomfit)
plotSA(PAG_limma_set_voom_efit, main="Final model: Mean-variance trend")
```

The figure should shwo the means (x-axis) and variances (y-axis) of each gene plotted to show the dependence between the two before `voom` is applied to the data (left panel) and how the trend is removed after `voom` precision weights are applied to the data (right panel). The plot on the left is created within the `voom` function which extracts residual variances from fitting linear models to log-CPM transformed data. Variances are then rescaled to quarter-root variances (or square-root of standard deviations) and plotted against the average log2 count for each gene. The plot on the right is created using `plotSA` which plots log2 residual standard deviations against mean log-CPM values. In both plots, each black dot represents a gene. On the left plot, the red curve shows the estimated mean-variance trend used to compute the `voom` weights. On the right plot, the average log2 residual standard deviation estimated by the empirical Bayes algorithm is marked by a horizontal blue line.

### 7.3.5 | Examining the number of DE genes
For a quick look at differential expression levels, the number of significantly up- and down-regulated genes can be summarised in a table. 
```{r}
summary(decideTests(PAG_limma_set_voom_efit))
```

For a stricter definition on significance, one may require log-fold-changes (log-FCs) to be above a minimum value. The `treat` method (McCarthy and Smyth 2009) can be used to calculate p-values from empirical Bayes moderated t-statistics with a minimum log-FC requirement.
```{r}
PAG_limma_set_treat_fit <- treat(PAG_limma_set_voom_fit, lfc=1)
PAG_limma_set_treat_fit_dt <- decideTests(PAG_limma_set_treat_fit)
summary(PAG_limma_set_treat_fit_dt)
```

Genes that are DE in multiple comparisons can be extracted using the results from `decideTests`, where 0s represent genes that are not DE, 1s represent genes that are up-regulated, and -1s represent genes that are down-regulated. The `write.fit` function can be used to extract and write results for all comparisons to a single output file.
```{r}
PAG_limma_DE_genes <- which(PAG_limma_set_treat_fit_dt[,1]!=0 & PAG_limma_set_treat_fit_dt[,2]!=0)
length(PAG_limma_DE_genes) # Number of DE genes.

head(PAG_limma_set_treat_fit$genes$SYMBOL[PAG_limma_DE_genes], n=20) # Try without $SYMBOL if it fails

# A venn diagram shows the number of DE genes in each comparisons, the number of genes that are DE in both comparisons, and the number of genes that are not DE in either comparison (bottom-right).
vennDiagram(PAG_limma_set_treat_fit_dt[,1:2], circle.col=c("turquoise", "salmon"))

# Extract and write results for all comparisons to a single output file.
write.fit(PAG_limma_set_treat_fit, PAG_limma_set_treat_fit_dt, file="PAG_limma_results.txt")
```

The top DE genes can be listed using `topTreat` for results using `treat` (or `topTable`for results using `eBayes`). By default `topTreat` arranges genes from smallest to largest adjusted p-value with associated gene information, log-FC, average log-CPM, moderated t-statistic, raw and adjusted p-value for each gene. The number of top genes displayed can be specified, where `n=Inf` includes all genes.
```{r}
VGAT_vs_VGluT2 <- topTreat(PAG_limma_set_treat_fit, coef=1, n=Inf)
head(VGAT_vs_VGluT2)
```

### 7.3.6 | Useful graphical representations of differential expression results
To summarise results for all genes visually, mean-difference plots, which display log-FCs from the linear model fit against the average log-CPM values can be generated using the `plotMD` function, with the differentially expressed genes highlighted.
```{r}
plotMD(PAG_limma_set_treat_fit, column=1, 
       status=PAG_limma_set_treat_fit_dt[,1], 
       main=colnames(PAG_limma_set_treat_fit)[1], 
       xlim=c(-8,13))
```

`Glimma` extends this functionality by providing an interactive mean-difference plot via the `glMDPlot` function. The output of this function is an html page, with summarised results in the left panel (similar to what is output by `plotMD`), and the log-CPM values from individual samples for a selected gene in the right panel, with a table of results below the plots. This interactive display allows the user to search for particular genes based on the annotation provided (e.g. Gene symbol identifier), which is not possible in a static R plot.
```{r}
glMDPlot(PAG_limma_set_treat_fit, coef=1, 
         status=PAG_limma_set_treat_fit_dt,
         main=colnames(PAG_limma_set_treat_fit)[1],
         side.main="ENTREZID", counts=lcpm, groups=group, launch=FALSE)
```

Heatmaps allow users to look at the expression of a subset of genes. This can give useful insight into the expression of individual groups and samples without losing perspective of the overall study when focusing on individual genes, or losing resolution when examining patterns averaged over thousands of genes at the same time. We can create a heatmap for the top 100 DE genes (as ranked by adjusted p-value) with the `heatmap.2` function from the _gplots_ package. 
```{r}
library(gplots)

VGAT_vs_VGluT2_topgenes <- VGAT_vs_VGluT2$ENTREZID[1:100]
i <- which(PAG_limma_set_voom$genes$ENTREZID %in% VGAT_vs_VGluT2_topgenes)

mycolors <- colorpanel(1000,"blue","white","red")

heatmap.2(lcpm[i,], scale="row",
          labRow=PAG_limma_set_voom$genes$SYMBOL[i], labCol=cell.type, 
          col=mycolors, trace="none", density.info="none", 
          margin=c(8,6), lhei=c(2,10), dendrogram="column")
```

## Step 7.4 | MAST
MAST is an R/Bioconductor package for managing and analyzing qPCR and sequencing-based single-cell gene expression data, as well as data from other types of single-cell assays. Apart from reading and storing single-cell assay data, the package also provides functionality for significance testing of differential expression using a Hurdle model, gene set enrichment, facilities for visualizing patterns in residuals indicative of differential expression, and power calculations.

MAST is based on a zero-inflated negative binomial model. It tests for differential expression using a Hurdle model to combine tests of discrete (0 vs not zero) and continuous (non-zero values) aspects of gene expression. Similar to `DESeq2` and `edgeR`, it uses a linear modelling framework to enable complex models to be considered.

We can directly convert our `SingleCellExperiment` object to the `SingleCellAssay` that `MAST` uses:
```{r}
library(MAST)
PAG_MAST_sca = SceToSingleCellAssay(PAG_sceset_qc_norm_filt_corr_clust)
# or: sca <- FromMatrix(assays(sce)$logcounts, colData(sce), rowData(sce))
options(mc.cores = 10) # For parallelisation. You can check how many cores you have available with detectCores()
```

### 7.4.1 | Significance testing under the Hurdle model
Once we are satisfied that we have high-quality expression (i.e. after QC), we will consider tests for differential expression and ways to visualize results. It is often helpful to synthesize from gene-level into module-level statements, so we will use MAST to also test for gene set enrichment.

There are two frameworks available in the package. The first framework `zlm` offers a full linear model to allow arbitrary comparisons and adjustment for covariates. The second framework `LRT` can be considered essentially performing t-tests (respecting the discrete/continuous nature of the data) between pairs of groups. `LRT` is subsumed by the first framework, but might be simpler for some users, so has been kept in the package.

For each gene, `MAST` will fit a Hurdle model with a separate intercept for each factor added to the model. An S4 object of class `ZlmFit` is returned, containing slots with the `genewise` coefficients, variance-covariance matrices, etc.
```{r}
# Model expression as function of condition & number of detected genes
start_time <- Sys.time() # Takes around 10 minutes
PAG_zlm <- zlm(~ mouse.sex + batch.processing + batch.sequencing_round + celltype_PAGarea, 
               sca = PAG_MAST_sca, parallel = TRUE)
end_time <- Sys.time()
end_time - start_time
```

We could run a likelihood ratio test here, testing for differences when we drop the `celltype_PAGarea` factor. Note that any arbitrary contrast matrix can be tested here, and specified either using a matrix or syntactically (see `Hypothesis` for details).
```{r}
#only test the condition coefficient.
PAG_zlm_summary <- summary(PAG_zlm, doLRT='conditionStim') 
#print the top 4 genes by contrast using the logFC
print(PAG_zlm_summary, n=4)
```

_But often of more general use is this delicious syntactic sugar to make a giant `data.table` containing coefficients, standard errors, etc, for the various model components. Many Bothan spies died so that we could pretty-print this summary of the top differentially expressed genes._
```{r}
PAG_zlm_summary_DT <- PAG_zlm_summary$datatable
fcHurdle <- merge(PAG_zlm_summary_DT[contrast=='conditionStim' & component=='H',.(primerid, `Pr(>Chisq)`)], #hurdle P values
                  PAG_zlm_summary_DT[contrast=='conditionStim' & component=='logFC', .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients

fcHurdle[,fdr:=p.adjust(`Pr(>Chisq)`, 'fdr')]
fcHurdleSig <- merge(fcHurdle[fdr<.05 & abs(coef)>FCTHRESHOLD], as.data.table(mcols(PAG_MAST_sca)), by='primerid')
setorder(fcHurdleSig, fdr)
```

#### Visualisation of 50 most differentially expressed genes
```{r}
entrez_to_plot <- fcHurdleSig[1:50,primerid]
symbols_to_plot <- fcHurdleSig[1:50,symbolid]
flat_dat <- as(PAG_MAST_sca[entrez_to_plot,], 'data.table')
ggbase <- ggplot(flat_dat, aes(x=condition, y=thresh,color=condition)) + geom_jitter()+facet_wrap(~symbolid, scale='free_y')+ggtitle("DE Genes in Activated MAIT Cells")
ggbase+geom_violin() 
```

#### Heatmap based on most DE genes
```{r}
mat_to_plot <- assay(PAG_MAST_sca[entrez_to_plot,])
rownames(mat_to_plot) <- symbols_to_plot
aheatmap(mat_to_plot,annCol=colData(PAG_MAST_sca)[,"condition"],main="DE genes",col=rev(colorRampPalette(colors = brewer.pal(name="PiYG",n=10))(20)))
```

## Step 7.5 | Non-parametric tests
The main argument against using non-parametric tests is that scaling normalization does not adjust for differences in the distributions, which results in incorrect rejection of the null hypothesis in fairly innocuous cases (see Aaron Lun's github: https://github.com/LTLA/SingleCellThoughts/blob/master/workflows/de.Rmd). Also, from _Soneson et al 2018_, the main drawback is that these methods don't allow for complex designs.

### 7.5.1 | Kolmogorov-Smirnov test (non-parametric)
To compare the distributions for each gene in two individuals/groups. The KS-test quantifies the distance between the empirical cummulative distributions of the expression of each gene in each of the two populations. It is sensitive to changes in mean expression and changes in variability. However it assumes data are continuous and may perform poorly when data contains a large number of identical values (eg. zeros). Another issue with the KS-test is that it can be very sensitive for large sample sizes and thus it may end up as significant even though the magnitude of the difference is very small.
```{r}
pValues_KS <- apply(
    norm, 1, function(x) {
        ks.test(
            x[PAG_sceset_qc$cell.type == "VGluT2"], 
            x[PAG_sceset_qc$cell.type == "VGAT"]
        )$p.value
    }
)
# multiple testing correction
pValues_KS <- p.adjust(pValues_KS, method = "fdr")
```

```{r}
# How many of the significant DE genes are detected
significant_DE_genes_KS <- names(pValues_KS)[pValues_KS < 0.05]
length(significant_DE_genes_KS)
```

Often it is informative to vary the threshold and evaluate performance across a range of values. This is then plotted as a receiver-operating-characteristic curve (ROC) and a general accuracy statistic can be calculated as the area under this curve (AUC). The ROCR package facilitates this plotting.

### 7.5.2 | Wilcox/Mann-Whitney-U Test (non-parametric)
The Wilcox-rank-sum test is another non-parametric test, but tests specifically if values in one group are greater/less than the values in the other group. Thus it is often considered a test for difference in median expression between two groups; whereas the KS-test is sensitive to any change in distribution of expression values.
```{r}
pValues_W <- apply(
    norm, 1, function(x) {
        wilcox.test(
            x[PAG_sceset_qc$cell.type == "VGluT2"], 
            x[PAG_sceset_qc$cell.type == "VGAT"]
        )$p.value
    }
)
# multiple testing correction
pValues_W <- p.adjust(pValues_W, method = "fdr")
```

```{r}
#How many of the significant DE genes are detected
significant_DE_genes_W <- names(pValues_W)[pValues_W < 0.05]
length(significant_DE_genes_W)
```
## Step 7.6 | SCDE [not yet implemented]
The `scde` package implements routines for fitting individual error models for single-cell RNA-seq measurements. Briefly, the read counts observed for each gene are modeled using a mixture of a negative binomial (NB) distribution (for the amplified/detected transcripts) and low-level Poisson distribution (for the unobserved or background-level signal of genes that failed to amplify or were not detected for other reasons). These models can then be used to identify robustly differentially expressed genes between groups of cells.

Website: http://hms-dbmi.github.io/scde/

### 7.6.1 | Preparing the data
The analysis starts with a matrix of read counts (the values must be integers). We first need to define the two groups we are going to compare:
```{r}
library(scde)
# load example dataset
data(es.mef.small)

# factor determining cell types
sg <- factor(gsub("(MEF|ESC).*", "\\1", colnames(es.mef.small)), levels = c("ESC", "MEF"))
# the group factor should be named accordingly
names(sg) <- colnames(es.mef.small)  
table(sg)

# clean up the dataset
cd <- clean.counts(es.mef.small, min.lib.size=1000, min.reads = 1, min.detected = 1)
```

### 7.6.2 | Fitting error models
As a next step we fit the error models on which all subsequent calculations will rely. The fitting process relies on a subset of robust genes that are detected in multiple cross-cell comparisons. Here we supply the groups = sg argument, so that the error models for the two cell types are fit independently (using two different sets of "robust" genes). If the groups argument is omitted, the models will be fit using a common set.

Note this step takes a considerable amount of time unless multiple cores are used.
```{r}

```

## Step 7.7 | BPSC [not yet implemented]
BPSC uses the Poisson-Beta model of single-cell gene expression, which we discussed in the previous chapter, and combines it with generalized linear models which we’ve already encountered when using edgeR. BPSC performs comparisons of one or more groups to a reference group (“control”) and can include other factors such as batches in the model.

# STEP 9 | Gene Set Enrichment Analysis
Gene set enrichment analysis is a popular approach for prioritising the biological processes perturbed in genomic datasets. It allows researchers to efficiently extract biological insights from long lists of differentially expressed genes by interrogating them at a systems level. The Bioconductor project hosts over 80 software packages capable of gene set analysis. Most of these packages search for enriched signatures amongst differentially regulated genes to reveal higher level biological themes that may be missed when focusing only on evidence from individual genes. 

* Gene Ontology (GO) is a controlled vocabulary to assign the following to a gene: Biological Processes, Cellular Components, Molecular Functions.

* Gene set enrichment analysis allows for a more comprehensive investigation of the function of the markers genes previously identified, and can be performed using `kegga` or `goana` from _limma_.

## Step 9.0 | Cell type annotation [from OSCA]
The most challenging task in scRNA-seq data analysis is arguably the interpretation of the results. Obtaining clusters of cells is fairly straightforward, but it is more difficult to determine what biological state is represented by each of those clusters. Doing so requires us to bridge the gap between the current dataset and prior biological knowledge, and the latter is not always available in a consistent and quantitative manner. Indeed, even the concept of a “cell type” is not clearly defined, with most practitioners possessing a “I’ll know it when I see it” intuition that is not amenable to computational analysis. As such, interpretation of scRNA-seq data is often manual and a common bottleneck in the analysis workflow.

To expedite this step, we can use various computational approaches that exploit prior information to assign meaning to an uncharacterized scRNA-seq dataset. The most obvious sources of prior information are the curated gene sets associated with particular biological processes, e.g., from the Gene Ontology (GO) or the Kyoto Encyclopedia of Genes and Genomes (KEGG) collections. Alternatively, we can directly compare our expression profiles to published reference datasets where each sample or cell has already been annotated with its putative biological state by domain experts. Here, we will demonstrate both approaches with several different scRNA-seq datasets.

### Assigning cell labels from reference data
A conceptually straightforward annotation approach is to compare the single-cell expression profiles with previously annotated reference datasets. Labels can then be assigned to each cell in our uncharacterized test dataset based on the most similar reference sample(s), for some definition of “similar”. This is a standard classification challenge that can be tackled by standard machine learning techniques such as random forests and support vector machines. Any published and labelled RNA-seq dataset (bulk or single-cell) can be used as a reference, though its reliability depends greatly on the expertise of the original authors who assigned the labels in the first place.

In this section, we will demonstrate the use of the `SingleR` method (Aran et al. 2019) for cell type annotation. This method assigns labels to cells based on the reference samples with the highest Spearman rank correlations, and thus can be considered a rank-based variant of k-nearest-neighbor classification. To reduce noise, `SingleR` identifies marker genes between pairs of labels and computes the correlation using only those markers. It also performs a fine-tuning step for each cell where calculation of the correlations is repeated with just the marker genes for the top-scoring labels. This aims to resolve any ambiguity between those labels by removing noise from irrelevant markers for other labels.

`SingleR` contains a number of built-in reference datasets, mostly assembled from bulk RNA-seq or microarray data of sorted cell types. These built-in references are often good enough for most applications, provided that they contain the cell types that are expected in the test population. We label our dataset using the `SingleR()` function with the main cell type labels in the reference. This returns a `DataFrame` where each row corresponds to a cell in the test dataset and contains its label assignments. Alternatively, we could use the labels in `ref$label.fine`, which provide more resolution at the cost of speed and increased ambiguity in the assignments.
```{r}
library(SingleR)
ref <- BlueprintEncodeData()
pred <- SingleR(test=sce.pbmc, ref=ref, labels=ref$label.main)
table(pred$labels)
```

We inspect the results using a heatmap of the per-cell and label scores. Ideally, each cell should exhibit a high score in one label relative to all of the others, indicating that the assignment to that label was unambiguous. 
```{r}
plotScoreHeatmap(pred)
```

`SingleR()` will attempt to prune out low-quality assignments by marking them as `NA`. This is done based on the difference _Δmed_ of the assigned label’s score from the median score within each cell. Small _Δmed_ values indicate that the cell assignment was so uncertain that the reported label is not much better than the bulk of other labels in the reference. We set a minimum threshold on the acceptable _Δmed_ using an outlier-based approach for each label, where labels with _Δmed_ that are substantially lower than the majority of values for a given label are marked as `NA`. If necessary, more control over the pruning can be achieved by supplying custom parameters to the `pruneScores()` function.
```{r}
sum(is.na(pred$pruned.labels))
plotScoreDistribution(pred)

```

We compare the assignments with the clustering results to determine the identity of each cluster. Ideally, clusters and labels would have a 1:1 relationship, though some nesting is likely depending on the resolution of the clustering algorithm.
```{r}
tab <- table(Assigned=pred$pruned.labels, Cluster=sce.pbmc$cluster)

# Adding a pseudo-count of 10 to avoid strong color jumps with just 1 cell.
library(pheatmap)
pheatmap(log2(tab+10), color=colorRampPalette(c("white", "blue"))(101))
```

This episode highlights some of the differences between reference-based annotation and unsupervised clustering. The former explicitly focuses on aspects of the data that are known to be interesting, simplifying the process of biological interpretation. However, the cost is that the downstream analysis is restricted by the diversity and resolution of the available labels. We suggest applying both strategies and, if major disagreements are present between reference label and cluster assignments, using those discrepancies as the basis for further investigation to discover novel effects.

### Assigning cluster labels from markers
Yet another strategy for annotation is to perform a gene set enrichment analysis on the marker genes defining each cluster. This identifies the pathways and processes that are (relatively) active in each cluster based on upregulation of the associated genes compared to other clusters. We demonstrate on the mouse mammary dataset from Bach et al. (2017), using markers that are identified by `findMarkers()` as being upregulated at a log-fold change threshold of 1.

We can use gene sets defined by the Gene Ontology (GO) project, which describe a comprehensive range of biological processes and functions. We define our subset of relevant marker genes at a FDR of 5% and apply the `goana()` function from the `limma` package. This performs a hypergeometric test to identify GO terms that are overrepresented in our marker subset. (The log-fold change threshold mentioned above is useful here, as it avoids including an excessive number of genes from the overpowered nature of per-cell DE comparisons.)
```{r}
markers.mam <- findMarkers(sce.mam, sce.mam$cluster, direction="up", lfc=1)

chosen <- "2"
cur.markers <- markers.mam[[chosen]]
is.de <- cur.markers$FDR <= 0.05 
summary(is.de)

# goana() requires Entrez IDs, some of which map to multiple
# symbols - hence the unique() in the call below.
library(org.Mm.eg.db)
entrez.ids <- mapIds(org.Mm.eg.db, keys=rownames(cur.markers), 
    column="ENTREZID", keytype="SYMBOL")

library(limma)
go.out <- goana(unique(entrez.ids[is.de]), species="Mm", 
    universe=unique(entrez.ids))

# Only keeping biological process terms that are not overly general.
go.out <- go.out[order(go.out$P.DE),]
go.useful <- go.out[go.out$Ont=="BP" & go.out$N <= 200,]
head(go.useful, 20)

plotExpression(sce.mam, features=c("Csn2", "Csn3"), x="cluster", colour_by="cluster")
```

Further inspection of interesting GO terms is achieved by extracting the relevant genes. This is usually desirable to confirm that the interpretation of the annotated biological process is appropriate. Many terms have overlapping gene sets, so a term may only be highly ranked because it shares genes with a more relevant term that represents the active pathway.
```{r}
# Extract symbols for each GO term; done once.
tab <- select(org.Mm.eg.db, keytype="SYMBOL", 
    keys=rownames(sce.mam), columns="GOALL")
by.go <- split(tab[,1], tab[,2])

# Identify genes associated with an interesting term.
adhesion <- unique(by.go[["GO:0022408"]])
head(cur.markers[rownames(cur.markers) %in% adhesion,1:4], 10)
```

Gene set testing of marker lists is a reliable approach for determining if pathways are up- or down-regulated between clusters. As the top marker genes are simply DEGs, we can directly apply well-established procedures for testing gene enrichment in DEG lists (see https://bioconductor.org/packages/release/BiocViews.html#___GeneSetEnrichment for relevant packages). This contrasts with the AUCell approach where scores are not easily comparable across cells. The downside is that all conclusions are made relative to the other clusters, making it more difficult to determine cell identity if an “outgroup” is not present in the same study.

## Step 9.1 | EGSEA: Easy and efficient ensemble gene set testing
_The following was created following the [EGSEA123 workflow](https://bioconductor.org/packages/release/workflows/html/EGSEA123.html)._

EGSEA, which stands for Ensemble of Gene Set Enrichment Analyses (Alhamdoosh et al. 2017) combines the results from multiple gene set testing algorithms to arrive at a consensus gene set ranking to identify biological themes and pathways perturbed in an experiment. EGSEA can extend limma-based differential expression analyses for RNA-seq and microarray data. Following data normalization and set-up of an appropriate linear model for differential expression analysis, EGSEA builds gene signature specific indexes that link a wide range of mouse or human gene set collections to the gene expression data being investigated. EGSEA is then configured and the ensemble enrichment analysis run, returning an object that can be queried using several S4 methods for ranking gene sets and visualizing results via heatmaps, KEGG pathway views, GO graphs, scatter plots and bar plots. Finally, an HTML report that combines these displays can fast-track the sharing of results with collaborators, and thus expedite downstream biological validation. 

We follow from the results obtained with the RNAseq123 Workflow from the previous step _(Step 10.4 | RNAseq123 Workflow)_. The EGSEA algorithm makes use of the voom object (`PAG_limma_set_voom`), a design matrix (`PAG_limma_design`) and an optional contrasts matrix (`PAG_limma_contrasts_matrix`). The design matrix describes how the samples in the experiment relate to the coefficients estimated by the linear model (Smyth 2004). The contrasts matrix then compares two or more of these coefficients to allow relative assessment of differential expression.
```{r}
PAG_limma_set_voom
PAG_limma_design
PAG_limma_contrasts_matrix
```

### 9.1.1 | Exploring, selecting and indexing gene set collections
The package `EGSEAdata` includes more than 25,000 gene sets organized in collections depending on their database sources. EGSEA uses Entrez Gene identifiers and alternate gene identifiers must be first converted into Entrez IDs. Summary information about the gene set collections available in EGSEAdata can be displayed as follows:
```{r}
library(EGSEAdata)
egsea.data("mouse")
```

We can obtain help on any of the collections using the standard R help (`?`) command, for instance `?Mm.c2` will return more information on the mouse version of the `c2` collection from `MSigDB`. The above information can be returned as a list:
```{r}
info = egsea.data("mouse", returnInfo = TRUE)
names(info)
info$msigdb$info$collections
```

This information will be useful to select the collections we are interested in using. Once we have made our choice, we build an index for each gene set collection using the EGSEA indexing functions to link the genes in the different gene set collections to the rows of our RNA-seq gene expression matrix.

The _EGSEA_ package has four indexing functions that utilize the gene set collections of _EGSEAdata_. They map the Entrez gene IDs of the input dataset into the gene sets of each collection and create an index for each collection. These fucntions also extract annotation information from EGSEAdata for each gene set to be displayed within the EGSEA HTML report. These functions are as follow:

* `buildKEGGIdx` builds an index for the _KEGG_ pathways collection and loads gene set annotation.
* `buildMSigDBIdx` builds indexes for the _MSigDB_ gene set collections and loads gene set annotation.
* `buildGeneSetDBIdx` builds indexes for the _GeneSetDB_ collections and loads gene set annotation.
* `buildIdx` is one-step method to build indexes for collections selected from the _KEGG_, _MSigDB_ and _GeneSetDB_ databases.

These four functions take a vector of Entrez Gene IDs and the species name and return an object (or list of objects) of class `GSCollectionIndex`. To use the` GSCollectionIndex` objects with the other _EGSEA_ functions, the order of input ids vector should match that of the row names of the count matrix or the `voom` object.

* In the EGSEA123 workflow, the KEGG pathways, c2 (curated gene sets) and c5 (Gene Ontology gene sets) collections from the MSigDB database are selected to highlight the capabilities of the EGSEA package. Indexes for the c2 and c5 collections from MSigDB and for the KEGG pathways are built using the `buildIdx` function which relies on Entrez gene IDs as its key. In the EGSEAdata gene set collections, Entrez IDs are used as they are widely adopted by the different source databases and tend to be more consistent and robust since there is one identifier per gene in a gene set. It is also relatively easy to convert other gene IDs into Entrez IDs.
```{r}
library(EGSEA)
gs_annots = buildIdx(entrezIDs=PAG_limma_set_voom$genes$ENTREZID, 
                     species="mouse", 
                     msigdb.gsets=c("c2", "c5"), go.part = TRUE)
names(gs_annots)

# To run the EGSEA analysis with all the gene set collections that are avilable in the EGSEAdata package, use the buildIdx function to create the gene set indexes as follows:
# gs_annots = buildIdx(entrezIDs = rownames(v$E), species = "mouse", gsdb.gsets = "all")
# names(gs_annots)
```

To obtain additional information on the gene set collection indexes, including the total number of gene sets, the version number and date of last revision, the methods `summary`, `show` and `getSetByName` (or `getSetByID`) can be invoked on an object of class `GSCollectionIndex`, which stores all of the relevant gene set information, as follows:
```{r}
class(gs_annots$c2)
summary(gs_annots$c2)
show(gs_annots$c2)

s = getSetByName(gs_annots$c2, "SMID_BREAST_CANCER_LUMINAL_A_DN")
class(s)
names(s)
names(s$SMID_BREAST_CANCER_LUMINAL_A_DN)
```

Objects of class `GSCollectionIndex` store for each gene set the Entrez gene IDs in the slot original, the indexes in the slot `idx` and additional annotation for each set in the slot `anno`.
```{r}
slotNames(gs_annots$c2)
```

Other EGSEA functions such as `buildCustomIdx`, `buildGMTIdx`, `buildKEGGIdx`, `buildMSigDBIdx` and `buildGeneSetDBIdx` can be also used to build gene set collection indexes. The functions `buildCustomIdx` and `buildGMTIdx` were written to allow users to run EGSEA on gene set collections that may have been curated within a lab or downloaded from public databases and allow use of gene identifiers other than Entrez IDs. Example databases include, ENCODE Gene Set Hub (available from https://sourceforge.net/projects/encodegenesethub/), which is a growing resource of gene sets derived from high quality ENCODE profiling experiments encompassing hundreds of DNase hypersensitivity, histone modification and transcription factor binding experiments (Ziemann et al. 2017). Other resources include `PathwayCommons` (http://www.pathwaycommons.org/) (Cerami et al. 2011) or the `KEGGREST` (Tenenbaum 2017) package that provides access to up-to-date KEGG pathways across many species.

### 9.1.2 | Configuring EGSEA
Before an EGSEA test is carried out, a few parameters need to be specified. First, a mapping between Entrez IDs and Gene Symbols is created for use by the visualization procedures. This mapping can be extracted from the `genes` _data.frame_ of the `voom` object as follows:
```{r}
colnames(PAG_limma_set_voom$genes)
symbolsMap = PAG_limma_set_voom$genes[, c(1, 2)]
colnames(symbolsMap) = c("FeatureID", "Symbols")
symbolsMap[, "Symbols"] = as.character(symbolsMap[, "Symbols"])
```

Another important parameter in EGSEA is the list of base GSE methods (`baseMethods` in the code below), which determines the individual algorithms that are used in the ensemble testing. The supported base methods can be listed using the function  egsea.base as follows:
```{r}
egsea.base()
```

The _plage_, _zscore_ and _ssgsea_ algorithms are available in the GSVA package and _camera_, _fry_ and _roast_ are implemented in the `limma` package (Ritchie et al. 2015). The _ora_ method is implemented using the `phyper` function from the `stats` package (R Core Team 2017), which estimates the hypergeometric distribution for a 2x2 contingency table. The remaining algorithms are implemented in Bioconductor packages of the same name. A wrapper function is provided for each individual GSE method to utilize this existing R code and create a universal interface for all methods.

We next select the base methods of the EGSEA analysis. In the workflow, eleven base methods are selected for our EGSEA analysis: _camera, safe, gage, padog, plage, zscore, gsva, ssgsea, globaltest, ora_ and _fry_. _Fry_ is a fast approximation of _roast_ that assumes equal gene-wise variances across samples to produce similar p-values to a _roast_ analysis run with an infinite number of rotations, and is selected here to save time.
```{r}
baseMethods = egsea.base()[-2] # try this? [-c(2, 12)]
baseMethods
```

Although, different combinations of base methods might produce different results, it has been found via simulation that including more methods gives better performance (Alhamdoosh et al. 2017).

Since each base method generates different p-values, EGSEA supports six different methods from the `metap` package (Dewey 2017) for combining individual p-values (`Wilkinson` (Wilkinson 1954) is default), which can be listed as follows:
```{r}
egsea.combine()
```

Finally, the sorting of EGSEA results plays an essential role in identifying relevant gene sets. Any of EGSEA's combined scores or the rankings from individual base methods can be used for sorting the results. The possible values of this argument can be seen as follows:
```{r}
egsea.sort()
```

Although `p.adj` is the default option for sorting EGSEA results for convenience, we recommend the use of either `med.rank` or `vote.rank` because they efficiently utilize the rankings of individual methods and tend to produce fewer false positives (Alhamdoosh et al. 2017).

### 9.1.3 | Ensemble testing with EGSEA
We next perform the EGSEA analysis by using the `egsea` function:
```{r}
# set report = TRUE and add report.dir = "./il13-egsea-report" to generate HTML report
# set display.top = 20 to display more gene sets. It takes longer time to run.

gsa = egsea(voom.results=PAG_limma_set_voom, 
            contrasts=PAG_limma_contrasts_matrix, 
            gs.annots=gs_annots, symbolsMap=symbolsMap,
            baseGSEAs=baseMethods, sort.by="med.rank",
            num.threads = 2, report = FALSE)
```

In situations where the design matrix includes an intercept, a vector of integers that specify the columns of the design matrix to test using EGSEA can be passed to the contrasts argument. If this parameter is NULL, all pairwise comparisons based on `PAG_limma_set_voom$targets$group` are created, assuming that `group` is the primary factor in the design matrix. Likewise, all the coefficients of the primary factor are used if the design matrix has an intercept.

EGSEA is implemented with parallel computing features enabled using the `parallel` package (R Core Team 2017) at both the method-level and experimental contrast-level. The running time of the EGSEA test depends on the base methods selected and whether report generation is enabled or not. The latter significantly increases the run time, particularly if the argument `display.top` is assigned a large value (> 20) and/or a large number of gene set collections are selected. EGSEA reporting functionality generates set-level plots for the top gene sets as well as collection-level plots.

The EGSEA package also has a function named `egsea.cnt`, that can perform the EGSEA test using an RNA-seq count matrix rather than a voom object, a function named `egsea.ora`, that can perform over-representation analysis with EGSEA reporting capabilities using only a vector of gene IDs, and the `egsea.ma` function that can perform EGSEA testing using a microarray expression matrix.

The output of the functions `egsea`, `egsea.cnt`, `egsea.ora` and `egsea.ma` is an S4 object of class `EGSEAResults`. Several S4 methods can be invoked to query this object. For example, an overview of the EGSEA analysis can be displayed using the `show` method, which displays the number of genes and samples that were included in the analysis, the experimental contrasts, base GSE methods, the method used to combine the p-values derived from different GSE algorithms, the sorting statistic used and the size of each gene set collection. Note that the gene set collections are identified using the labels that appear in parentheses (e.g. c2) in the output of _show_.
```{r}
show(gsa)
```

### 9.1.4 | Reporting EGSEA results
A summary of the top 10 gene sets in each collection for each contrast in addition to the EGSEA comparative analysis can be displayed using the S4 method `summary`:
```{r}
summary(gsa)
```

EGSEA's comparative analysis allows researchers to estimate the significance of a gene set across multiple experimental contrasts. This analysis helps in the identification of biological processes that are perturbed in multiple experimental conditions simultaneously.

Another way of exploring the EGSEA results is to retrieve the top ranked N sets in each collection and contrast using the method `topSets`. For example, the top 10 gene sets in the c2 collection for the comparative analysis can be retrieved as follows:
```{r}
topSets(gsa, gs.label="c2", contrast = "comparison", names.only=TRUE)
```

The gene sets are ordered based on their `med.rank` score as selected when `egsea` was invoked above. When the argument `names.only` is set to `FALSE`, additional information is displayed for each gene set including gene set annotation, the EGSEA scores and the individual rankings by each base method.

`topSets` can be used to search for gene sets of interest based on different EGSEA scores as well as the rankings of individual methods. 
```{r}
t = topSets(gsa, contrast = "comparison",
            names.only=FALSE, number = Inf, verbose = FALSE) # number = 10 for top 10 gene sets

t[grep("LIM_", rownames(t)), c("p.adj", "Rank", "med.rank", "vote.rank")] 
# Replace "LIM_" for your gene set of interst
```

Similarly, we can find the top 10 pathways in the _KEGG_ collection from the ensemble analysis for a particular comparison and the comparative analysis as follows:
```{r}
topSets(gsa, gs.label="kegg", contrast="BasalvsLP", sort.by="med.rank")
topSets(gsa, gs.label="kegg", contrast="comparison", sort.by="med.rank")
```

### 9.1.5 | Visualizing results at the gene set level
When using `plotHeatmap`, the `gene.set` value must match the name returned from the `topSets` method. The rows of the heatmap represent the genes in the set and the columns represent the experimental contrasts. The heatmap colour-scale ranges from down-regulated (blue) to up-regulated (red) while the row labels (Gene symbols) are coloured in green when the genes are statistically significant in the DE analysis (i.e. FDR <= 0.05 in at least one contrast). Heatmaps can be generated for individual comparisons by changing the contrast argument of `plotHeatmap`. The `plotHeatmap` method also generates a CSV file that includes the DE analysis results from `limma::topTable` for all expressed genes in the selected gene set and for each contrast (in the case of  contrast = "comparison").
```{r}
plotHeatmap(gsa, gene.set="LIM_MAMMARY_STEM_CELL_UP", gs.label="c2",
            contrast = "comparison", file.name = "hm_cmp_LIM_MAMMARY_STEM_CELL_UP", format="png")
plotHeatmap(gsa, gene.set="LIM_MAMMARY_STEM_CELL_DN", gs.label="c2",
            contrast = "comparison", file.name = "hm_cmp_LIM_MAMMARY_STEM_CELL_DN", format="png")
```

In addition to heatmaps, pathway maps can be generated for the KEGG gene sets using the `plotPathway` method which uses functionality from the `pathview` package (Luo and Brouwer 2013). Pathway components are coloured based on the gene-specific log-fold-changes as calculated in the limma DE analysis.
```{r}
plotPathway(gsa, gene.set = "Vascular smooth muscle contraction", 
            contrast = "BasalvsLP", gs.label = "kegg", 
            file.name = "Vascular_smooth_muscle_contraction")

plotPathway(gsa, gene.set = "Vascular smooth muscle contraction", 
            contrast = "comparison", gs.label = "kegg", 
            file.name = "Vascular_smooth_muscle_contraction_cmp")
```

### 9.1.6 | Visualizing results at the experiment level
Since EGSEA combines the results from multiple gene set testing methods, it can be interesting to compare how different base methods rank a given gene set collection for a selected contrast. The `plotMethods` command generates a multi-dimensional scaling (MDS) plot for the ranking of gene sets across all the base methods used. Methods that rank gene sets similarly will appear closer together in this plot and we see that certain methods consistently cluster together across different gene set collections. The clustering of methods does not necessarily follow the style of null hypothesis tested though (i.e. self-contained versus competitive).
```{r}
plotMethods(gsa, gs.label = "c2", contrast = "BasalvsLP", 
            file.name = "mds_c2_BasalvsLP", format="png")
plotMethods(gsa, gs.label = "c5BP", contrast = "BasalvsLP", 
            file.name = "mds_c5_BasalvsLP", format="png")
```

The significance of each gene set in a given collection for a selected contrast can be visualized using EGSEA's `plotSummary` method. The summary plot visualizes the gene sets as bubbles based on the -log10(p-value) (X-axis) and the average absolute log fold-change of the set genes (Y-axis). The sets that appear towards the top-right corner of this plot are most likely to be biologically relevant. EGSEA generates two types of summary plots: the directional summary plot, which colours the bubbles based on the regulation direction of the gene set (the direction of the majority of genes), and the ranking summary plot, which colours the bubbles based on the gene set ranking in a given collection (according to the `sort.by` argument). The bubble size is based on the EGSEA significance score in the former plot and the gene set size in the latter. The blue colour labels on the ranking plot represents gene sets that do not appear in the top 10 gene sets that are selected based on the `sort.by` argument while their EGSEA significance scores are among the top 5 in the entire collection. This is used to identify gene sets with high significance scores that were not captured by the `sort.by` score. The gene set IDs and more information about each set can be found in the EGSEA HTML report generated later.
```{r}
plotSummary(gsa, gs.label = 3, contrast = 3, 
            file.name = "summary_kegg_LPvsML", format="png")
```

By default, `plotSummary` uses a gene set's `p.adj` score for the X-axis. This behaviour can be easily modified by assigning any of the available `sort.by` scores into the parameter `x.axis`, for example, `med.rank` can be used to create an EGSEA summary plot:
```{r}
plotSummary(gsa, gs.label = 1, contrast = 3, 
            file.name = "summary_c2_LPvsML", 
            x.axis = "med.rank", format="png")
```

The summary plot tends to become very cluttered when the size of the gene set collection is very large. The parameter `x.cutoff` can be used to focus in on the significant gene sets rather than plotting the entire gene set collection,:
```{r}
plotSummary(gsa, gs.label = 1, contrast = 3, 
            file.name = "summary_sig_c2_LPvsML", 
            x.axis = "med.rank", x.cutoff=300, format="png")
```

Comparative summary plots can be also generated to compare the significance of gene sets between two contrasts:
```{r}
plotSummary(gsa, gs.label = "kegg", contrast = c(1,2), 
            file.name = "summary_kegg_1vs2", format="png")
```

The `plotSummary` method has two useful parameters: (i) `use.names` that can be used to display gene set names instead of gene set IDs and (ii) `interactive` that can be used to generate an interactive version of this plot.

The c5 collection of `MSigDB` and the Gene Ontology collection of `GeneSetDB` contain Gene Ontology (GO) terms. These collections are meant to be non-redundant, containing only a small subset of the entire GO and visualizing how these terms are related to each other can be informative. EGSEA utilizes functionality from the `topGO` package (Alexa and Rahnenfuhrer 2016) to generate GO graphs for the significant biological processes (BPs), cellular compartments (CCs) and molecular functions (MFs). The `plotGOGraph` method can generate such a display as follows:
```{r}
plotGOGraph(gsa, gs.label="c5BP", contrast = 1, file.name="BasalvsLP-c5BP-top-", format="png")
plotGOGraph(gsa, gs.label="c5CC", contrast = 1, file.name="BasalvsLP-c5CC-top-", format="png")
```

The GO graphs are coloured based on the values of the argument `sort.by`, which in this instance was taken as `med.rank` by default since this was selected when EGSEA was invoked. The top five most significant GO terms are highlighted by default in each GO category (MF, CC or BP). More terms can be displayed by changing the value of the parameter `noSig`. However, this might generate very complicated and unresolved graphs. The colour of the nodes vary between red (most significant) and yellow (least significant). The values of the `sort.by` scoring function are scaled between 0 and 1 to generate these graphs.

Another way to visualize results at the experiment level is via a summary bar plot. The method `plotBars` can be used to generate a bar plot for the top N gene sets in an individual collection for a particular contrast or from a comparative analysis across multiple contrasts.
```{r}
plotBars(gsa, gs.label = "c2", contrast="comparison", file.name="comparison-c2-bars", format="png")
```

The colour of each bar is based on the regulation direction of the gene sets, i.e., red for up-regulated, blue for down-regulated and purple for neutral regulation (in the case of comparative analysis of experimental contrasts that have show opposite behaviours). By default, the -log10(p.adj) values are plotted for the top 20 gene sets selected and ordered based on the `sort.by` parameter. The parameters `bar.vals`, `number` and `sort.by` of `plotBars` can be changed to customize the bar plot.

When changes over multiple conditions are of interest, a summary heatmap can be a useful visualization. The method `plotSummaryHeatmaps` generates a heatmap of the top N gene sets in the comparative analysis across all experimental conditions. By default, 20 gene sets are selected based on the `sort.by` parameter and the values plotted are the average log-fold changes at the set level for the genes regulated in the same direction as the set regulation direction, i.e. `avg.logfc.dir`. The parameters `number`, `sort.by` and `hm.vals` of the `plotSummaryHeatmaps` can be used to customize the summary heatmap. Additionally, the parameter `show.vals` can be used to display the values of a specific EGSEA score on the heatmap cells. 
```{r}
plotSummaryHeatmap(gsa, gs.label="c2", hm.vals = "avg.logfc.dir",
                   file.name="summary_heatmaps_c2", format="png")
plotSummaryHeatmap(gsa, gs.label="kegg", hm.vals = "avg.logfc.dir",
                   file.name="summary_heatmaps_kegg", format="png")
```

The heatmap view at both the gene set and summary level and the summary level bar plots are useful summaries to include in publications to highlight the gene set testing results. The top differentially expressed genes from each contrast can be accessed from the `EGSEAResults` object using the `limmaTopTable` method.
```{r}
t = limmaTopTable(gsa, contrast=1)
head(t)
```

### 9.1.7 | Creating an HTML report of the results
To generate an EGSEA HTML report you can either set `report=TRUE` when you invoke `egsea` or use the S4 method `generateReport` as follows:
```{r}
generateReport(gsa, number = 20, report.dir="./mam-rnaseq-egsea-report")
```

The HTML report is a convenient means of organising all of the results generated up to now, from the individual tables to the gene set level heatmap, pathway maps and summary level plots. It can easily be shared with collaborators to allow them to explore their results more fully. Interactive tables of results via the `DT` package (https://CRAN.R-project.org/package=DT) and summary plots from `plotly` (https://CRAN.R-project.org/package=plotly) are integrated into the report using `htmlwidgets` (https://CRAN.R-project.org/package=htmlwidgets) and can be added by setting `interactive = TRUE` in the command above. This option significantly increases both the run time and size of the final report due to the large number of gene sets in most collections.

## Step 9.2 | bigSCale 2
[bigSCale2](https://github.com/iaconogi/bigSCale2) is a complete framework for the analysis and visualization of single cell data. It allows to cluster, phenotype, perform pseudotime analysis, infer gene regulatory networks and reduce large datasets in smaller datasets with higher quality.

_bigSCale2_ works with the `SingleCellExperiment` class. This class is a container meant to store in an organized way single cell data. bigScale2 requires two elements to be present in the single cell class: the counts `counts()` and the gene names `rownames()`. The counts must be raw counts, and the genes must not be filtered, aside from removing the genes with all zero values.

### 9.3.1 | Running bigSCale2
```{r}
library(bigSCale)
PAG_bigSCale2 <- SingleCellExperiment(assays = list(counts = as.matrix(PAG_data)))
PAG_bigSCale2
```

bigSCale2 can be run with one single command, and we can set `speed.preset="slow"` for maximum accuracy. Once we've run this, the results are stored in the `SingleCellExperiment` object.
```{r}
PAG_bigSCale2 <- bigscale(PAG_bigSCale2, speed.preset = "slow", clustering = "recursive") 
PAG_bigSCale2 <- bigscale(PAG_bigSCale2, speed.preset = "fast")
# Or run it step by step
# sce=preProcess(sce)
# sce = storeNormalized(sce) # stores normalized data
# sce=setModel(sce) # computes the numerical model
# sce = storeTransformed(sce) # stores transformed expression data (needed for some plots)
# viewModel(sce)
# sce = setODgenes(sce,min_ODscore=2.33) 
# viewODgenes(sce)
# sce=setDistances(sce)
# sce=storeTsne(sce)
# sce=setClusters(sce)
# sce=storePseudo(sce)
# sce=computeMarkers(sce,speed.preset='slow')
# sce=setMarkers(sce,cutoff=3)
# sce=restoreData(sce)
```

### 9.3.2 | Visualising the results
Plot the clusters and signatures of coexpressed genes:

* The dendrogram represents how the cells are phenotypically organized and clustered.
* Colored bars representing the clusters, the library size (meant as a proxy to transcriptome size/complexity) and the pseudotime of the cells. An additional color bar is displayed for any user custom `colData()` (for example, sample batches, conditions and so on ...). For custom user `colData`, the color codes are automatically chosen upen the type of data (numeric or factor).
* The clustered signatures of coexpressed genes alogside their size. Here, all the genes differentially expressed are organized in signatures of co-expressed genes.
```{r}
viewSignatures(PAG_bigSCale2)
```

Inspect the markers of a specific cluster: this plot is the same as before, but instead of the signatures of coexpressed genes we see the markers of the selected cluster stratified by level of specificity (see Iacono et al. 2018). Shortly, markers of level 1 are the most specific to a given cluster (only found in that cluster), whereas level 2 are shared between the chosen cluster and at most another cluster, level 3 are shared between the chosen cluster and at most two other clusters, and so on.
```{r}
viewSignatures(PAG_bigSCale2, selected.cluster=2) 
```

Barplot of selected genes to plot gene expression at single cell level with colored clusters:
```{r}
viewGeneBarPlot(PAG_bigSCale2, gene.list = c('Aqp4','Olig1','Thy1'))
```

Violin plots of a selected gene:
```{r}
viewGeneViolin(PAG_bigSCale2, 'Aqp4')
```

t-SNE and UMAP plots
```{r}
viewReduced(PAG_bigSCale2) # to see t-SNE with clusters
viewReduced(PAG_bigSCale2, color.by = 'Stmn2') # to see t-SNE with gene expression
```
If you want to color the cell according to some custom annotation you can pass a `factor` variable in place of a gene name. If you want to visualize a UMAP plot, first compute the UMAP data with `PAG_bigSCale2 = storeUMAP(PAG_bigSCale2)` and then `viewReduced(PAG_bigSCale2, method = 'UMAP')`.

Browsing markers: To have a look at the markers found by bigSCale2 we retrive `Mlist` from the single cell object. `Mlist` is a 2 dimensional list containing for each cluster the markers of the different levels. Let's inspect the markers of level 1 (most specific) of cluster 4. We will take advantage of the package `DT` for interactive visualization. Running the next command line we will see the markers specific to cluster 4 sorted from the highest (most significant) to the lowest (less significant) Zscore.
```{r}
Mlist = getMarkers(PAG_bigSCale2)
DT::datatable(Mlist[[4,1]]) # Level 1 Markers of cluster 4
DT::datatable(Mlist[[4,5]]) # Level 5 Markers of cluster 4
```

We can also look at co-expressed genes:
```{r}
Signatures = getSignatures(PAG_bigSCale2)
DT::datatable(Signatures[[1]])
```

Superclustering: highly accurate recursive clustering which directly individautes the sub-types of a dataset. It can be activated by using the option `clustering='recursive'` when running bigSCale.

### 9.3.3 | Gene Regulatory Networks
bigSCale2 allows to infer the putative gene regulatory network (GRN) from any single cell dataset. Networks are automatically generated by retaining only the most significant correlations. By default, the parameter `quantile.p=0.998` retains only the top 0.2% correlations. 
```{r}
# define gene.names and subset vgat and vglut2 cells

results.vgat = compute.network(expr.data = PAG_bigSCale2$VGAT, gene.names = gene.names, clustering = 'recursive')
results.vglut2 = compute.network(expr.data = PAG_bigSCale2$VGluT2, gene.names = gene.names, clustering = 'recursive')
```

We can have a look at the networks:
```{r}
results.vgat$graph
results.vglut2$graph
```

bigSCale2 has already calculated the gene (node) centralities and stored them in the output list. Centralities are a measure of the importance of a gene in the regulatory netowork. The following will plot a table with the four centralities for each gene. Genes with high `betweenness` are important information bottlenecks.
```{r}
DT::datatable(results.vgat$centrality)
DT::datatable(results.vgat$correlations) # check the correlations between a gene of interest and the rest of the trancriptome
```

We can also compare changes in node centralities between both conditions. The input of `compare.centrality()` is a list whose elements are the previously calculated centralities. We also provide the complete names of the conditions which will be used to annotate the output. The output of `compare.centrality()` is a list of `data.frames`. Each `data.frame` stores the genes ranked for their change in one given centrality (`degree`, `betweenness`, `closeness`, `pagerank` in order).
```{r}
comparison = compare.centrality(list(results.vgat$centrality, results.vglut2$centrality),
                                c('VGAT','VGluT2'))
DT::datatable(comparison$betweenness)
```

# STEP 10 | Seurat
[Seurat](https://satijalab.org/seurat/) is an R package designed for QC, analysis, and exploration of single-cell RNA-seq data. Seurat aims to enable users to identify and interpret sources of heterogeneity from single-cell transcriptomic measurements, and to integrate diverse types of single-cell data. For more info see Butler et al. 2018 and Stuart, Butler et al. 2018. The following code has been adapted from the [Guided Clustering Tutorial](https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html).

_IMP:_ Before starting this, run "Part I: from a gene expression matrix to a SingleCellExperiment object" again to load the raw data. Seurat uses its own object class, so we need to create a new object with the raw (non-normalised) data. Setting up a Seurat object:
```{r}
library(Seurat)
library(dplyr)
PAG_seurat <- CreateSeuratObject(counts = PAG_data,
                                 project = "PAG_seurat_analysis",
                                 min.cells = 1, # keep genes expressed in more than 1 cell
                                 min.features = 2000, # keep cells with at least 2000 detected genes
                                 meta.data = PAG_metadata)
```

## Step 10.1 | Pre-processing, data QC and normalization
Selection and filtration of cells based on QC metrics, data normalization and scaling, and detection of highly variable features.
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
PAG_seurat[["percent.mt"]] <- PercentageFeatureSet(PAG_seurat, pattern = "^MT-")
PAG_seurat[["percent.ercc"]] <- PercentageFeatureSet(PAG_seurat, pattern = "^ERCC-")
head(PAG_seurat@meta.data, 5) # Metadata for the first 5 cells
```

Visualize QC metrics using a violin plot:
```{r}
VlnPlot(PAG_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ercc"), ncol = 4)
```

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(PAG_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(PAG_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
```

Filter the dataset according to specific quality  metrics:
```{r}
PAG_seurat <- subset(PAG_seurat, subset = nFeature_RNA > 2000 & percent.mt < 5)
```

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method `LogNormalize` that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in `SeuratObject[["RNA"]]@data`.
```{r}
PAG_seurat <- NormalizeData(PAG_seurat, normalization.method = "LogNormalize", scale.factor = 10000)
PAG_seurat <- NormalizeData(PAG_seurat)
```

## Step 10.2 | Feature selection: identify highly variable features
The next step consists on calculating a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. Seurat directly models the mean-variance relationship inherent in single-cell data and implements in in the `FindVariableFeatures` function, returning 2000 features per dataset by default.
```{r}
PAG_seurat <- FindVariableFeatures(PAG_seurat, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(PAG_seurat), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(PAG_seurat)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1, plot2))
```

## Step 10.3 | Scaling the data, peforming dimensionality reduction and determining the dimensionality of the dataset
Linear transformation (scaling) is a standard pre-processing step prior to dimensionality reduction techniques like PCA. The `ScaleData` function:

* Shifts the expression of each gene, so that the mean expression across cells is 0
* Scales the expression of each gene, so that the variance across cells is and highly-expressed genes do not dominate
* Stores the resuts in `SeuratObject[["RNA"]]@scale.data`
```{r}
all.genes <- rownames(PAG_seurat)
PAG_seurat <- ScaleData(PAG_seurat, features = all.genes)

# Scaling is an essential step in the Seurat workflow, but only on genes that will be used as input to PCA. To speed things up, the default in  ScaleData is only to perform scaling on the previously identified variable features (2,000 by default). To do this, omit the  features argument in the previous function call.
```

We can now perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using `features` argument if you wish to choose a different subset.
```{r}
PAG_seurat <- RunPCA(PAG_seurat, features = VariableFeatures(object = PAG_seurat))
```

Seurat provides several useful ways of visualizing both cells and features that define the PCA, including `VizDimReduction`, `DimPlot`, and `DimHeatmap`.
```{r}
# Examine and visualize PCA results a few different ways
print(PAG_seurat[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(PAG_seurat, dims = 1:2, reduction = "pca")
DimPlot(PAG_seurat, reduction = "pca")
```

`DimHeatmap` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting cells to a number plots the extreme cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, this is a valuable tool for exploring correlated feature sets.
```{r}
DimHeatmap(PAG_seurat, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(PAG_seurat, dims = 1:15, cells = 500, balanced = TRUE)
```

To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a metafeature that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

In Macosko et al, they implemented a resampling test inspired by the JackStraw procedure. They randomly permuted a subset of the data (1% by default) and rerun PCA, constructing a null distribution of feature scores, and repeat this procedure. They then identify significant PCs as those with a strong enrichment of low p-value features.
```{r}
# NOTE: This process can take a long time for big datasets.
# Other techniques such as those implemented in ElbowPlot() can be used to reduce computation time
PAG_seurat <- JackStraw(PAG_seurat, num.replicate = 100)
PAG_seurat <- ScoreJackStraw(PAG_seurat, dims = 1:20)
```

The `JackStrawPlot` function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). Significant PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line).
```{r}
JackStrawPlot(PAG_seurat, dims = 1:15)
```

An alternative heuristic method generates an `Elbow plot`: a ranking of principle components based on the percentage of variance explained by each one (`ElbowPlot` function). The elbow suggests a point by which the majority of true signal is captured.
```{r}
ElbowPlot(PAG_seurat)
```

Identifying the true dimensionality of a dataset can be challenging/uncertain for the user. It is therefore a good idea to try the three different methods described above. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff. The third is a heuristic that is commonly used, and can be calculated instantly. It is also good practice to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). Although the results often do not differ dramatically, it is best to err on the higher side when choosing this parameter.

## Step 10.4 | Clustering
Seurat v3 applies a graph-based clustering approach. It first constructs a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors` function, and takes as input the previously defined dimensionality of the dataset.

To cluster the cells, Seurat next applies modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters` function implements this procedure, and contains a resolution parameter that sets the "granularity" of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the `Idents` function.
```{r}
PAG_seurat <- FindNeighbors(PAG_seurat, dims = 1:10)
PAG_seurat <- FindClusters(PAG_seurat, resolution = 0.5)
head(Idents(PAG_seurat), 5) # Look at cluster IDs of the first 5 cells
```

## Step 10.5 | Non-linear dimensionality reduction (UMAP and t-SNE)
Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in a low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. Ideally use the same PCs input to the clustering analysis as input to the UMAP and tSNE.
```{r}
PAG_seurat <- RunTSNE(PAG_seurat, dims = 1:10)
DimPlot(PAG_seurat, reduction = "tsne")
```

You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.
```{r}
saveRDS(PAG_seurat, file = "../output/PAG_seurat_analysis.rds")
```

## Step 10.6 | Finding differentially expressed features (cluster biomarkers)
Seurat can help find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. `FindAllMarkers` automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The `min.pct` argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the `thresh.test` argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, `max.cells.per.ident` can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top.
```{r}
# find all markers of cluster 1
cluster1.markers <- FindMarkers(PAG_seurat, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
```

```{r}
# find all markers distinguishing cluster 3 from clusters 0 and 2
cluster3.markers <- FindMarkers(PAG_seurat, ident.1 = 3, ident.2 = c(0, 1, 2), min.pct = 0.25)
head(cluster3.markers, n = 10)
```

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
PAG_seurat.markers <- FindAllMarkers(PAG_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
PAG_seurat.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
```

Seurat has several tests for differential expression which can be set with the `test.use` parameter. For example, the ROC test returns the "classification power" for any individual marker (ranging from 0 - random, to 1 - perfect).
```{r}
cluster1.markers <- FindMarkers(PAG_seurat, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
```

There are several tools for visualizing marker expression. `VlnPlot` (shows expression probability distributions across clusters), and `FeaturePlot` (visualizes feature expression on a tSNE or PCA plot) are the most commonly used visualizations, but additional methods are `RidgePlot`, `CellScatter`, and `DotPlot`.
```{r}
VlnPlot(PAG_seurat, features = c("Sst", "Npy"))

# you can plot raw counts as well
VlnPlot(PAG_seurat, features = c("Sst", "Npy"), slot = "counts", log = TRUE)

FeaturePlot(PAG_seurat, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
    "CD8A"))
```

`DoHeatmap` generates an expression heatmap for given cells and features.
```{r}
top10 <- PAG_seurat.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(PAG_seurat, features = top10$gene) + NoLegend()
```

## Step 10.7 | Assigning cell type identity to clusters
Finally, we can rename/assign an identity to the clusters we have been able to identify based on the data.
```{r}
new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", 
                     "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(PAG_seurat)
PAG_seurat <- RenameIdents(PAG_seurat, new.cluster.ids)
DimPlot(PAG_seurat, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

Save the complete analysis:
```{r}
saveRDS(PAG_seurat, file = "../output/PAG_seurat_analysis_final.rds")
```
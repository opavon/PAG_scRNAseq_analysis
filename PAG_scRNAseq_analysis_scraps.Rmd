---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Code scraps"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***
This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al. Nature Protocols 2014). 

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/release/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/release/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/release/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources are Bioconductor (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarty et al., Bioinformatics 2017), `scran` (Lun et al. F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008).

***

Below are some code scraps that have been taken out of the pipeline in favour of other preferred alternatives. They most likely require further adaptations before being reincorporated. 

# STEP 2 | Quality Control and pre-processing
## Step 2.5 | Gene QC
### 2.5.3 | Identities of the most highly expressed genes
It can also be useful to plot gene expression frequency versus mean expression level to assess the effects of technical dropout in the dataset. The `plotExprsFreqVsMean()` function fits a non-linear least squares curve for the relationship between expression frequency and mean expression and uses this to define the number of genes above high technical dropout and the numbers of genes that are expressed (here defined as at least 4 counts) in at least 50% and at least 25% of cells. A subset of genes to be treated as feature controls can be specified, otherwise any feature controls previously defined are used. 

Plot frequency of expression (number of cells with non-zero expression) against the mean. These two metrics should be positively correlated with each other for most genes. Outliers from the trend may warrant further investigation. For example, alignment errors for pseudo-genes of highly-expressed genes will result in features with low means that are expressed in all cells. Conversely, PCR amplification biases (or the presence of rare populations) may result in genes with very high means that are expressed in very few cells. 

*Check out the "Scater Case Study" by McCarthy et al. 2016 for more information.*
```{r}
plotExprsFreqVsMean(PAG_sceset,
                    control = "is_spike") 
plotExprsFreqVsMean(PAG_sceset[ , colData(PAG_sceset)$use],
                    control = "is_spike")
```

## Step 2.5b | Cell cycle phase [OPTIONAL]
It is possible to classify cells into cell cycle phases based on the gene expression data using the function `cyclone` (Sciealdone et al. 2015). This, however, is not super useful in the brain, as many neuronal cell types are expected to lie in the G0 resting phase, which is distinct from the other phases of the cell cycle (Coller et al., 2006). We run it anyway and observe that all the cells are in G1.

Cells are classified as being in G1 phase if the G1 score is above 0.5 and greater than the G2/M score; in G2/M phase if the G2/M score is above 0.5 and greater than the G1 score; and in S phase if neither score is above 0.5.

*See McCarthy et al. F1000Research 2016 for an explanation of this step and the code.*
```{r}
library(scran)
library(AnnotationDbi)
library(org.Mm.eg.db)
set.seed(1991)

mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran")) 
assignments <- cyclone(PAG_sceset, mm.pairs, gene.names=rowData(PAG_sceset)$ENSEMBL) 
plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", ylab="G2/M score", pch=16, xlim=c(0,1), ylim=c(0,1))
```

We could store the cell cycle phases for future use:
```{r}
PAG_sceset$cycle_phase <- assignments$phases
```

# STEP 4 | Modelling technical and biological variability in gene expression and identifying highly variable genes
## PATH "A" to feature selection - trendVar
### Step 4a.4 | Identifying correlated gene pairs with Spearman's rho
Another useful procedure is to identify the HVGs that are highly correlated with one another. This distinguishes between HVGs caused by random noise and those involved in driving systematic differences between subpopulations. Correlations between genes can be quantified by computing Spearman's rho, which accommodates non-linear relationships in the expression values. Gene pairs with significantly large positive or negative values of rho are identified using the `correlatePairs` function. We only apply this function to the set of HVGs, because these genes have large biological components and are more likely to exhibit strong correlations driven by biology. In contrast, calculating correlations for all possible gene pairs would require too much computational time and increase the severity of the multiple testing correction. It may also prioritize uninteresting genes that have strong correlations but low variance, e.g., tightly co-regulated house-keeping genes.
```{r}
# Takes around 1 min
set.seed(1991)
library(scran)

start_time_c1 <- Sys.time()
var.cor <- correlatePairs(PAG_sceset_qc_norm_filt, 
                          subset.row=metadata(PAG_sceset_qc_norm_filt)$hvg_out_no_spikes_filt) 
write.table(file="PAG_correlated_genes.tsv", var.cor, sep="\t", quote=FALSE, row.names=FALSE) 
head(var.cor)
end_time_c1 <- Sys.time()
end_time_c1 - start_time_c1
```

The significance of each correlation is determined using a permutation test. For each pair of genes, the null hypothesis is that the expression profiles of two genes are independent. Shuffling the profiles and recalculating the correlation yields a null distribution that is used to obtain a p-value for each observed correlation value (Phipson & Smyth, 2010). Correction for multiple testing across many gene pairs is performed by controlling the FDR at 5%. Correlated gene pairs can be directly used for experimental validation with orthogonal techniques (e.g., fluorescence-activated cell sorting, immunohistochemistry or RNA fluorescence in situ hybridization) to verify that these expression patterns are genuinely present across the cell population.
```{r}
sig.cor <- var.cor$FDR <= 0.05 
summary(sig.cor)
```

The use of `correlatePairs` is primarily intended to identify correlated gene pairs for validation studies. Obviously, non-zero correlations do not provide evidence for a direct regulatory interaction, let alone specify causality. To construct regulatory networks involving many genes, we suggest using dedicated packages such as _[WGCNA](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/)_.

#### 4a.4.1 | Larger sets of genes
Larger sets of correlated genes are assembled by treating genes as nodes in a graph and each pair of genes with significantly large correlations as an edge. In particular, an undirected graph is constructed using methods in the `RBGL` package. Highly connected subgraphs are then identified and defined as gene sets. This provides a convenient summary of the pairwise correlations between genes.
```{r}
# Takes around 15 min
library(RBGL) 
start_time_c2 <- Sys.time()
g <- ftM2graphNEL(cbind(var.cor$gene1, var.cor$gene2)[sig.cor,], W=NULL, V=NULL, edgemode="undirected")
cl <- highlyConnSG(g)$clusters # Time consuming step
cl <- cl[order(lengths(cl), decreasing=TRUE)] 
head(cl)
end_time_c2 <- Sys.time()
end_time_c2 - start_time_c2
```

Significant correlations provide evidence for substructure in the dataset, i.e., subpopulations of cells with systematic differences in their expression profiles. The number of significantly correlated HVG pairs represents the strength of the substructure. If many pairs were significant, this would indicate that the subpopulations were clearly defined and distinct from one another. 

## PATH "B" to feature selection - M3Drop
__Based on the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group).__

We continue using the `PAG_sceset_qc_norm` after normalization. We should thus have a `logcounts` slot in`assays`:
```{r}
# If starting from stored results, load saved filtered dataset from previous Step:
set.seed(1991)
options(stringsAsFactors = FALSE)
library(SingleCellExperiment)
library(scater)
library(scran)
library(matrixStats)
library(M3Drop)

PAG_sceset_qc_norm <- readRDS("PAG_sceset_qc_norm.rds") # Contains filtered cells and genes, and normalized data
assayNames(PAG_sceset_qc_norm)
PAG_sceset_qc_norm
```

scRNA-seq is capable of measuring the expression of many thousands of genes in every cell. However, in most situations only a portion of those will show a response to the biological condition of interest, e.g. differences in cell-type, drivers of differentiation, respond to an environmental stimulus. Most genes detected in a scRNA-seq experiment will only be detected at different levels due to technical noise. One consequence of this is that technical noise and batch effects can obscure the biological signal of interest. Thus, it is often advantageous to perform feature selection to remove those genes which only exhibit technical noise from downstream analysis. Not only does this generally increase the signal:noise ratio in the data; it also reduces the computational complexity of analyses, by reducing the total amount of data to be processed.

For scRNA-seq data, we will be focusing on unsupervised methods of feature selection which don’t require any a priori information, such as cell-type labels or biological group, since they may not be available, or may be unreliable, for many experiments. In contrast, differential expression can be considered a form of supervised feature selection since it uses the known biological label of each sample to identify features (i.e. genes) which are expressed at different levels across groups.

__One important thing...__
Before identifying HVGs, consider dropping any Ribosomal, Mitochondrial, ERCC, sex-specific genes (e.g. XIST), transgenes (EYFP, tdTomato, Cre, TSO concatamers) and genes used for transgenic labeling of cells (VGAT and VGluT2) from the dataset before proceeding to downstream analysis, as some of them are not be biologically informative and others have been used to select the cells.
```{r}
dim(PAG_sceset_qc_norm)

is_X_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "X") # Find which genes correspond to chromosome X 
is_Y_qc_norm <- (rowData(PAG_sceset_qc_norm)$Chromosome == "Y") # Find which genes correspond to chromosome Y
is_feature_control_qc_norm <- (rowData(PAG_sceset_qc_norm)$is_feature_control) # Find which genes correspond to feature controls (Ribosomal, Mitochondrial, ERCC, transgenes)

filter_genes_qc_norm <- !(is_X_qc_norm | is_Y_qc_norm | is_feature_control_qc_norm)
PAG_sceset_qc_norm <- PAG_sceset_qc_norm[filter_genes_qc_norm, ]
dim(PAG_sceset_qc_norm)
```

Feature selection is performed after QC. `M3Drop` contains two different feature selection methods `M3DropFeatureSelection` which is based on a Michaelis-Menten curve and is designed for full-transcript single-cell RNA-seq data (such as Smart-seq2) and `NBumiFeatureSelectionCombinedDrop` which is based on a negative binomial model and is designed for UMI count data. We will use the former.

`M3Drop` feature selection runs on a normalized (but not log-transformed) expression matrix. This can be extracted from our `SingleCellExperiment` object using the command below. This function is compatible with most single-cell RNA-seq analysis packages including: `scater`, `SingleCellExperiment`, `monocle`, and `Seurat`. It can also convert an existing expression matrix to the correct form (removing undetected genes & normalizing/delogging) if you specify whether the matrix is raw counts, or log transformed. Check the manual for details.
```{r}
#expr_matrix <- M3Drop::M3DropConvertData(PAG_sceset_qc_norm) #
#expr_matrix <- M3DropConvertData(PAG_sceset_qc_norm@assays[["logcounts_raw"]], is.log=TRUE, is.counts=FALSE)
expr_matrix <- M3DropConvertData(PAG_sceset_qc_norm@assays[["counts"]], is.log=FALSE, is.counts=TRUE)
nrow(counts(PAG_sceset_qc_norm)) - nrow(expr_matrix) # check the ConvertData function has dropped undetected genes
```

### Step 4b.1 | Identifying genes vs a Null Model
There are two main approaches to unsupervised feature selection. The first is to identify genes which behave differently from a null model describing just the technical noise expected in the dataset.

If the dataset contains spike-in RNAs they can be used to directly model technical noise. However, measurements of spike-ins may not experience the same technical noise as endogenous transcripts (Svensson et al., 2017). In addition, scRNA-seq experiments often contain only a small number of spike-ins which reduces our confidence in fitted model parameters. We will not use spike-in transcripts beyond QC in our analysis.

#### 4b.1.1 | Highly Variable Genes
The first method proposed to identify features in scRNA-seq datasets was to identify highly variable genes (HVG). HVG assumes that if genes have large differences in expression across cells some of those differences are due to biological difference between the cells rather than technical noise. However, because of the nature of count data, there is a positive relationship between the mean expression of a gene and the variance in the read counts across cells. This relationship must be corrected for to properly identify HVGs.
```{r}
# Plot the relationship between mean expression and variance for all genes in this dataset:
plot(
    rowMeans(expr_matrix), 
    rowVars(expr_matrix), 
    log="xy", 
    pch=16,
    xlab="Mean Expression", 
    ylab="Variance", 
    main=""
)
```

A popular method to correct for the relationship between variance and mean expression was proposed by [Brennecke et al. 2013](http://www.nature.com/nmeth/journal/v10/n11/full/nmeth.2645.html). To use the Brennecke method, we first normalize for library size and then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A quadratic curve is fit to the relationship between these two variables for the ERCC spike-in, and then a chi-square test is used to find genes significantly above the curve. This method is included in the `M3Drop` package as the `Brennecke_getVariableGenes(counts, spikes)` function. If the dataset does not contain spike-ins we can use the entire dataset to estimate the technical noise.

In the figure below the red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction.
```{r}
Brennecke_HVG <- M3Drop::BrenneckeGetVariableGenes(expr_matrix,
                                                   fdr = 0.01,
                                                   minBiolDisp = 0.5
                                                   )
```

This function returns a matrix of significant genes as well as their estimated effect size (difference between observed and expected coefficient of variation), and their significance as raw p.values and FDR corrected q.values. For now we will just keep the names of the significant HVG genes.
```{r}
HVG_genes <- Brennecke_HVG$Gene
length(HVG_genes)
```

#### 4b.1.2 | High Dropout Genes
An alternative to finding HVGs is to identify genes with unexpectedly high numbers of zeros. The frequency of zeros, known as the "dropout rate", is very closely related to expression level in scRNASeq data. Zeros are the dominant feature of single-cell RNASeq data, typically accounting for over half of the entries in the final expression matrix. These zeros predominantly result from the failure of mRNAs failing to be reversed transcribed (Andrews and Hemberg, 2016). Reverse transcription is an enzyme reaction thus can be modelled using the Michaelis-Menten equation: Pdropout=1−S/(K+S) where S is the mRNA concentration in the cell (we will estimate this as average expression) and K is the Michaelis-Menten constant.

Because the Michaelis-Menten equation is a convex non-linear function, genes which are differentially expression across two or more populations of cells in our dataset will be shifted up/right of the Michaelis-Menten model. We use M3Drop to identify significant outliers to the right of the MM curve. We also apply 1% FDR multiple testing correction:
```{r}
M3Drop_genes <- M3DropFeatureSelection(expr_matrix,
                                       mt_method = "fdr",
                                       mt_threshold = 0.01
                                       )
M3Drop_genes <- M3Drop_genes$Gene
length(M3Drop_genes)
```

### Step 4b.2 | Correlated Expression
A completely different approach to feature selection is to use gene-gene correlations. This method is based on the idea that multiple genes will be differentially expressed between different cell-types or cell-states. Genes which are expressed in the same cell-population will be positively correlated with each other where as genes expressed in different cell-populations will be negatively correated with each other. Thus important genes can be identified by the magnitude of their correlation with other genes.

The limitation of this method is that it assumes technical noise is random and independent for each cell, thus shouldn't produce gene-gene correlations, but this assumption is violated by batch effects which are generally systematic between different experimental batches and will produce gene-gene correlations. As a result it is more appropriate to take the top few thousand genes as ranked by gene-gene correlation than consider the significance of the correlations.
```{r}
cor_feat <- M3Drop::corFS(expr_matrix) # Takes a long time
Cor_genes <- names(cor_feat)[1:1500]
```

### Step 4b.3 | PCA loadings
Lastly, another common method for feature selection in scRNASeq data is to use PCA loadings. Genes with high PCA loadings are likely to be highly variable and correlated with many other variable genes, thus may be relevant to the underlying biology. However, as with gene-gene correlations PCA loadings tend to be susceptible to detecting systematic variation due to batch effects; thus it is recommended to plot the PCA results to determine those components corresponding to the biological variation rather than batch effects.
```{r}
# PCA is typically performed on log-transformed expression data
pca <- prcomp(log(expr_matrix + 1) / log(2))

# plot projection
plot(
    pca$rotation[,1], 
    pca$rotation[,2], 
    pch = 16
)
```

```{r}
# calculate loadings for components 1 and 2
score <- rowSums(abs(pca$x[,c(1,2)])) 
names(score) <- rownames(expr_matrix)
score <- score[order(-score)]
PCA_genes <- names(score[1:1500])
```

```{r}
#Consider the top 5 principal components. Which ones appear to be most biologically relevant? How do the top 1,500 features change if you consider the loadings for those components?
plot(
    pca$rotation[,2], 
    pca$rotation[,3], 
    pch = 16
)

plot(
    pca$rotation[,3], 
    pca$rotation[,4], 
    pch = 16
)

# calculate loadings for components 1 and 2
score <- rowSums(abs(pca$x[,c(2, 3, 4)]))
names(score) <- rownames(expr_matrix)
score <- score[order(-score)]
PCA_genes2 = names(score[1:1500])
```

### Step 4b.4 | Comparing Methods
We can check whether the identified features really do represent genes differentially expressed between cell-types in this dataset.
```{r}
M3DropExpressionHeatmap(M3Drop_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(HVG_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(Cor_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(PCA_genes,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

```{r}
M3DropExpressionHeatmap(PCA_genes2,
                        expr_matrix,
                        cell_labels = PAG_sceset_qc_norm$cell.type
                        )
```

We can also consider how consistent each feature selection method is with the others using the Jaccard Index:
```{r}
list_of_features <- list(M3Drop_genes,
                         HVG_genes, 
                         Cor_genes, 
                         PCA_genes, 
                         PCA_genes2
                         )

Out <- matrix(0, 
              ncol = length(list_of_features), 
              nrow = length(list_of_features)
              )

for(i in 1:length(list_of_features) ) {
    for(j in 1:length(list_of_features) ) {
        Out[i,j] <- sum(list_of_features[[i]] %in% list_of_features[[j]])/
            length(unique(c(list_of_features[[i]], list_of_features[[j]])))
     }
}

colnames(Out) <- rownames(Out) <- c("M3Drop", "HVG", "Cor", "PCA", "PCA2")
Out
```

# STEP 7 | Clustering
## Step 7.1 | Consensus clustering with SC3
### 7.1.10 | SC3 Clustering using ion channels genes
Here we will run the same clustering approach but using only ion channel genes instead of all the genes. First we load the list of ion channel genes and keep the ones that are present in our dataset:
```{r}
PAG_ionchannels <- PAG_scRNAseq_gene_lists$genes.ionchannels
sum(PAG_scRNAseq_gene_lists$genes.ionchannels != "") # Ion Channel genes present in the list

# Filter any genes not present in our dataset by comparing the gene names with the rownames of our expression matrix (which contains gene names)
PAG_ionchannels <- PAG_ionchannels[(PAG_ionchannels %in% rownames(PAG_sceset_qc))]
length(PAG_ionchannels) # Ion Channel genes present in the dataset
```

Generate a SCE object with only ion channel genes:
```{r}
# Keep only the rows that correspond to ion channel genes:
PAG_sceset_qc_ionchannels <- PAG_sceset_qc[rownames(PAG_sceset_qc) %in% PAG_ionchannels, ]
dim(PAG_sceset_qc_ionchannels)
```

Estimate K:
```{r}
PAG_sceset_qc_ionchannels <- sc3_estimate_k(PAG_sceset_qc_ionchannels)
metadata(PAG_sceset_qc_ionchannels)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_ionchannels)$feature_symbol <- rownames(PAG_sceset_qc_ionchannels)
PAG_sceset_qc_ionchannels <- sc3(PAG_sceset_qc_ionchannels, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
library(shiny)
sc3_interactive(PAG_sceset_qc_ionchannels)
```

For k=2
```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_ionchannels, 
                   k = 2, 
                   show_pdata = "cell.type"
)

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_ionchannels, 
                 k = 2,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_ionchannels, 
                 k = 2,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

```

Figures for k=3
```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_ionchannels, 
                   k = 3, 
                   show_pdata = "cell.type"
                   )

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_ionchannels, 
                 k = 3,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_ionchannels, 
                 k = 3,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = c("cell.type", "PAG.areacollection")
                 )
```

### 7.1.11 | SC3 Clustering using Neuropeptides and Neuromodulators
Here we will run the same clustering approach but using only ion channel genes instead of all the genes. First we load the list of ion channel genes and keep the ones that are present in our dataset:
```{r}
PAG_Neuromodulators_Peptides <- PAG_scRNAseq_gene_lists$genes.NeuromodulatorsPeptides
length(PAG_Neuromodulators_Peptides) # This won't be the length of the $genes.ionchannels column but the one of the longest column of the .csv file (there will be a lot of empty cells).
#typeof(PAG_ionchannels)

# Filter any genes not present in our dataset by comparing the gene names with the rownames of our expression matrix (which contains gene names)
PAG_Neuromodulators_Peptides <- PAG_Neuromodulators_Peptides[(PAG_Neuromodulators_Peptides %in% rownames(PAG_sceset_qc))]
length(PAG_Neuromodulators_Peptides)
```

Generate a SCE object with only ion channel genes:
```{r}
# Keep only the rows that correspond to ion channel genes:
PAG_sceset_qc_Neuromodulators_Peptides <- PAG_sceset_qc[rownames(PAG_sceset_qc) %in% PAG_Neuromodulators_Peptides, ]
dim(PAG_sceset_qc_Neuromodulators_Peptides)
```

Estimate K:
```{r}
PAG_sceset_qc_Neuromodulators_Peptides <- sc3_estimate_k(PAG_sceset_qc_Neuromodulators_Peptides)
metadata(PAG_sceset_qc_Neuromodulators_Peptides)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_Neuromodulators_Peptides)$feature_symbol <- rownames(PAG_sceset_qc_Neuromodulators_Peptides)
PAG_sceset_qc_Neuromodulators_Peptides <- sc3(PAG_sceset_qc_Neuromodulators_Peptides, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
sc3_interactive(PAG_sceset_qc_Neuromodulators_Peptides)
```

```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_Neuromodulators_Peptides, 
                   k = 2, 
                   show_pdata = "cell.type"
                   )

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_Neuromodulators_Peptides, 
                 k = 2,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_Neuromodulators_Peptides, 
                 k = 2,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = "cell.type"
                 )
```

### 7.1.12 | SC3 Clustering ion channels genes instead of cells (need to transpose matrix in a new SCE object)
Run STEP 5.1.2 first, so you already have the subset of genes and the SCE object. Then transpose the SCE object with only ion channel genes you generated in the previous step:
```{r}
# Keep only the rows that correspond to ion channel genes:
dim(PAG_sceset_qc_ionchannels)
# Trying to transpose a SCEset as follows doesn't work, so we have to transpose the original data prior to creating the SCEset
# PAG_sceset_qc_ionchannels_T <- PAG_sceset_qc_ionchannels[colData(PAG_sceset_qc_ionchannels), rowData(PAG_sceset_qc_ionchannels)]
dim(PAG_sceset_qc_ionchannels_T)
```

```{r}
head(PAG_data)
head(PAG_metadata)
PAG_sceset_qc
PAG_sceset_transposed <- SingleCellExperiment(
  assays = list(counts = as.matrix(PAG_data)), 
  colData = PAG_metadata, 
  rowData = PAG_gene_information
)
```

Estimate K:
```{r}
PAG_sceset_qc_ionchannels <- sc3_estimate_k(PAG_sceset_qc_ionchannels)
metadata(PAG_sceset_qc_ionchannels)$sc3$k_estimation
```

Run SC3:
```{r}
rowData(PAG_sceset_qc_ionchannels)$feature_symbol <- rownames(PAG_sceset_qc_ionchannels)
PAG_sceset_qc_ionchannels <- sc3(PAG_sceset_qc_ionchannels, ks = 2:6, biology = TRUE)
```

Explore results interactively:
```{r}
sc3_interactive(PAG_sceset_qc_ionchannels)
```

### 7.1.13 | SC3 Clustering VGAT and VGluT2 cells separately
Do this when you are ready for downstream analysis, after quality checks.  
```{r}
# Is this the best way to subset the data? Probably not, there must be a way to do it without creating a new SCE object.
VGAT_sceset <- PAG_sceset[,grep("^[I]", colnames(PAG_sceset), value=TRUE)]

VGluT2_sceset <- PAG_sceset[,grep("^[E]", colnames(PAG_sceset), value=TRUE)]
```

## Step 7.6 | BackSPIN - biclustering hierarchical [MATLAB/Python]
The BackSPIN biclustering algorithm was developed by Amit Zeisel and is described in Zeisel et al. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq Science 2015 (PMID: 25700174, doi: 10.1126/science.aaa1934). Please cite this paper if you use the BackSPIN algorithm in your work.

Original MATLAB implementation by Amit Zeisel. This repo contains a standalone command-line version of BackSPIN, implemented in Python by Gioele La Manno (https://github.com/linnarsson-lab/BackSPIN)

## Step 7.7 | SINCERA (hierarchical clustering) [not installed]
It performs a gene-level z-score transformation before doing clustering.
It can also identify k as the minimum height of the hierarchical tree that generates no more than a specified number of singleton clusters (clusters containing only 1 cell).

SINCERA: a computational pipeline for SINgle CEll RNA-seq profiling Analysis, can be used for processing scRNA-seq data from a whole organ or sorted cells. The pipeline supports the analysis for: 1) the distinction and identification of major cell types; 2) the identification of cell type specific gene signatures; and 3) the determination of driving forces of given cell types.

Website: https://research.cchmc.org/pbge/sincera.html
Paper: https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004575

## Step 7.8 | pcaReduce [haven't tried, but very stochastic, does not provide a stable result] 
pcaReduce combines PCA, k-means and iterative hierarchical clustering. Starting from a large number of clusters pcaReduce iteratively merges similar clusters; after each merging event it removes the principle component explaning the least variance in the data.

pcaReduce operates directly on the expression matrix. It is recommended to use a gene filter and log transformation before running pcaReduce. We will use the default SC3 gene filter (note that the exprs slot of a scater object is log-transformed by default).
```{r}
# use the same gene filter as in SC3
library(pcaReduce) # You need to install PCAReduce first
input <- logcounts(PAG_sceset_qc[rowData(PAG_sceset_qc)$sc3_gene_filter, ])
```

There are several parameters used by pcaReduce: nbt defines a number of pcaReduce runs (it is stochastic and may have different solutions after different runs). q defines number of dimensions to start clustering with. The output will contain partitions for all k from 2 to q+1. method defines a method used for clustering. S - to perform sampling based merging, M - to perform merging based on largest probability.
```{r}
# run pcaReduce 1 time creating hierarchies from 1 to 30 clusters
pca.red <- PCAreduce(t(input), nbt = 1, q = 30, method = 'S')[[1]]
colData(PAG_sceset_qc)$pcaReduce <- as.character(pca.red[,32 - 10])
plotPCA(PAG_sceset_qc, colour_by = "pcaReduce")
```

## Step 7.9 | tSNE followed by K-means clustering [not really good]
```{r}
PAG_sceset_qc <- plotTSNE(PAG_sceset_qc, rand_seed = 1991, perplexity = 50, return_SCE = TRUE)
# return_SCE adds the results of the tSNE to the reducedDims slot of our object.
```

Once we have the tSNE we apply k-means clustering to the cloud of points on the tSNE map. Try different k (Centers) and perplexities.
```{r}
colData(PAG_sceset_qc)$tSNE_kmeans <- as.character(kmeans(PAG_sceset_qc@reducedDims$TSNE, centers = 5)$clust)
plotTSNE(PAG_sceset_qc, rand_seed = 1991, colour_by = "tSNE_kmeans")
# Try colour_by = "cell.type"
```

# STEP 8 | Differential Expression Analysis
One of the most common types of analyses when working with bulk RNA-seq data is to identify differentially expressed genes. By comparing the genes that change between two conditions, e.g. mutant and wild-type or stimulated and unstimulated, it is possible to characterize the molecular mechanisms underlying the change. Several different methods, e.g. DESeq2 and edgeR, have been developed for bulk RNA-seq. 

In scRNA-seq we usually do not have a defined set of experimental conditions. Instead, we can identify the cell groups by using an unsupervised clustering approach. Once the groups have been identified one can find differentially expressed genes either by comparing the differences in variance between the groups (like the Kruskal-Wallis test implemented in SC3), or by comparing gene expression between clusters in a pairwise manner.

The most common model of RNASeq data is the negative binomial model. However, a raw negative binomial model does not fit full-length transcript data as well due to the high dropout rates relative to the non-zero read counts. For this type of data a variety of zero-inflated negative binomial models have been proposed (e.g. MAST, SCDE). The model that makes more biological sense and with more experimental support (Kim and Marioni, 2013) is the Poisson-Beta distribution, based on a mechanistic model of transcriptional bursting.
```{r}
# Load libraries:
#library(scRNA.seq.funcs)
library(edgeR)
library(monocle)
library(MAST)
library(ROCR)
set.seed(1991)
```

## STEP 6.1: Kolmogorov-Smirnov test (non-parametric)
To compare the distributions for each gene in the two individuals/groups. The KS-test quantifies the distance between the empirical cummulative distributions of the expression of each gene in each of the two populations. It is sensitive to changes in mean expression and changes in variability. However it assumes data is continuous and may perform poorly when data contains a large number of identical values (eg. zeros). Another issue with the KS-test is that it can be very sensitive for large sample sizes and thus it may end up as significant even though the magnitude of the difference is very small.
```{r}
pValues_KS <- apply(
    norm, 1, function(x) {
        ks.test(
            x[PAG_sceset_qc$cell.type == "VGluT2"], 
            x[PAG_sceset_qc$cell.type == "VGAT"]
        )$p.value
    }
)
# multiple testing correction
pValues_KS <- p.adjust(pValues_KS, method = "fdr")
```

```{r}
#How many of the significant DE genes are detected
significant_DE_genes_KS <- names(pValues_KS)[pValues_KS < 0.05]
length(significant_DE_genes_KS)
```

Often it is informative to vary the threshold and evaluate performance across a range of values. This is then plotted as a receiver-operating-characteristic curve (ROC) and a general accuracy statistic can be calculated as the area under this curve (AUC). The ROCR package facilitates this plotting.

## STEP 6.2: Wilcox/Mann-Whitney-U Test (non-parametric)
The Wilcox-rank-sum test is another non-parametric test, but tests specifically if values in one group are greater/less than the values in the other group. Thus it is often considered a test for difference in median expression between two groups; whereas the KS-test is sensitive to any change in distribution of expression values.
```{r}
pValues_W <- apply(
    norm, 1, function(x) {
        wilcox.test(
            x[PAG_sceset_qc$cell.type == "VGluT2"], 
            x[PAG_sceset_qc$cell.type == "VGAT"]
        )$p.value
    }
)
# multiple testing correction
pValues_W <- p.adjust(pValues_W, method = "fdr")
```

```{r}
#How many of the significant DE genes are detected
significant_DE_genes_W <- names(pValues_W)[pValues_W < 0.05]
length(significant_DE_genes_W)
```

## STEP 6.3: SCDE [not yet implemented]
The scde package implements routines for fitting individual error models for single-cell RNA-seq measurements. Briefly, the read counts observed for each gene are modeled using a mixture of a negative binomial (NB) distribution (for the amplified/detected transcripts) and low-level Poisson distribution (for the unobserved or background-level signal of genes that failed to amplify or were not detected for other reasons). These models can then be used to identify robustly differentially expressed genes between groups of cells.

Website: http://hms-dbmi.github.io/scde/

### STEP 6.3.1: Preparing the data
The analysis starts with a matrix of read counts (the values must be integers). We first need to define the two groups we are going to compare:
```{r}
library(scde)
# load example dataset
data(es.mef.small)

# factor determining cell types
sg <- factor(gsub("(MEF|ESC).*", "\\1", colnames(es.mef.small)), levels = c("ESC", "MEF"))
# the group factor should be named accordingly
names(sg) <- colnames(es.mef.small)  
table(sg)

# clean up the dataset
cd <- clean.counts(es.mef.small, min.lib.size=1000, min.reads = 1, min.detected = 1)
```

### STEP 6.3.2: Fitting error models
As a next step we fit the error models on which all subsequent calculations will rely. The fitting process relies on a subset of robust genes that are detected in multiple cross-cell comparisons. Here we supply the groups = sg argument, so that the error models for the two cell types are fit independently (using two different sets of "robust" genes). If the groups argument is omitted, the models will be fit using a common set.

Note this step takes a considerable amount of time unless multiple cores are used.
```{r}

```


## STEP 6.4: edgeR (bulk RNA) [not yet implemented]
edgeR is designed for bulkRNA and is based on a negative binomial model of gene expression and uses a generalized linear model (GLM) framework, the enables us to include other factors such as batch to the model.
<!--
```{r}
dge <- DGEList(
    counts = counts, 
    norm.factors = rep(1, length(counts[1,])), 
    group = group
)
group_edgeR <- factor(group)
design <- model.matrix(~ group_edgeR)
dge <- estimateDisp(dge, design = design, trend.method = "none")
fit <- glmFit(dge, design)
res <- glmLRT(fit)
pVals <- res$table[,4]
names(pVals) <- rownames(res$table)

pVals <- p.adjust(pVals, method = "fdr")
DE_Quality_AUC(pVals)
```
-->

## STEP 6.5: MAST [not yet implemented]
MAST is based on a zero-inflated negative binomial model. It tests for differential expression using a hurdle model to combine tests of discrete (0 vs not zero) and continuous (non-zero values) aspects of gene expression. Again this uses a linear modelling framework to enable complex models to be considered.

## STEP 6.6: BPSC [not yet implemented]
BPSC uses the Poisson-Beta model of single-cell gene expression, which we discussed in the previous chapter, and combines it with generalized linear models which we’ve already encountered when using edgeR. BPSC performs comparisons of one or more groups to a reference group (“control”) and can include other factors such as batches in the model.


# STEP X | OTHER TOOLs ANALYSIS STEPS
## STEP X.1 | Explore and compare dimensionality reduction approaches with Sleepwalk
Website: https://anders-biostat.github.io/sleepwalk/
```{r}
library("devtools")
devtools::install_github("anders-biostat/JsRCom")
devtools::install_github("anders-biostat/sleepwalk")
```

## STEP X.2 | Comparing/Combining scRNASeq datasets (scmap)
As more and more scRNA-seq datasets become available, carrying merged seurat comparisons between them is key. There are two main approaches to comparing scRNASeq datasets. The first approach is label-centric which is focused on trying to identify equivalent cell-types/states across datasets by comparing individual cells or groups of cells. The other approach is cross-dataset normalization which attempts to computationally remove experiment-specific technical/biological effects so that data from multiple experiments can be combined and jointly analyzed.

scmap is a method for projecting cells from a scRNA-seq experiment on to the cell-types or individual cells identified in a different experiment.

Website: http://bioconductor.org/packages/release/bioc/html/scmap.html
 
```{r}
library(scmap)
```

## STEP X.3 | Pseudotime Analysis (for development trajectories)
In many situations, one is studying a process where cells change continuously. This includes, for example, many differentiation processes taking place during development: following a stimulus, cells will change from one cell-type to another. Ideally, we would like to monitor the expression levels of an individual cell over time. Unfortunately, such monitoring is not possible with scRNA-seq since the cell is lysed (destroyed) when the RNA is extracted.

Instead, we must sample at multiple time-points and obtain snapshots of the gene expression profiles. Since some of the cells will proceed faster along the differentiation than others, each snapshot may contain cells at varying points along the developmental progression. We use statistical methods to order the cells along one or more trajectories which represent the underlying developmental trajectories, this ordering is referred to as pseudotime.

In this chapter we will consider five different tools: Monocle, TSCAN, destiny, SLICER and ouija for ordering cells according to their pseudotime development. To illustrate the methods we will be using a dataset on mouse embryonic development (Deng et al. 2014). The dataset consists of 268 cells from 10 different time-points of early mouse development. In this case, there is no need for pseudotime alignment since the cell labels provide information about the development trajectory. Thus, the labels allow us to establish a ground truth so that we can evaluate and compare the different methods.

A recent review by Cannoodt et al provides a detailed summary of the various computational methods for trajectory inference from single-cell transcriptomics (Cannoodt, Saelens, and Saeys 2016). They discuss several tools, but unfortunately for our purposes many of these tools do not have complete or well-maintained implementations, and/or are not implemented in R

## STEP X.4 | Imputation (after QC but prior to downstream analysis)
One of the main challenges when analyzing scRNA-seq data is the presence of zeros, or dropouts. The dropouts are assumed to have arisen for three possible reasons:

1. The gene was not expressed in the cell and hence there are no transcripts to sequence
2. The gene was expressed, but for some reason the transcripts were lost somewhere prior to sequencing
3. The gene was expressed and transcripts were captured and turned into cDNA, but the sequencing depth was not sufficient to produce any reads.

Thus, dropouts could be result of experimental shortcomings, and if this is the case then we would like to provide computational corrections. One possible solution is to impute the dropouts in the expression matrix. To be able to impute gene expression values, one must have an underlying model. However, since we do not know which dropout events are technical artefacts and which correspond to the transcript being truly absent, imputation is a difficult challenge.

To the best of our knowledge, there are currently two different imputation methods available: MAGIC (Dijk et al. 2017) and scImpute (W. V. Li and Li 2017).

## STEP X.5 | Search scRNA-seq data (scfind)
scfind is a tool that allows one to search single cell RNA-Seq collections (Atlas) using lists of genes, e.g. searching for cells and cell-types where a specific set of genes are expressed. scfind is a Bioconductor package.
```{r}
library(scfind)
library(SingleCellExperiment)
set.seed(1991)
```

Create a gene index using our dataset. The gene index contains for each gene indexes of the cells where it is expressed. This is similar to sparsification of the expression matrix. In addition to this the index is also compressed in a way that it can be accessed very quickly.
```{r}
cellIndex <- buildCellIndex(PAG_sceset_qc, cell_type_column = "cell.type")
```

Define lists of interesting marker genes (you can use the PAG_scRNAseq_gene_lists.csv file) or manually by:
```{r}
VGAT_genes <- c("Gad1", "Gad2", "Slc32a1")
VGAT_genes <- VGAT_genes[(VGAT_genes %in% rownames(PAG_sceset_qc))]

VGluT2_genes <- c("Slc17A6")
VGluT2_genes <- VGluT2_genes[(VGluT2_genes %in% rownames(PAG_sceset_qc))]
```

findCell function returns a list of p-values corresponding to all cell types in a given dataset. It also outputs a list of cells in which genes from the given gene list are co-expressed. We will run it on all lists of marker genes defined above:
```{r}
res <- findCell(cellIndex, VGAT_genes)
barplot(-log10(res$p_values), ylab = "-log10(pval)", las = 2)
head(res$common_exprs_cells)
```

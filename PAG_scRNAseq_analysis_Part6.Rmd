---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Part VI: clustering"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***

This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al., Nature Protocols 2014). 

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/3.10/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/3.10/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/3.10/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources include [Bioconductor](http://www.bioconductor.org/) (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarthy et al., Bioinformatics 2017), `scran` (Lun et al., F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `edgeR` (Robinson et al., Bioinformatics 2010), `MAST` (Finak, McDavid, Yajima et al., Genome Biology 2015), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008), `UMAP` (McInnes et al., arXiv 2018), and the [Mathematical Statistics and Machine Learning for Life Sciences](https://towardsdatascience.com/tagged/stats-ml-life-sciences) column by Nikolay Oskolkov.

***

# STEP 6 | Clustering
Once we have normalized the data, identified highly variable genes, and corrected confounding factors we can carry out analyses that are relevant to the biological questions at hand.

scRNA-seq data allow de novo discovery and annotation of cell-types based on transcription profiles. Computationally, we need to identify groups of cells based on the similarities of the transcriptomes without any prior knowledge of the labels, nor the number of clusters we will end up with. This is very challenging due to the high level of noise (both technical and biological) and the large number of dimensions (i.e. genes).

Unsupervised clustering is useful in many different applications and it has been widely studied in machine learning. Some of the most popular approaches are __hierarchical clustering__, __k-means clustering__ and __graph-based clustering__.

Ideally we want to run several tools on the same dataset and see whether we get similar results. To compare two sets of clustering labels we can use the _adjusted Rand index_ from the `mclust` package. The index is a measure of the similarity between two data clusterings. Values of the adjusted Rand index lie in [0;1] interval, where 1 means that two clusterings are identical and 0 means the level of similarity expected by chance.

We continue using the `PAG_sceset_qc_norm_filt_corr` after normalization, filtering, and batch correction. We should thus have a `corrected` slot in `assays`:
```{r}
set.seed(1991)
library(SC3)
library(scater)
library(SingleCellExperiment)
library(pheatmap)
library(mclust) # contains adjustedRandIndex function to compare clustering results

PAG_sceset_qc_norm_filt_corr <- readRDS("PAG_sceset_qc_norm_filt_corr.rds") # Contains filtered cells and genes, and normalized data
assayNames(PAG_sceset_qc_norm_filt_corr)
PAG_sceset_qc_norm_filt_corr
```

## Step 6.1 | Consensus clustering with SC3
Single-Cell Consensus Clustering (SC3) is a tool for unsupervised clustering of scRNA-seq data. SC3 achieves high accuracy and robustness by consistently integrating different clustering solutions through a consensus approach. An interactive graphical implementation makes SC3 accessible to a wide audience of users. In addition, SC3 also aids biological interpretation by identifying marker genes, differentially expressed genes and outlier cells. A manuscript describing  SC3 in details is published in Nature Methods.

The advantage of the SC3 is that it can directly ingest a `SingleCellExperiment` object, and it has a function that can estimate a number of clusters for us. SC3 is a purely clustering tool and it does not provide functions for the sequencing quality control (QC) or normalisation. On the contrary, it is expected that these preprocessing steps are performed by a user in advance. SC3 requires both `counts` and `logcounts` slots to exist in the input `SingleCellExperiment` object. The `counts` slot is used for gene filtering, which is based on gene dropout rates. The `logcounts` slot, which is supposed to contain both normalised and log-transformed expression matrix, is used in the main clustering algorithm.  Additionally, if spike-ins are defined via `isSpike function`, SC3 will automatically remove them before doing clustering.

### 6.1.1 | Prepare SingleCellExperiment object for SC3
SC3 requires a `feature_symbol` column of the `rowData` slot of the input `SingleCellExperiment` object to contain preferable feature names (genes/transcript) which will be used in the future visualisations. 
```{r}
rowData(PAG_sceset_qc_norm_filt_corr)$feature_symbol <- rownames(PAG_sceset_qc_norm_filt_corr)
```

We can next run `sc3_prepare`. This method prepares an object of `SCE` class for `SC3` clustering, defining all parameters needed for clustering and storing them in the `sc3` slot. The parameters have their own defaults but can be manually changed (see `?sc3_prepare` for more details). 
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_prepare(PAG_sceset_qc_norm_filt_corr,
                                            gene_filter = FALSE, # Set your own filter by changing the sc3_gene_filter slot
                                            n_cores = 10,
                                            rand_seed = 1991) 
# SC3 is stochastic, if we run it different times we will get different results, so we need to make sure we have set a seed before running it.

str(metadata(PAG_sceset_qc_norm_filt_corr)$sc3)
```

As we can see above, `SC3` applies a gene filter to remove genes very lowly expressed in all samples and also the ones that are expressed everywhere, so that these genes do not contribute to the clustering (see `$sc3_gene_filter`). However, we have already filtered genes in previous steps and selected highly variable genes, which we could use for it. We can manually define a list of genes that we want to use for clustering by setting the `sc3_gene_filter` column of the `rowData` slot:
```{r}
# Check which lists of genes you have available to use from loaded metadata or calculated highly variable genes:
names(metadata(PAG_sceset_qc_norm_filt_corr))

# Use Highly Variable Genes:
#rowData(PAG_sceset_qc_norm_filt_corr)$sc3_gene_filter <- rownames(PAG_sceset_qc_norm_filt_corr) %in% metadata(PAG_sceset_qc_norm_filt_corr)$hvg_out_no_spikes_filt

# Use Ion Channel Genes:
rowData(PAG_sceset_qc_norm_filt_corr)$sc3_gene_filter <- rownames(PAG_sceset_qc_norm_filt_corr) %in% metadata(PAG_sceset_qc_norm_filt_corr)$genes.ionchannels

# Use Neuropeptides and Neuromodulators Genes:
#rowData(PAG_sceset_qc_norm_filt_corr)$sc3_gene_filter <- rownames(PAG_sceset_qc_norm_filt_corr) %in% metadata(PAG_sceset_qc_norm_filt_corr)$genes.NeuromodulatorsPeptides

# Use Neuropeptides and Neuromodulators Genes:
#rowData(PAG_sceset_qc_norm_filt_corr)$sc3_gene_filter <- rownames(PAG_sceset_qc_norm_filt_corr) %in% metadata(PAG_sceset_qc_norm_filt_corr)$genes.Transcriptionfactors
```

### 6.1.2 | Estimate k
Once the `SCE` object is prepared for clustering, `Sc3` has a method to estimate the optimal number of cluster `k` for a scRNA-seq expression matrix, which uses Tracy-Widom theory on random matrices to estimate the optimal number of clusters k.
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_estimate_k(PAG_sceset_qc_norm_filt_corr)
metadata(PAG_sceset_qc_norm_filt_corr)$sc3$k_estimation
str(metadata(PAG_sceset_qc_norm_filt_corr)$sc3)
```

### 6.1.3 | Calculate distances and transformations
We are now ready to perform the clustering itself. The method `sc3_calc_dists` calculates distances between the cells and creates and populates the `distances` slot, which contains a list of distance matrices corresponding to Euclidean, Pearson and Spearman distances.
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_calc_dists(PAG_sceset_qc_norm_filt_corr)
names(metadata(PAG_sceset_qc_norm_filt_corr)$sc3$distances)
```

Next, the method `sc3_calc_transfs` calculates the transformations of the distance matrices contained in the distances item of the `sc3` slot, and creates and populates the `transformations` slot, which contains a list of transformations of the distance matrices corresponding to PCA and graph Laplacian transformations. It also removes the previously calculated `distances` item from the `sc3` slot:
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_calc_transfs(PAG_sceset_qc_norm_filt_corr)
names(metadata(PAG_sceset_qc_norm_filt_corr)$sc3$transformations)
metadata(PAG_sceset_qc_norm_filt_corr)$sc3$distances
```

### 6.1.4 | K-means
We use the `sce_kmeans` method to perform k-means on the transformed distance matrices contained in the `transformations` item of the `sc3` slot. The method `sc3_kmeans` also creates and populates the `kmeans` item, which contains a list of kmeans clusterings. Given that we need to define the ks at the beginning, it is best to set a range of ks around the estimated value obtained from `sc3_estimate` to try and compare different solutions.
```{r}
start_time <- Sys.time() # Takes around 5 min
PAG_sceset_qc_norm_filt_corr <- sc3_kmeans(PAG_sceset_qc_norm_filt_corr,
                                           ks = 2:12)
names(metadata(PAG_sceset_qc_norm_filt_corr)$sc3$kmeans)
end_time <- Sys.time()
end_time - start_time
```

### 6.1.5 | Calculate consensus
In this step `SC3` provides a clustering solution. When calculating consensus for each value of `k`, `SC3` averages the clustering results of `kmeans` using a consensus approach. The method `sc3_calc_consens` calculates consensus matrices based on the clustering solutions contained in the `kmeans` item of the `sc3` slot, and it then creates and populates the `consensus` item, which for each value of k it contains a consensus matrix, an `hclust` object corresponding to hierarchical clustering of the consensus matrix, and the Silhouette indices of the clusters. It also removes the previously calculated `kmeans` item from the `sc3` slot.
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_calc_consens(PAG_sceset_qc_norm_filt_corr)
names(metadata(PAG_sceset_qc_norm_filt_corr)$sc3$consensus)
names(metadata(PAG_sceset_qc_norm_filt_corr)$sc3$consensus$`1`)
metadata(PAG_sceset_qc_norm_filt_corr)$sc3$kmeans
```

### 6.1.6 | Calculate biology
`SC3` can also calculate DE genes, marker genes, and cell outliers based on the calculated consensus clusterings. Similary to the clustering solutions, the method `sc3_calc_biology` writes the results for the cell outliers (cell-related information) to the `colData` slot of the `SCE` object. In contrast, DE and marker genes results (gene-related information) are written to the `rowData` slot.
```{r}
PAG_sceset_qc_norm_filt_corr <- sc3_calc_biology(PAG_sceset_qc_norm_filt_corr, 
                                                 ks = 2:12)
```

### 6.1.7 | Running SC3 with the wrapper function [OPTIONAL ALTERNATIVE]
Alternatively, we can run SC3 with the wrapper function and ask it to calculate biological properties of the clusters as well. This should do the same steps as we just did in the same order. However, make sure you have at least prepared the `SCE` object and have estimated ks beforehand.
```{r}
rowData(PAG_sceset_qc_norm_filt_corr)$feature_symbol <- rownames(PAG_sceset_qc_norm_filt_corr)

start_time <- Sys.time() # Takes around 35 min
PAG_sceset_qc_norm_filt_corr <- sc3(PAG_sceset_qc_norm_filt_corr,
                                    ks = 2:12,
                                    gene_filter = TRUE, # Set to FALSE if you want to determine a list of genes to be used instead
                                    biology = TRUE, 
                                    n_cores = 4,
                                    rand_seed = 1991)
end_time <- Sys.time()
end_time - start_time
```

### 6.1.8 | Explore the results
To run the interactive `Shiny` session, we can do the following: 
```{r}
sc3_interactive(PAG_sceset_qc_norm_filt_corr)
```

SC3 writes all its results obtained for cells to the `colData` slot of the `SCE` object by adding additional columns to it, and all its results obtained for features (genes/transcripts) to the `rowData` slot. This slot also contains all other cell features calculated by the scater package either automatically during the `SCE` object creation or during the `calculateQCMetrics` call. One can identify the SC3 results using the "sc3_" prefix. We can use these results as highlights when plotting.
```{r}
# Consensus Matrix
sc3_plot_consensus(PAG_sceset_qc_norm_filt_corr, 
                   k = 4, 
                   show_pdata = c("cell.type", "PAG.arearegistration"))

# DE Genes
sc3_plot_de_genes(PAG_sceset_qc_norm_filt_corr, 
                  k = 4,
                  p.val = 0.001,
                  show_pdata = c("cell.type", "PAG.arearegistration"))

# Marker Genes
sc3_plot_markers(PAG_sceset_qc_norm_filt_corr,
                 k = 4,
                 auroc = 0.7,
                 p.val = 0.01,
                 show_pdata = c("cell.type", "PAG.arearegistration"))
```

We can also use the results from the clustering to highlight the clusters in any PCA/tSNE/UMAP plot:
```{r}
plotPCA(PAG_sceset_qc_norm_filt_corr, colour_by = "sc3_8_clusters")
```

#### Consensus matrix
The consensus matrix is a NxN matrix, where N is the number of cells. It represents similarity between the cells based on the averaging of clustering results from all combinations of clustering parameters. Similarity 0 (blue) means that the two cells are always assigned to different clusters. In contrast, similarity 1 (red) means that the two cells are always assigned to the same cluster. The consensus matrix is clustered by hierarchical clustering and has a diagonal-block structure. Intuitively, the perfect clustering is achieved when all diagonal blocks are completely red and all off-diagonal elements are completely blue. 
```{r}
sc3_plot_consensus(PAG_sceset_qc_norm_filt_corr, 
                   k = 3, 
                   show_pdata = c("cell.type",
                                  "PAG.areacollection",
                                  "sc3_3_clusters"
                                  )
                   )
```

#### Silhouette plot and stability index
A silhouette is a quantitative measure of the diagonality of the consensus matrix. An average silhouette width (shown at the bottom left of the silhouette plot) varies from 0 to 1, where 1 represents a perfectly block-diagonal consensus matrix and 0 represents a situation where there is no block-diagonal structure. The best clustering is achieved when the average silhouette width is close to 1.
```{r}
sc3_plot_silhouette(PAG_sceset_qc_norm_filt_corr, 
                    k = 5
                    )
```

The Stability Index shows how stable each cluster is accross the selected range of ks. The stability index varies between 0 and 1, where 1 means that the same cluster appears in every solution for different k.
```{r}
sc3_plot_cluster_stability(PAG_sceset_qc_norm_filt_corr, 
                           k = 3
                           )
```

#### Heatmap of the expression matrix
The expression panel represents the original input expression matrix (cells in columns and genes in rows) after cell and gene filters. Genes are clustered by k-means with k = 100 (dendrogram on the left) and the heatmap represents the expression levels of the gene cluster centers after log2-scaling. It is also possible to annotate cells (columns of the expression matrix) with any column of the `colData` slot of the `SCE` object.
```{r}
sc3_plot_expression(PAG_sceset_qc_norm_filt_corr, 
                    k = 3, 
                    show_pdata = c("cell.type",
                                   "PAG.areacollection",
                                   "sc3_3_clusters"
                                   )
                    )
```

#### Differentially expressed and Marker genes
Differential expression is calculated using the non-parametric Kruskal-Wallis test. A significant p-value indicates that gene expression in at least one cluster stochastically dominates one other cluster. SC3 provides a list of all differentially expressed genes with adjusted p-values < 0.01 and plots gene expression profiles of the 50 genes with the lowest p-values. Note that the calculation of differential expression after clustering can introduce a bias in the distribution of p-values, and thus we advise to use the p-values for ranking the genes only.
```{r}
sc3_plot_de_genes(PAG_sceset_qc_norm_filt_corr, 
                  k = 3,
                  p.val = 0.001,
                  show_pdata = c("cell.type",
                                 "PAG.areacollection",
                                 "sc3_3_clusters"
                                 )
                  )
```

To find marker genes, for each gene a binary classifier is constructed based on the mean cluster expression values. The classifier prediction is then calculated using the gene expression ranks. The area under the receiver operating characteristic (ROC) curve is used to quantify the accuracy of the prediction. A p-value is assigned to each gene by using the Wilcoxon signed rank test. The genes with the area under the ROC curve (AUROC) > 0.85 and with the p-value < 0.01 are defined as marker genes and the top 10 marker genes of each cluster are visualized in this panel. The AUROC and the p-value thresholds can be changed using the slider and radio buttons below.
```{r}
sc3_plot_markers(PAG_sceset_qc_norm_filt_corr, 
                 k = 3,
                 auroc = 0.65,
                 p.val = 0.01,
                 show_pdata = c("cell.type",
                                "PAG.areacollection",
                                "sc3_3_clusters"
                                )
                 )
```

### 6.1.9 | Export the results
SC3 allows us to export the results into an Excel file:
```{r}
sc3_export_results_xls(PAG_sceset_qc_norm_filt_corr, filename = "PAG_sceset_qc_norm_filt_corr_clust")
```

## STEP 6.2 | clusterExperiment [TO TRY]
## STEP 6.3 | bigSCale2
bigSCale is an analytical framework for big-scale single-cell data, available [here](https://github.com/iaconogi/bigSCale2).

```{r}
library(bigscale)
PAG_sceset_qc <- bigscale(PAG_sceset_qc)
```

OR, if you want to run it step by step:
```{r}
# Pre-process the data and generate the model:
PAG_sceset_qc = preProcess(PAG_sceset_qc)
PAG_sceset_qc = storeNormalized(PAG_sceset_qc) # stores normalized data
PAG_sceset_qc = setModel(PAG_sceset_qc) # computes the numerical model
PAG_sceset_qc = storeTransformed(PAG_sceset_qc) # stores transformed expression data (needed for some plots)
viewModel(PAG_sceset_qc) # check the model

# Compute the highly variable genes and we calculate cell to cell distances. 
PAG_sceset_qc = setODgenes(PAG_sceset_qc, min_ODscore=2.33) # min_ODscore is the Z-score treshold for selecting the genes (default 2.33). Increase it to be more stringent (less genes) and viceversa.
viewODgenes(PAG_sceset_qc) # visually inspect the selected highly variable genes

# Compute the distances and the t-SNE:
PAG_sceset_qc = setDistances(PAG_sceset_qc)
PAG_sceset_qc = storeTsne(PAG_sceset_qc)

# Cluster the data
PAG_sceset_qc = setClusters(PAG_sceset_qc)

# Make pseudotime analysis:
PAG_sceset_qc = storePseudo(PAG_sceset_qc)

# Compute the differential expression for all genes. Select speed.preset='slow' for maximum accuracy with long computational time.
PAG_sceset_qc = computeMarkers(PAG_sceset_qc, speed.preset='slow')

# Organize all the genes into markers and signatures of co-expression. cutoff is a Z-score which filters the genes and retains only those with significant changes of expression. Inrease it if you want to be more stringent or viceversa.
PAG_sceset_qc = setMarkers(PAG_sceset_qc, cutoff=3)

# Restore some matrices from the virtual memory to complete the analysis.
PAG_sceset_qc = restoreData(PAG_sceset_qc)
```

Plot of the clusters and signatures of coexpressed genes and visualise:

* The dendrogram representing how the cells are phenotypically organized and clustered.
* Colored bars representing the clusters, the library size (meant as a proxy to transcriptome size/complexity) and the pseudotime of the cells. An additional color bar is displayed for any user custom `colData()` (for example, sample batches, conditions and so on ...). For custom user `colData`, the color codes are automatically chosen upoen the type of data (numeric or factor).
* The clustered signatures of coexpressed genes alogside their size. Here, all the genes differentially expressed are organized in signatures of co-expressed genes.
```{r}
viewSignatures(PAG_sceset_qc)
```

We can also inspect the markers of a specific cluster, with markers of level 1 being the most specific to a given cluster.
```{r}
viewSignatures(PAG_sceset_qc, selected.cluster=2)
```

Barplots and violin plots of selected genes to visualize gene expression at single cell level with colored clusters:
```{r}
viewGeneBarPlot(PAG_sceset_qc, gene.list = c('Aqp4','Olig1','Thy1'))
```

```{r}
viewGeneViolin(PAG_sceset_qc, 'Asic4')
```

t-SNE and UMAP plots:

* If you want to color the cell according to some custom annotation you can pass a `factor` variable in place of a gene name. If you want to visualize a UMAP plot first compute the UMAP data with `sce=storeUMAP(sce)` and then `viewReduced(sce,method = 'UMAP')`
```{r}
viewReduced(PAG_sceset_qc) # to see t-SNE with clusters
viewReduced(PAG_sceset_qc, color.by = 'Stmn2') # to see t-SNE with gene expression
```

Browsing markers:
* To have a look to the markers found by bigscale we retrive `Mlist` from the single cell object. `Mlist` is a 2 dimensional list containing for each cluster the markers of the different levels. Let's inspect the markers of level 1 (most specific) of cluster 4. We will take advantage of the package `DT` for interactive visualization. Running the next command line we will see the markers specific to cluster 4 sorted from the highest (most significant) to the lowest (less significant) Zscore.
```{r}
Mlist = getMarkers(PAG_sceset_qc)
DT::datatable(Mlist[[4,1]])
```

Browsing signatures:
* Alternatevely to a cluster-based organization of the markers (as shown before, we have clusters and we have levels) there is also a more compact organization of markers into lists of co-expressed genes. This are the same lists shown with `viewSignatures(sce)`.
```{r}
Signatures = getSignatures(PAG_sceset_qc)
DT::datatable(Signatures[[1]])
```

## STEP 6.4 | Hierarchical clustering on Euclidean distances
The denoised log-expression values can be used to cluster cells into putative subpopulations. Specifically, we perform hierarchical clustering on the Euclidean distances between cells, using Ward's criterion to minimize the total variance within each cluster. This yields a dendrogram that groups together cells with similar expression patterns across the chosen genes.
```{r}
principal_components <- reducedDim(PAG_sceset_qc_norm, "PCA")
PAG_dist <- dist(principal_components) # Making a distance matrix
PAG_tree <- hclust(PAG_dist, method="ward.D2") # Building a tree
plot(PAG_tree)
```

### 6.1.1 | Cutree
We can next cut the tree into different clusters and see how these correspond to the known sample conditions:
```{r}
PAG_clusters <- cutree(PAG_tree, k=3) 
table(PAG_clusters, PAG_sceset_qc_norm$PAG.area)
```

Color the t-SNE according to the cluster identity:
```{r}
PAG_sceset_qc_norm$Cluster <- factor(PAG_clusters)
plotTSNE(PAG_sceset_qc_norm, colour_by='Cluster')
```

We next use a heatmap to visualize the expression profiles of the top 100 genes with the largest biological components. If there is structure, we should see "blocks" in expression that correspond nicely to known sample features. We possibly could have subclustered further, in which case we would subset and repeat the above process.
```{r}
library(pheatmap)
plotHeatmap(PAG_sceset_qc_norm, 
            features=rownames(var_out_no_spikes)[order(var_out_no_spikes$bio, decreasing=TRUE)[1:100]],
            cluster_cols=PAG_tree, colour_columns_by="PAG.area",
            center=TRUE, symmetric=TRUE)
```

When clustering, it is often useful to look at silhouette plots to assess cluster separatedness. Each bar corresponds to a cell, and is proportional to the difference in the average distances to all other cells in the same cluster versus cells in the nearest neighbouring cluster. A good gauge for the number of clusters is that which maximizes the average silhouette width.
```{r}
library(cluster)
par(mfrow=c(2,2))
for (k in 2:5) { 
    example_clusters <- cutree(PAG_tree, k=k)
    sil <- silhouette(example_clusters, dist=PAG_dist)
    plot(sil, col=rainbow(k)[sort(sil[,1])])
}
```

Other options for clustering are:

* Use the `cutreeDynamic()` function in the _dynamicTreeCut_ package, for topology-aware cutting of the tree (doesn't require specifying the number of clusters).
* Use graph-based methods such as `buildSNNGraph()` or `buildKNNGraph()`, followed by clustering methods from _igraph_.
* Use methods with pre-specified number of clusters, e.g., k-means with `kmeans()` and _SC3_, self-organizing maps in _flowSOM_.

### 6.1.2 | DynamicTreeCut
Clusters are explicitly defined by applying a dynamic tree cut (Langfelder, Zhang, and Horvath 2008) to the dendrogram. This exploits the shape of the branches in the dendrogram to refine the cluster definitions, and is more appropriate than `cutree` for complex dendrograms. Greater control of the empirical clusters can be obtained by manually specifying cutHeight in  `cutreeDynamic`. We also set `minClusterSize` to a lower value than the default of 20, to avoid spurious aggregation of distant small clusters.
```{r}
library(dynamicTreeCut)
PAG_clusters <- unname(cutreeDynamic(PAG_tree, distM=as.matrix(PAG_dist), 
                                     minClusterSize=10, verbose=0))
```

We examine the distribution of cells in each cluster with respect to known factors. We check whether each cluster is comprised of cells from both batches, which would indicate that the clustering is not driven by a batch effect. Differences in the composition of each cluster are observed with respect to `cell.type` or `PAG.area`.
```{r}
table(PAG_clusters, PAG_sceset_qc_norm$cell.type)
table(PAG_clusters, PAG_sceset_qc_norm$PAG.area)
```

We can now visualize the cluster assignments for all cells on the t-SNE we created before. Adjacent cells are generally assigned to the same cluster, indicating that the clustering procedure was applied correctly.
```{r}
PAG_sceset_qc_norm$Cluster <- factor(PAG_clusters)
plotTSNE(PAG_sceset_qc_norm, colour_by="Cluster") + fontsize
```

We check the separatedness of the clusters using the silhouette width. Cells with large positive silhouette widths are closer to other cells in the same cluster than to cells in different clusters. Conversely, cells with negative widths are closer to other clusters than to other cells in the cluster to which it was assigned. Each cluster would ideally contain many cells with large positive widths, indicating that it is well-separated from other clusters.
```{r}
library(cluster)
clust.col <- scater:::.get_palette("tableau10medium") # hidden scater colours
sil <- silhouette(PAG_clusters, dist = PAG_dist)
sil.cols <- clust.col[ifelse(sil[,3] > 0, sil[,1], sil[,2])]
sil.cols <- sil.cols[order(-sil[,1], sil[,3])]
plot(sil, main = paste(length(unique(PAG_clusters)), "clusters"), 
     border=sil.cols, col=sil.cols, do.col.sort=FALSE)
```

The silhouette width can be used to determine the parameter values that maximize the separation between clusters. For example, we could vary the cut height or splitting depth in `cutreeDynamic` to maximize the average silhouette width across all cells. This usually provides a satisfactory initial clustering for further examination. However, keep in mind that the granularity of clustering is much like the magnification on a microscope. Different views of the data can be obtained with different granularities, some of which may be suboptimal on measures of separation. Users should not fixate on the clustering with the greatest separation if it does not provide the desired granularity for a particular biological question.

* Small silhouette positive widths indicates that the separation between clusters is weak. This may be symptomatic of over-clustering where clusters that are clearly defined are further split into subsets that are less well separated. 
* An alternative clustering strategy is to use a matrix of distances derived from correlations (e.g., as in `quickCluster`). This is more robust to noise and normalization errors, but is also less sensitive to subtle changes in the expression profiles.
* Both Ward's criterion and complete linkage yield spherical, compact clusters. In particular, complete linkage favours the formation of clusters with the same diameter. This may be desirable in some cases but is less appropriate when subpopulations differ in their variance. Thus, we typically use Ward's criterion for our initial clustering. Of course, it is simple (and recommended) to try other approaches provided that some assessment is performed, e.g., using the silhouette width.

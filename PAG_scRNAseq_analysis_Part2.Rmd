---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Part II: pre-processing and data quality control"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***

This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al., Nature Protocols 2014). 

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/3.10/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/3.10/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/3.10/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources include [Bioconductor](http://www.bioconductor.org/) (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarthy et al., Bioinformatics 2017), `scran` (Lun et al., F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `edgeR` (Robinson et al., Bioinformatics 2010), `MAST` (Finak, McDavid, Yajima et al., Genome Biology 2015), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008), `UMAP` (McInnes et al., arXiv 2018), and the [Mathematical Statistics and Machine Learning for Life Sciences](https://towardsdatascience.com/tagged/stats-ml-life-sciences) column by Nikolay Oskolkov.

***

# STEP 2 | Pre-processing and data Quality Control
Once we have our `SingleCellExperiment` object with our data and annotations, we can proceed to QC the data.
```{r}
# If starting from stored results, load the saved dataset from previous notebook:
options(stringsAsFactors = FALSE)
library(SingleCellExperiment)
library(scater)
library(scran)

PAG_sceset <- readRDS("PAG_sceset.rds") # Contains cells and genes and their metadata
assayNames(PAG_sceset)
```

## Step 2.1 | Set control features
The package `scater` allows us to define control features (genes) that we can use for quality checks, such as ERCC spike-ins if we have them, Mitochondrial and Ribosomal genes, and any fluorophores used to identify the cells if they came from transgenic animals.

If we have ERCC spike-ins in our dataset, and these are labeled accordingly in the gene names, we can store them in a dedicated slot of the `SingleCellExperiment` object. If you are doing this on the gene symbols, beware of the human gene family that also starts with "ERCC". We need to explicitly indicate that the ERCC set is, in fact, a spike-in set with the `splitAltExps()` function. This is necessary as spike-ins require special treatment in some downstream steps such as variance estimation and normalization.
```{r}
# ERCCs
is_spike <- grepl("^ERCC-", rownames(PAG_sceset))
#isSpike(PAG_sceset, "ERCC") <- is_spike # Add them to the Spike-in slot - Deprecated
PAG_sceset <- splitAltExps(PAG_sceset, ifelse(is_spike, "ERCC", "gene")) # using new AltExps

# Mitochondrial genes
is_mitochondrial <- which(rowData(PAG_sceset)$Chromosome == "M") # Select the mitochondrial chromosome

# Ribosomal genes, if you somehow marked the ribosomal gene IDs.
is_ribosomal <- which(rowData(PAG_sceset)$gene_biotype == "rRNA")

# Genes from sex chromosomes
is_X <- which(rowData(PAG_sceset)$Chromosome == "X")
is_Y <- which(rowData(PAG_sceset)$Chromosome == "Y")

# XIST gene
is_XIST <- which(rowData(PAG_sceset)$gene_name == "Xist")

# EYFP, tdTomato, Cre, and TSO concatamers
is_tdTomato <- which(rowData(PAG_sceset)$Chromosome == "A") # tdTomato fluorophor
# Alternatively, if using gene_name use <- grepl("^tdTomato", rownames(PAG_sceset))
is_EYFP <- which(rowData(PAG_sceset)$Chromosome == "B") # EYFP fluorophor
# Alternatively, if using gene_name use <- grepl("^EYFP", rownames(PAG_sceset))
is_Cre <- which(rowData(PAG_sceset)$Chromosome == "C") # Cre transgene to express fluorophors
# Alternatively, if using gene_name use <- grepl("^Cre", rownames(PAG_sceset))
is_SmartSeqTSO <- which(rowData(PAG_sceset)$Chromosome == "D") # TSO concatamers

# VGAT and VGluT2
is_VGAT <- which(rowData(PAG_sceset)$gene_name == "Slc32a1")
is_VGluT2 <- which(rowData(PAG_sceset)$gene_name == "Slc17a6") 

#spikeNames(PAG_sceset) # Only ERCCs should appear as Spikes in the SingleCellExperiment object - Deprecated
altExpNames(PAG_sceset)
altExp(PAG_sceset)
```

To facilitate visualisation of gene expression values, we will very crudely create a new assay slot containing log2-transformed counts:
```{r}
# Create an additional assay slot with log-transformed counts:
assay(PAG_sceset, "logcounts_raw") <- log2(counts(PAG_sceset) + 1)
PAG_sceset
assayNames(PAG_sceset)
```

### 2.1.1 | Uniquify feature names
To facilitate interpretation in the upcoming steps, we can use gene symbols as `rownames` instead of ENSEMBL IDs. `scater` provides the `uniquifyFeatureNames()` function to avoid non-unique gene symbols (in which case it pastes the ENSEMBL ID after it) or missing gene symbols (in which case it uses the ENSEMBL ID).

_Cautionary note_: only do this for your own interpretation and analysis, if you release the expression matrix, make sure you use a stable ID such as ENSEMBL as the row name.
```{r}
library(scater)
head(rownames(PAG_sceset), 50)
tail(rownames(PAG_sceset), 50)
rownames(PAG_sceset) <- uniquifyFeatureNames(rowData(PAG_sceset)$gene_id, rowData(PAG_sceset)$gene_name)
head(rownames(PAG_sceset), 50)
tail(rownames(PAG_sceset), 50)
```

## Step 2.2 | Calculate QC metrics
Once we have defined the control features, the function `perCellQCMetrics()` allows us to automatically calculate QC metrics based on these features. For each cell, it calculates quality control metrics such as the total number of counts or the proportion of counts in mitochondrial genes or spike-in transcripts. If we use `addPerCellQC()`, these are stored in the `colData()` of the `SingleCellExperiment` for future reference:
```{r}
# Calculate the quality metrics after defining the control features:
library(scater)
PAG_sceset <- addPerCellQC(PAG_sceset,
                           subsets = list(#ERCC = isSpike(PAG_sceset, "ERCC"), # Deprecated
                                          Mitochondrial = is_mitochondrial,
                                          Ribosomal = is_ribosomal,
                                          Chromosome_X = is_X,
                                          Chromosome_Y = is_Y,
                                          XIST = is_XIST,
                                          tdTomato = is_tdTomato,
                                          EYFP = is_EYFP,
                                          Cre = is_Cre,
                                          TSO_concatamers = is_SmartSeqTSO,
                                          VGAT = is_VGAT,
                                          VGluT2 = is_VGluT2
                                          )
                           )
PAG_sceset
colnames(colData(PAG_sceset))
```

## Step 2.3 | Cell QC
We next need to remove low-quality cells to ensure that technical effects do not distort downstream analyses. Some of the metrics we can use to assess quality are automatically calculated in the previous step, including Library size, Number of expressed features, Proportion of spike-in reads, Proportion of mitochondrial reads, etc. Together, these metrics helps us spot failures in cDNA capture (failed reverse transcription) and cell damage during isolation.

_See the the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun and the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks  for more details on this and following QC steps._

### 2.3.1 | Library size and Number of expressed features
Two common measures of cell quality are the library size (total sum of counts across all features) and the number of detected features in each library. 

* Cells with relatively small library sizes are likely to have been dead prior to aspiration and their RNA may not have been efficiently captured (i.e. converted into cDNA and amplified) during library preparation. These cells should be removed.

* Additionally, the number of detected features in each cell is defined as the number of features with non-zero counts for that cell. Any cell with very few detected genes is likely to be of poor quality as the diverse transcript population has not been successfully captured. Similarly, any cell with way more genes detected is likely to contain mRNA molecules from two cells instead of just one. 
```{r}
# Plot the histograms of the library sizes and number of detected genes:
par(mfrow = c(1,2)) # Draw figures in a 1 by 2 array.

hist(PAG_sceset$total/1e6,
     breaks = 50,
     xlab = "Read per sample (millions)", main = "", col = "grey80", ylab = "Number of cells")
abline(v = c(0.4, 4.6), col = "blue", lwd = 2, lty = 2) # less than 400K reads and more than 4.6M

hist(PAG_sceset$detected, 
     breaks = 50,
     xlab = "Number of detected genes", main = "", col = "grey80", ylab = "Number of cells")
abline(v = c(5000, 13000), col = "blue", lwd = 2, lty = 2) # exclude less than 5,000 features and more than 13K (potential doublets?)

summary(PAG_sceset$total/1e6)
summary(PAG_sceset$detected)
```

```{r}
# Plot the library size against the total number of detected features:
plotColData(PAG_sceset,
            x = "detected",
            y = "total",
            colour_by = "PAG.arearegistration",
            other_fields = "cell.type") +
  facet_wrap(~cell.type) +
  theme(legend.position = "right") +
  xlab("Number of detected genes") +
  ylab("Library size") +
  stat_smooth(method = "lm", se = FALSE, size = 0.5, fullrange = TRUE)
```

### 2.3.2 | ERCCs, Mitochondrial and Ribosomal RNAs, and TSO concatamers
Another measure of cell quality is the ratio between ERCC spike-in RNAs and endogenous RNAs. This ratio can be used to estimate the total amount of RNA in the captured cells. Cells with a high proportion of spike-in RNAs had probably low starting amounts of RNA, likely due to the cell being dead or stressed which may result in the RNA being degraded.The quantity of spike-in RNA added to each cell should be constant, which means that the proportion should increase upon loss of endogenous RNA in low-quality cells.

It is also worth looking at the proportion of reads mapped to genes in the Mitochondrial/Ribosomal genome amd to TSO concatamers. High proportions are indicative of poor-quality cells, possibly because of increased apoptosis and/or loss of cytoplasmic RNA from lysed cells. We will be looking at both the histograms and plots with every individual cell.

_IMPORTANT_: cells of small dimensions will have a higher fraction of ERCC reads than larger cells, so take this into account if you think this might be the case. In addition, cells with a high active metabolic rate may have larger proportion of mitochondrial transcripts. For these reasons the best strategy is to simultaneously take the different quality measures into considiration before deciding whether to exclude a cell or not.

_Using ERCC for normalization vs using them for QC_: ERCCs contain 96 different sequences at increasing concentrations. If you use a very diluted volume (1:5,000,000) you will only get the ones at a higher concentration, so it will not be useful for normalization, but it will still be useful for QC. If you want to use them for normalization, you would need roughly 50% of your reads to be from ERCCs (which might be a waste of reads if you are not benchmarking different methods). We will use them for QC only, in which case you would want about 5-10% of the reads going to the spike-ins. If this is not the case, it suggests that you need to alter the dilution.
```{r}
# Plot the histograms of the percentage of feature controls in all cells:
par(mfrow = c(2,2))

# ERCCs
hist(PAG_sceset$altexps_ERCC_percent,
     breaks = 50,
     xlab = "ERCC proportion (%)", ylab = "Number of cells", main = "", col = "grey80")
abline(v = 1, col = "blue", lwd = 2, lty = 2)

# Mitochondrial genes
hist(PAG_sceset$subsets_Mitochondrial_percent,
     breaks = 50,
     xlab = "Mitochondrial proportion (%)", ylab = "Number of cells", main = "", col = "grey80")
abline(v = 15, col = "blue", lwd = 2, lty = 2)

# Ribosomal genes
hist(PAG_sceset$subsets_Ribosomal_percent,
     breaks = 50,
     xlab = "Ribosomal proportion (%)", ylab = "Number of cells", main = "", col = "grey80")
abline(v = 20, col = "blue", lwd = 2, lty = 2)

# TSO concatamers
hist(PAG_sceset$subsets_TSO_concatamers_percent,
     breaks = 50,
     xlab = "TSO concatamers proportion (%)", ylab = "Number of cells", main = "", col = "grey80")
abline(v = 5, col = "blue", lwd = 2, lty = 2)

summary(PAG_sceset$altexps_ERCC_percent)
summary(PAG_sceset$subsets_Mitochondrial_percent)
summary(PAG_sceset$subsets_Ribosomal_percent)
summary(PAG_sceset$subsets_TSO_concatamers_percent)
```

```{r}
# Plot the same as above but with each cell represented individually
plotColData(PAG_sceset,
            x = "detected",
            y = "altexps_ERCC_percent",
            colour_by = "PAG.arearegistration",
            other_fields = "cell.type") +
  facet_wrap(~cell.type) + 
  theme(legend.position = "right") +
  xlab("Number of detected genes") +
  ylab("ERCC proportion (%)") +
  stat_smooth(method = "lm", se = FALSE, size = 0.5, fullrange = TRUE)

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_Mitochondrial_percent",
            colour_by = "PAG.arearegistration",
            other_fields = "cell.type") +
  facet_wrap(~cell.type) + 
  xlab("Number of detected genes") +
  ylab("Mitochondrial proportion (%)") +
  stat_smooth(method = "lm", se = FALSE, size = 0.5, fullrange = TRUE)

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_Ribosomal_percent",
            colour_by = "PAG.arearegistration",
            other_fields = "cell.type") +
  facet_wrap(~cell.type) + 
  xlab("Number of detected genes") +
  ylab("Ribosomal proportion (%)") +
  stat_smooth(method = "lm", se = FALSE, size = 0.5, fullrange = TRUE)

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_TSO_concatamers_percent",
            colour_by = "PAG.arearegistration",
            other_fields = "cell.type") +
  facet_wrap(~cell.type) + 
  xlab("Number of detected genes") +
  ylab("TSO concatamers proportion (%)") +
  stat_smooth(method = "lm", se = FALSE, size = 0.5, fullrange = TRUE)
```

### 2.3.3 | EYFP/tdTomato expression
We can also take advantage of our experimental approach to isolate the cells. Given that we isolated cells from transgenic animals expressing either EYFP or tdTomato as a reporter, while cells should always express Cre, they should only express either EYFP or tdTomato.
```{r}
# Plot the histograms of the counts assigned to transgenes in all cells:
par(mfrow = c(1,3))

# EYFP
hist(PAG_sceset$subsets_EYFP_sum,
     breaks = 50,
     xlab = "EYFP expression (total counts)", ylab = "Number of cells", main = "", col = "grey80")

# tdTomato
hist(PAG_sceset$subsets_tdTomato_sum,
     breaks = 50,
     xlab = "tdTomato expression (total counts)", ylab = "Number of cells", main = "", col = "grey80")

# Cre
hist(PAG_sceset$subsets_Cre_sum,
     breaks = 50,
     xlab = "Cre expression (total counts)", ylab = "Number of cells", main = "", col = "grey80")
```

```{r}
# Plot Expression values of EYFP and tdTomato in several ways:
plotExpression(PAG_sceset[, PAG_sceset$cell.fluorophor == "EYFP"], c("EYFP", "tdTomato", "Cre"), x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing",
               ncol = 3,
               xlab = "Mouse ID")

plotExpression(PAG_sceset[, PAG_sceset$cell.fluorophor == "tdTomato"], c("EYFP", "tdTomato", "Cre"), x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing", 
               ncol = 3,
               xlab = "Mouse ID")

plotExpression(PAG_sceset, c("EYFP", "tdTomato"), x = "cell.fluorophor", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "mouse.id", 
               xlab = "Cell fluorophor")

plotExpression(PAG_sceset, "tdTomato", x = "EYFP", 
               exprs_values = "counts",
               colour_by = "cell.fluorophor", 
               xlab = "tdTomato (total counts)")

plotExpression(PAG_sceset, "tdTomato", x = "EYFP", 
               exprs_values = "logcounts_raw",
               colour_by = "cell.fluorophor", 
               xlab = "tdTomato (total counts)")

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_EYFP_sum",
            colour_by = "mouse.id",
            other_fields = "cell.fluorophor") +
  facet_wrap(~cell.fluorophor) + 
  xlab("Number of detected genes") +
  ylab("EYFP counts")

plotColData(PAG_sceset,
            x = "detected",
            y = "subsets_tdTomato_sum",
            colour_by = "mouse.id",
            other_fields = "cell.fluorophor") +
  facet_wrap(~cell.fluorophor) + 
  xlab("Number of detected genes") +
  ylab("tdTomato counts")
```

An easy way to check everything is as it should be is to look at whether each cell expresses only the fluorophor it should according to the transgenic line it was acquired from. A simple scatterplot of log-transformed counts of EYFP and tdTomato should be enough to reveal this.
```{r}
# Log transform the counts for EYFP and tdTomato
PAG_sceset$log2_total_counts_EYFP <- log2(PAG_sceset$subsets_EYFP_sum + 1)
PAG_sceset$log2_total_counts_tdTomato <- log2(PAG_sceset$subsets_tdTomato_sum + 1)

# In EYFP cells, plot the EYFP total counts against the tdTomato counts
plot(PAG_sceset[, PAG_sceset$cell.fluorophor == "EYFP"]$subsets_EYFP_sum,
     PAG_sceset[, PAG_sceset$cell.fluorophor == "EYFP"]$subsets_tdTomato_sum,
     xlim = c(0, max(PAG_sceset$subsets_EYFP_sum)),
     ylim = c(0, max(PAG_sceset$subsets_tdTomato_sum)),
     xlab = "EYFP (counts)", ylab = "tdTomato (counts)",
     type = "p", pch = 19, cex = 1.25, 
     col = rgb(255, 200, 0, 255/2, maxColorValue = 255))

# Add the equivalent plot for tdTomato cells
points(PAG_sceset[, PAG_sceset$cell.fluorophor == "tdTomato"]$subsets_EYFP_sum,
       PAG_sceset[, PAG_sceset$cell.fluorophor == "tdTomato"]$subsets_tdTomato_sum,
       type = "p", pch = 19, cex = 1,
       col = rgb(255, 0, 0, 255/6, maxColorValue = 255))


# In EYFP cells, plot the EYFP log2 total counts against the tdTomato counts
plot(PAG_sceset[, PAG_sceset$cell.fluorophor == "EYFP"]$log2_total_counts_EYFP,
     PAG_sceset[, PAG_sceset$cell.fluorophor == "EYFP"]$log2_total_counts_tdTomato,
     xlim = c(0, max(PAG_sceset$log2_total_counts_EYFP)),
     ylim = c(0, max(PAG_sceset$log2_total_counts_tdTomato)),
     xlab = "EYFP (log2 counts)", ylab = "tdTomato (log2 counts)",
     type = "p", pch = 19, cex = 1.25, 
     col = rgb(255, 200, 0, 255/2, maxColorValue = 255))

# Add the equivalent plot for tdTomato cells
points(PAG_sceset[, PAG_sceset$cell.fluorophor == "tdTomato"]$log2_total_counts_EYFP,
       PAG_sceset[, PAG_sceset$cell.fluorophor == "tdTomato"]$log2_total_counts_tdTomato,
       type = "p", pch = 19, cex = 1,
       col = rgb(255, 0, 0, 255/6, maxColorValue = 255))
```

As we can see, we have a minority of cells that express both fluorophors when they should only express one. The safest is to exclude those, as there may have been contamination at one of the processing steps.

### 2.3.4 | VGAT/VGluT2 expression
We isolated cells from transgenic animals expressing either EYFP or tdTomato as a reporter under VGAT or VGluT2 promoters. However, we don't really know whether neurons in the midbrain area we are investigating express one or the other, or whether they express both? If the latter, in which proportions? We repeat the same approach we used for the fluorophors to inspect VGAT and VGluT2 expression.
```{r}
# Plot the histograms of the counts assigned to VGAT and VGluT2 in all cells:
par(mfrow = c(1,2))

# VGAT
hist(PAG_sceset$subsets_VGAT_sum,
     breaks = 50,
     xlab = "VGAT expression (total counts)", ylab = "Number of cells", main = "", col = "grey80")

# VGluT2
hist(PAG_sceset$subsets_VGluT2_sum,
     breaks = 50,
     xlab = "VGluT2 expression (total counts)", ylab = "Number of cells", main = "", col = "grey80")
```

```{r}
# Plot Expression values of VGAT and VGluT2 in several ways:
plotExpression(PAG_sceset[, PAG_sceset$cell.type == "VGAT"], c("Slc32a1", "Slc17a6"), x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing",
               xlab = "Mouse ID")

plotExpression(PAG_sceset[, PAG_sceset$cell.type == "VGluT2"], c("Slc32a1", "Slc17a6"), x = "mouse.id", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "batch.processing",
               xlab = "Mouse ID")

plotExpression(PAG_sceset, c("Slc32a1", "Slc17a6"), x = "cell.type", 
               exprs_values = "logcounts_raw", # alternatively try "counts"
               colour_by = "mouse.id", 
               xlab = "Cell type")

plotExpression(PAG_sceset, "Slc32a1", x = "Slc17a6", 
               exprs_values = "counts", 
               colour_by = "cell.type",
               xlab = "VGluT2 (total counts)")

plotExpression(PAG_sceset, "Slc32a1", x = "Slc17a6", 
               exprs_values = "logcounts_raw", 
               colour_by = "cell.type",
               xlab = "VGluT2 (logcounts_raw)")
```

We again use a scatterplot of log-transformed counts of VGAT and VGluT2 to quickly visualise their expression.
```{r}
# Log transform the counts for VGAT and VGluT2
PAG_sceset$log2_total_counts_VGAT <- log2(PAG_sceset$subsets_VGAT_sum + 1)
PAG_sceset$log2_total_counts_VGluT2 <- log2(PAG_sceset$subsets_VGluT2_sum + 1)

# In VGAT cells, plot the VGAT total counts against the VGluT2 counts
plot(PAG_sceset[, PAG_sceset$cell.type == "VGAT"]$subsets_VGAT_sum,
     PAG_sceset[, PAG_sceset$cell.type == "VGAT"]$subsets_VGluT2_sum,
     xlim = c(0, max(PAG_sceset$subsets_VGAT_sum)),
     ylim = c(0, max(PAG_sceset$subsets_VGluT2_sum)),
     xlab = "VGAT (counts)", ylab = "VGluT2 (counts)",
     type = "p", pch = 19, cex = 1.25, 
     col = rgb(255, 119, 124, 255/2, maxColorValue = 255))

# Add the equivalent plot for VGluT2 cells
points(PAG_sceset[, PAG_sceset$cell.type == "VGluT2"]$subsets_VGAT_sum,
       PAG_sceset[, PAG_sceset$cell.type == "VGluT2"]$subsets_VGluT2_sum,
       type = "p", pch = 19, cex = 1,
       col = rgb(0, 156, 181, 255/6, maxColorValue = 255))


# In VGAT cells, plot the VGAT log2 counts against the VGluT2 counts
plot(PAG_sceset[, PAG_sceset$cell.type == "VGAT"]$log2_total_counts_VGAT,
     PAG_sceset[, PAG_sceset$cell.type == "VGAT"]$log2_total_counts_VGluT2,
     xlim = c(0, max(PAG_sceset$log2_total_counts_VGAT)),
     ylim = c(0, max(PAG_sceset$log2_total_counts_VGluT2)),
     xlab = "VGAT (log2 counts)", ylab = "VGluT2 (log2 counts)",
     type = "p", pch = 19, cex = 1.25, 
     col = rgb(255, 119, 124, 255/2, maxColorValue = 255))

# Add the equivalent plot for VGluT2 cells
points(PAG_sceset[, PAG_sceset$cell.type == "VGluT2"]$log2_total_counts_VGAT,
       PAG_sceset[, PAG_sceset$cell.type == "VGluT2"]$log2_total_counts_VGluT2,
       type = "p", pch = 19, cex = 1,
       col = rgb(0, 156, 181, 255/6, maxColorValue = 255))
```

As we can see, a large proportion of cells express both VGAT and VGlUT2. The coexpression of VGAT and VGluT2 has been reported previously in midbrain, so it shouldnt't be surprising. However, if we find cells that only express the opposite transporter as they should (e.g. if a VGAT-Cre cell only expresses VGluT2) we should consider excluding them (although again, these might just be dropout events, so we can use combinatorial QC metrics to err on the safe side).

## Step 2.4 | Filtering low quality cells
Choosing a filtering threshold for the above quality metrics is not straightforward as their absolute values depend on the experimental protocol. For example, sequencing to greater depths will lead to more reads and more expressed features, regardless of the quality of the cells, and using more spike-in RNA in the protocol will result in higher spike-in proportions. The histograms and plots from the previous section should allow us to visualise the distribution of our samples and more easily identify any obvious outliers.

After visual inspection, we can follow several paths to exclude low quality cells. One way is to manually establish a cutoff to exclude any low quality cells. Although it is hard to set a threshold automatically, as it will depend on the dataset and sequencing depth, another thing we can try is to remove cells with log-library sizes that are more than 4 median absolute deviations (MADs) below the median log-library size by using the `isOutlier()` function. Finally, we can use `scater` to detect outliers based on PCA on quality metrics for each cell. We will use all these approaches in parallel and compare them to each other before deciding which one to apply.

### 2.4.1 | Using Manual filters
A possible strategy is to set pre-defined thresholds on each QC metric. For example, we might remove all cells with library sizes below 400,000 counts and numbers of expressed genes below 5000. This avoids any assumptions associated with the use of outliers to identify low-quality cells, but it requires considerable experience to determine appropriate thresholds for each experimental protocol and biological system (e.g. thresholds for read count-based data are simply not applicable for UMI-based data, and vice versa, and even with the same protocol and system, the appropriate threshold can vary from run to run due to the vagaries of RNA capture and sequencing). What we can do instead is to fix the threshold based on the observed distribution of each metric in our dataset:
```{r}
# Set the filters and check how many cells you would exclude with each one after visual inspection of data:

# At least 400,000 counts and no more than 4.6M (potential doublets)
PAG_sceset$filter_by_total_counts_manual <- (PAG_sceset$total < 400000 | PAG_sceset$total > 4600000)
table(PAG_sceset$filter_by_total_counts_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_total_counts_manual]$PAG.areacollection)

# At least 5,000 genes detected and not more than 13,000 (potential doublets)
PAG_sceset$filter_by_expr_features_manual <- (PAG_sceset$detected < 5000 | PAG_sceset$detected > 13000)
table(PAG_sceset$filter_by_expr_features_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_expr_features_manual]$PAG.areacollection)

# Not more than 60% of counts consumed by the 100 most expressed genes
PAG_sceset$filter_by_percent_top_100_manual <- (PAG_sceset$percent_top_100 > 60)
table(PAG_sceset$filter_by_percent_top_100_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_percent_top_100_manual]$PAG.areacollection)

# Not more than 1% of counts in ERCCs
PAG_sceset$filter_by_pct_ERCC_manual <- (PAG_sceset$altexps_ERCC_percent > 1)
table(PAG_sceset$filter_by_pct_ERCC_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_pct_ERCC_manual]$PAG.areacollection)

# Not more than 15% of counts in Mitochondrial genes
PAG_sceset$filter_by_pct_Mitochondrial_manual <- (PAG_sceset$subsets_Mitochondrial_percent > 15)
table(PAG_sceset$filter_by_pct_Mitochondrial_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_pct_Mitochondrial_manual]$PAG.areacollection)

# Not more than 20% of counts in Ribosomal genes for VGAT cells, and not more than 30% for VGluT2 cells
PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual <- (PAG_sceset$cell.type == "VGAT" & PAG_sceset$subsets_Ribosomal_percent > 20)
table(PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual]$PAG.areacollection)

PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual <- (PAG_sceset$cell.type == "VGluT2" & PAG_sceset$subsets_Ribosomal_percent > 30)
table(PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual]$PAG.areacollection)

# Not more than 5% of counts in TSO concatamers
PAG_sceset$filter_by_pct_TSO_concatamer_manual <- (PAG_sceset$subsets_TSO_concatamers_percent > 5)
table(PAG_sceset$filter_by_pct_TSO_concatamer_manual)
summary(PAG_sceset[,PAG_sceset$filter_by_pct_TSO_concatamer_manual]$PAG.areacollection)

# Custom filters: remove Aqueduct cell and Patch-seq cells:
PAG_sceset$filter_AQ_cells <- (PAG_sceset$cell.id == "AQ")
table(PAG_sceset$filter_AQ_cells)
summary(PAG_sceset[,PAG_sceset$filter_AQ_cells]$PAG.areacollection)

PAG_sceset$filter_patchseq_cells <- (PAG_sceset$patch.recorded == "yes")
table(PAG_sceset$filter_patchseq_cells)
summary(PAG_sceset[,PAG_sceset$filter_patchseq_cells]$PAG.areacollection)

# Custom filters: identify the cells that express the wrong fluorophor
PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells <- (PAG_sceset$cell.fluorophor == "EYFP" & PAG_sceset$subsets_tdTomato_sum > 0)
table(PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells)
summary(PAG_sceset[,PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells]$PAG.areacollection)

PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells <- (PAG_sceset$cell.fluorophor == "tdTomato" & PAG_sceset$subsets_EYFP_sum > 0)
table(PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells)
summary(PAG_sceset[,PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells]$PAG.areacollection)

# Custom filters: identify the cells from male mice that express XIST
#PAG_sceset$filter_by_wrong_Xist_in_males <- (PAG_sceset$mouse.sex == "M" & PAG_sceset$subsets_XIST_percent > 0.005)
#table(PAG_sceset$filter_by_wrong_Xist_in_males)
#summary(PAG_sceset[,PAG_sceset$filter_by_wrong_Xist_in_males]$PAG.areacollection)

# Custom filters: label the cells not expressing any fluorophor to use them in combination of other filters
PAG_sceset$cells_nofluorophor <- (PAG_sceset$subsets_EYFP_sum == 0 & PAG_sceset$subsets_tdTomato_sum == 0)
table(PAG_sceset$cells_nofluorophor)
summary(PAG_sceset[,PAG_sceset$cells_nofluorophor]$PAG.areacollection)

# Custom filters: from the VGAT cells not expressing VGAT, mark the ones expressing VGluT2 and not expressing any fluorophor (they might be wrongly aspirated cells - e.g. a neighbouring non-fluorescent cell was aspirated instead of the fluorescent one)
PAG_sceset$filter_by_wrong_transporter_VGAT_cells <- (PAG_sceset$cell.type == "VGAT" & PAG_sceset$cells_nofluorophor == TRUE & PAG_sceset$subsets_VGAT_sum == 0 & PAG_sceset$subsets_VGluT2_sum > 0)
table(PAG_sceset$filter_by_wrong_transporter_VGAT_cells)
summary(PAG_sceset[,PAG_sceset$filter_by_wrong_transporter_VGAT_cells]$PAG.areacollection)

# Custom filters: from the VGluT2 cells not expressing VGluT2, mark the ones expressing VGAT and not expressing any fluorophor (they might be wrongly aspirated cells - e.g. a neighbouring non-fluorescent cell was aspirated instead of the fluorescent one)
PAG_sceset$filter_by_wrong_transporter_VGluT2_cells <- (PAG_sceset$cell.type == "VGluT2" & PAG_sceset$cells_nofluorophor == TRUE & PAG_sceset$subsets_VGAT_sum > 0 & PAG_sceset$subsets_VGluT2_sum == 0)
table(PAG_sceset$filter_by_wrong_transporter_VGluT2_cells)
summary(PAG_sceset[,PAG_sceset$filter_by_wrong_transporter_VGluT2_cells]$PAG.areacollection)

# Custom filters: mark any cells with no expression of either VGAT nor VGluT2 nor fluorophor (again, these are likely to be dropouts)
PAG_sceset$cells_noVGAT_noVGluT2 <- (PAG_sceset$subsets_VGAT_sum == 0 & PAG_sceset$subsets_VGluT2_sum == 0 & PAG_sceset$cells_nofluorophor == TRUE)
table(PAG_sceset$cells_noVGAT_noVGluT2)
summary(PAG_sceset[,PAG_sceset$cells_noVGAT_noVGluT2]$PAG.areacollection)
```

Just in case we might use this in any of the steps of downstream analysis, we can add a slot in the metadata to label cells that express only VGAT, only VGluT2, or a mixture or both. Similarly, we can also add the ratio of both transporters in each cell.
```{r}
# Add a label to the metadata indicating whether a cell expresses only VGAT, only VGluT2, or both:
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGAT" & PAG_sceset$subsets_VGAT_sum > 0 & PAG_sceset$subsets_VGluT2_sum == 0))] <- "VGAT_Cre_VGAT_only"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGAT" & PAG_sceset$subsets_VGAT_sum == 0 & PAG_sceset$subsets_VGluT2_sum > 0))] <- "VGAT_Cre_VGluT2_only"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGAT" & PAG_sceset$subsets_VGAT_sum > 0 & PAG_sceset$subsets_VGluT2_sum > 0))] <- "VGAT_Cre_both"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGAT" & PAG_sceset$subsets_VGAT_sum == 0 & PAG_sceset$subsets_VGluT2_sum == 0))] <- "VGAT_Cre_neither"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGluT2" & PAG_sceset$subsets_VGluT2_sum > 0 & PAG_sceset$subsets_VGAT_sum == 0))] <- "VGluT2_Cre_VGluT2_only"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGluT2" & PAG_sceset$subsets_VGluT2_sum == 0 & PAG_sceset$subsets_VGAT_sum > 0))] <- "VGluT2_Cre_VGAT_only"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGluT2" & PAG_sceset$subsets_VGluT2_sum > 0 & PAG_sceset$subsets_VGAT_sum > 0))] <- "VGluT2_Cre_both"
PAG_sceset$VGAT_VGluT2_expression[(which(PAG_sceset$cell.type == "VGluT2" & PAG_sceset$subsets_VGluT2_sum == 0 & PAG_sceset$subsets_VGAT_sum == 0))] <- "VGluT2_Cre_neither"
PAG_sceset$VGAT_VGluT2_expression <- factor(PAG_sceset$VGAT_VGluT2_expression,
                                            levels = c("VGAT_Cre_VGAT_only", "VGAT_Cre_VGluT2_only", "VGAT_Cre_both", "VGAT_Cre_neither",
                                                       "VGluT2_Cre_VGluT2_only", "VGluT2_Cre_VGAT_only", "VGluT2_Cre_both", "VGluT2_Cre_neither"))
levels(PAG_sceset$VGAT_VGluT2_expression)
table(PAG_sceset$VGAT_VGluT2_expression)
table(PAG_sceset$VGAT_VGluT2_expression, PAG_sceset$PAG.areacollection)

# Add the ratio of VGluT2 over VGAT in VGAT cells, and VGAT over VGluT2 in VGluT2 cells:
PAG_sceset$VGAT_VGluT2_ratio <- (PAG_sceset$log2_total_counts_VGAT / PAG_sceset$log2_total_counts_VGluT2)
PAG_sceset$VGluT2_VGAT_ratio <- (PAG_sceset$log2_total_counts_VGluT2 / PAG_sceset$log2_total_counts_VGAT)
```

Subsetting the `SingleCellExperiment` object by column will retain only the high-quality cells that pass each of the filters described above. We examine the number of cells removed by each filter as well as the total number of retained cells. Current practices focus on three main QC metrics (library size, gene detection, and percentage of reads in Mitochondrial genes). According to this strategy, removal of a substantial proportion of cells (> 10%) may be indicative of an overall issue with data quality. We are however being extra stringent, as a cell needs to fail in any of our 11 filters to be excluded. Despite our filtering strategy, we only end up excluding 13% of our cells, suggesting we overall have a high quality dataset:
```{r}
PAG_sceset$manual_filters <- !(
    # Sufficient library size
    PAG_sceset$filter_by_total_counts_manual |
    # Sufficient genes detected
    PAG_sceset$filter_by_expr_features_manual |
    # Remove cells with unusual proportion of reads the top 100 genes
    PAG_sceset$filter_by_percent_top_100_manual |
    # Remove cells with unusual proportion of reads in ERCCs
    PAG_sceset$filter_by_pct_ERCC_manual |
    # Remove cells with unusual proportion of reads in Mitochondrial genes
    PAG_sceset$filter_by_pct_Mitochondrial_manual |
    # Remove cells with unusual proportion of reads in Ribosomal genes
    PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual |
    PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual |
    # Remove cells with unusual proportion of reads in TSO concatamers
    PAG_sceset$filter_by_pct_TSO_concatamer_manual |
    # Remove cells from the Aqueduct Ependymal layer
    PAG_sceset$filter_AQ_cells |
    # Remove cells from patch-seq
    PAG_sceset$filter_patchseq_cells |
    # Remove cells from male mice expressing Xist
    #PAG_sceset$filter_by_wrong_Xist_in_males |
    # Remove EYFP cells expressing tdTomato
    PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells |
    # Remove tdTomato cells expressing EYFP
    PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells |   
    # Remove VGAT cells expressing only VGluT2
    PAG_sceset$filter_by_wrong_transporter_VGAT_cells |    
    # Remove VGluT2 cells expressing only VGAT
    PAG_sceset$filter_by_wrong_transporter_VGluT2_cells
    )

data.frame(ByLibSize = sum(PAG_sceset$filter_by_total_counts_manual), 
           ByExprFeatures = sum(PAG_sceset$filter_by_expr_features_manual), 
           ByPercentTop100 = sum(PAG_sceset$filter_by_percent_top_100_manual),
           ByERCC = sum(PAG_sceset$filter_by_pct_ERCC_manual), 
           ByMitochondrial = sum(PAG_sceset$filter_by_pct_Mitochondrial_manual), 
           ByRibosomalVGAT = sum(PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual),
           ByRibosomalVGluT2 = sum(PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual),
           ByTSOconcatamer = sum(PAG_sceset$filter_by_pct_TSO_concatamer_manual),
           ByAqueduct = sum(PAG_sceset$filter_AQ_cells),
           ByPatchseqRecorded = sum(PAG_sceset$filter_patchseq_cells),
           #ByXist = sum(PAG_sceset$filter_by_wrong_Xist_in_males),
           ByWrongFlurorophorEYFP = sum(PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells),
           ByWrongFlurorophortdTomato = sum(PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells),
           ByWrongTransporterVGAT = sum(PAG_sceset$filter_by_wrong_transporter_VGAT_cells),
           ByWrongTransporterVGluT2 = sum(PAG_sceset$filter_by_wrong_transporter_VGluT2_cells),
           Remaining = sum(PAG_sceset$manual_filters)
           )
table(PAG_sceset$manual_filters)
table(PAG_sceset$manual_filters, PAG_sceset$PAG.arearegistration)
table(PAG_sceset$manual_filters, PAG_sceset$cell.type)
```

Inspect the cells excluded by each filter. Are there cells that consistently fail the filters?
```{r}
plyr::ldply(list(ByLibSize = colnames(PAG_sceset[, PAG_sceset$filter_by_total_counts_manual]),
                 ByExprFeatures = colnames(PAG_sceset[, PAG_sceset$filter_by_expr_features_manual]),
                 ByPercentTop100 = colnames(PAG_sceset[, PAG_sceset$filter_by_percent_top_100_manual]),
                 ByERCC = colnames(PAG_sceset[, PAG_sceset$filter_by_pct_ERCC_manual]),
                 ByMitochondrial = colnames(PAG_sceset[, PAG_sceset$filter_by_pct_Mitochondrial_manual]),
                 ByRibosomalVGAT = colnames(PAG_sceset[, PAG_sceset$filter_by_pct_Ribosomal_VGAT_manual]),
                 ByRibosomalVGluT2 = colnames(PAG_sceset[, PAG_sceset$filter_by_pct_Ribosomal_VGluT2_manual]),
                 ByTSOconcatamer = colnames(PAG_sceset[, PAG_sceset$filter_by_pct_TSO_concatamer_manual]),
                 ByAqueduct = colnames(PAG_sceset[, PAG_sceset$filter_AQ_cells]),
                 ByPatchseqRecorded = colnames(PAG_sceset[, PAG_sceset$filter_patchseq_cells]),
                 #ByXist = colnames(PAG_sceset[, PAG_sceset$filter_by_wrong_Xist_in_males]),
                 ByWrongFlurorophorEYFP = colnames(PAG_sceset[, PAG_sceset$filter_by_wrong_flurorophor_EYFP_cells]),
                 ByWrongFlurorophortdTomato = colnames(PAG_sceset[, PAG_sceset$filter_by_wrong_flurorophor_tdTomato_cells]),
                 ByWrongTransporterVGAT = colnames(PAG_sceset[, PAG_sceset$filter_by_wrong_transporter_VGAT_cells]),
                 ByWrongTransporterVGluT2 = colnames(PAG_sceset[, PAG_sceset$filter_by_wrong_transporter_VGluT2_cells])
                 ), 
            rbind)
```

### 2.4.2 | Using MADs filters
An outlier-based definition for low-quality cells assumes that most cells are of high quality and that the QC metrics are independent of the biological state of each cell. This ensures that any outlier values for these metrics are driven by technical factors rather than biological processes. Thus, removing cells based on the metrics will not misrepresent the biology in downstream analyses.

The second assumption is most likely to be violated in highly heterogeneous cell populations. For example, some cell types may naturally have less RNA or express fewer genes than other cell types. Such cell types are more likely to be considered outliers and removed, even if they are of high quality. The use of the MAD mitigates this problem by accounting for biological variability in the QC metrics. A heterogeneous population should have higher variability in the metrics among high-quality cells, increasing the MAD and reducing the chance of incorrectly removing particular cell types (at the cost of reducing power to remove low-quality cells). Nonetheless, filtering based on outliers may not be appropriate in extreme cases where one cell type is very different from the others.

Systematic differences in the QC metrics can be handled to some extent using the `batch =` argument in the `isOutlier()` function. For example, setting `batch` to the plate of origin will identify outliers within each level of batch, using plate-specific median and MAD estimates. This is obviously useful for accommodating known differences in experimental processing, e.g., sequencing at different depth or different amounts of added spike-in RNA. We can also include biological factors in `batch`, if those factors could result in systematically fewer expressed genes or lower RNA content. However, this is not applicable in experiments where the factors are not known in advance.

* In our case, we could add either the `mouse.id` or the `cell.type` (e.g. `batch = PAG_sceset$mouse.id`) as an argument that specifies the batch to which each sample belongs. A median/MAD is calculated for each batch, and outliers are then identified within each batch.

Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells. A 3-MAD threshold has a fairly simple interpretation for normal distributions, enabling the removal of points with lower than 1% likelihood. 
* The default MAD threshold in the `isOutlier()` function is set to `nmads = 3`. 
* We begin by removing cells with log-library sizes that are more than 4 MADs below the median log-library size. A log-transformation improves resolution at small values, especially when the MAD of the raw values is comparable to or greater than the median. We also remove cells where the log-transformed number of expressed genes is 4 MADs below the median value.
* However, if the 4-MAD threshold is too restrictive or not restrictive enough, we can try to loosen it a bit by setting it to 5 or 3.
```{r}
# Total counts
PAG_sceset$filter_by_total_counts_MADs <- isOutlier(PAG_sceset$total, nmads = 5, type = "both", log = TRUE, batch = NULL)
table(PAG_sceset$filter_by_total_counts_MADs)
attr(PAG_sceset$filter_by_total_counts_MADs, "thresholds")

# Expressed features
PAG_sceset$filter_by_expr_features_MADs <- isOutlier(PAG_sceset$detected, nmads = 5, type = "both", log = TRUE, batch = NULL)
table(PAG_sceset$filter_by_expr_features_MADs)
attr(PAG_sceset$filter_by_expr_features_MADs, "thresholds")
```

We identify outliers for the proportion-based metrics in a similar manner. Here, no transformation is required as we are identifying large outliers, for which the distinction should be fairly clear on the raw scale.
```{r}
# ERCCs
PAG_sceset$filter_by_pct_ERCC_MADs <- isOutlier(PAG_sceset$altexps_ERCC_percent, nmads = 5, type = "higher", batch = NULL)
table(PAG_sceset$filter_by_pct_ERCC_MADs)
attr(PAG_sceset$filter_by_pct_ERCC_MADs, "thresholds")

# Mitochondrial genes
PAG_sceset$filter_by_pct_Mitochondrial_MADs <- isOutlier(PAG_sceset$subsets_Mitochondrial_percent, nmads = 5, type = "higher", batch = NULL)
table(PAG_sceset$filter_by_pct_Mitochondrial_MADs)
attr(PAG_sceset$filter_by_pct_Mitochondrial_MADs, "thresholds")

# Ribosomal genes
PAG_sceset$filter_by_pct_Ribosomal_MADs <- isOutlier(PAG_sceset$subsets_Ribosomal_percent, nmads = 5, type = "higher", batch = NULL)
table(PAG_sceset$filter_by_pct_Ribosomal_MADs)
attr(PAG_sceset$filter_by_pct_Ribosomal_MADs, "thresholds")

# TSO concatamers
PAG_sceset$filter_by_pct_TSO_concatamer_MADs <- isOutlier(PAG_sceset$subsets_TSO_concatamers_percent, nmads = 5, type = "higher", batch = NULL)
table(PAG_sceset$filter_by_pct_TSO_concatamer_MADs)
attr(PAG_sceset$filter_by_pct_TSO_concatamer_MADs, "thresholds")
```

Subsetting by column will retain only the high-quality cells that pass each filter described above. We examine the number of cells removed by each filter as well as the total number of retained cells. Removal of a substantial proportion of cells (> 10%) may be indicative of an overall issue with data quality.
```{r}
# Create a subset of the PAG_sceset with the cells that pass the MADs filters:
PAG_sceset$MADs_filters <- !(
    # Sufficient library size
    PAG_sceset$filter_by_total_counts_MADs |
    # Sufficient genes detected
    PAG_sceset$filter_by_expr_features_MADs |
    # Remove cells with unusual proportion of reads in ERCCs
    PAG_sceset$filter_by_pct_ERCC_MADs |
    # Remove cells with unusual proportion of reads in Mitochondrial genes
    PAG_sceset$filter_by_pct_Mitochondrial_MADs |
    # Remove cells with unusual proportion of reads in Ribosomal genes
    PAG_sceset$filter_by_pct_Ribosomal_MADs |
    # Remove cells with unusual proportion of reads in TSO concatamers
    PAG_sceset$filter_by_pct_TSO_concatamer_MADs
)

data.frame(ByLibSize=sum(PAG_sceset$filter_by_total_counts_MADs), 
           ByExprFeatures=sum(PAG_sceset$filter_by_expr_features_MADs), 
           ByERCC=sum(PAG_sceset$filter_by_pct_ERCC_MADs), 
           ByMitochondrial=sum(PAG_sceset$filter_by_pct_Mitochondrial_MADs), 
           ByRibosomal=sum(PAG_sceset$filter_by_pct_Ribosomal_MADs),
           ByTSOconcatamer=sum(PAG_sceset$filter_by_pct_TSO_concatamer_MADs),
           Remaining=sum(PAG_sceset$MADs_filters)
           )

table(PAG_sceset$MADs_filters, PAG_sceset$PAG.arearegistration)
table(PAG_sceset$MADs_filters, PAG_sceset$cell.type)
```

### 2.4.3 | Using Automatic cell filtering in scater
Another option available in `scater` is to filter cells using the `runColDataPCA()` function with `outliers = TRUE`. This performs PCA based on a set of QC metrics and then uses automatic outlier detection to identify potentially problematic cells. Outliers on a PCA plot may be indicative of low-quality cells that have aberrant technical properties compared to the (presumed) majority of high-quality cells.

`scater` first creates a matrix where the rows represent cells and the columns represent the different QC metrics. Here, the PCA plot provides a 2D representation of cells ordered by their quality metrics. The outliers are then detected using methods from the `mvoutlier` package. This will identify cells that have substantially different QC metrics from the others, possibly corresponding to low-quality cells.
```{r}
library(scater)
library(sgeostat)
library(mvoutlier)
set.seed(1991)
PAG_sceset <- runColDataPCA(PAG_sceset, outliers = TRUE,
                            variables = list("sum", "detected", "altexps_ERCC_percent", "subsets_Mitochondrial_percent", 
                                             "subsets_Ribosomal_percent", "subsets_TSO_concatamers_percent"),
                            name = "PCA_coldata")
plotReducedDim(PAG_sceset, dimred = "PCA_coldata", colour_by = "outlier", shape_by = "PAG.areacollection")
table(PAG_sceset$outlier)

PAG_sceset$PCA_filters <- !PAG_sceset$outlier
table(PAG_sceset$PCA_filters, PAG_sceset$PAG.arearegistration)
```

Methods like PCA-based outlier detection and support vector machines can provide more power to distinguish low-quality cells from high-quality counterparts (Ilicic et al. 2016). This is because they are able to detect subtle patterns across many quality metrics simultaneously. However, this comes at some cost to interpretability, as the reason for removing a given cell may not always be obvious.

### 2.4.4 | Compare filtering strategies
Before deciding on a filtering strategy, we can use the `limma` package to plot a Venn diagram of the outlier cells from the different filtering approaches we have used.
```{r}
library(limma)
Manual <- colnames(PAG_sceset)[!PAG_sceset$manual_filters]
MADs <- colnames(PAG_sceset)[!PAG_sceset$MADs_filters]
PCA_based <- colnames(PAG_sceset)[PAG_sceset$outlier]

venn.diag <- vennCounts(cbind(colnames(PAG_sceset) %in% Manual,
                              colnames(PAG_sceset) %in% MADs,
                              colnames(PAG_sceset) %in% PCA_based))

vennDiagram(venn.diag,
            names = c("Manual", "MADs", "PCA_based"),
            circle.col = c("#E69F00", "#56B4E9", "#009E73"))
```

### 2.4.5 | Apply chosen cell filtering approach
After comparing the different filtering strategies, we can see that the Manual filter is the most flexible and allows us to add custom filters based on our experimental design (including the identity of the cells and the fluorophors they should express). We will prime knowing why we remove each cell and will thus apply the manual filter over the MADs and the PCA based filters.
```{r}
# Set the chosen filter as the "use" slot:
PAG_sceset$use <- PAG_sceset$manual_filters
table(PAG_sceset$use, PAG_sceset$PAG.arearegistration)
dim(PAG_sceset)
PAG_sceset
```

Once we have applied our cell filter, we can quickly inspect the distribution of our QC metrics:
```{r}
gridExtra::grid.arrange(plotColData(PAG_sceset, x = "cell.type", y = "total", colour_by = "use") + 
                          labs(title = "Library size", x = NULL, y = "total counts"),
                        plotColData(PAG_sceset, x = "cell.type", y = "detected", colour_by = "use") + 
                          ggtitle("Detected genes") + xlab(NULL) + ylab("number of genes detected"), # Alternative way of adding plot labels
                        plotColData(PAG_sceset, x = "cell.type", y = "subsets_Mitochondrial_percent", colour_by = "use") + 
                          labs(title = "Percent reads in Mitochondrial genes", x = NULL, y = "% reads in mitochondrial genes"),
                        plotColData(PAG_sceset, x = "cell.type", y = "subsets_Ribosomal_percent", colour_by = "use") + 
                          labs(title = "Percent reads in Ribosomal genes", x = NULL, y = "% reads in ribosomal genes"),
                        plotColData(PAG_sceset, x = "cell.type", y = "altexps_ERCC_percent", colour_by = "use") + 
                          labs(title = "Percent reads in ERCC spike-ins", x = NULL, y = "% reads in ERCC spike-ins"),
                        plotColData(PAG_sceset, x = "cell.type", y = "subsets_TSO_concatamers_percent", colour_by = "use") + 
                          labs(title = "Percent reads in TSO concatamers", x = NULL, y = "% reads in TSO concatamers"),
                        plotColData(PAG_sceset, x = "cell.type", y = "percent_top_100", colour_by = "use") + 
                          labs(title = "Percent reads in top 100 genes", x = NULL, y = "% reads in top 100 genes"),
                        plotColData(PAG_sceset, x = "cell.fluorophor", y = "log2_total_counts_EYFP", colour_by = "use") + 
                          labs(title = "EYFP expression", x = NULL, y = "log2 raw expression"),
                        plotColData(PAG_sceset, x = "cell.fluorophor", y = "log2_total_counts_tdTomato", colour_by = "use") + 
                          labs(title = "tdTomato expression", x = NULL, y = "log2 raw expression"))

# Plot the violin plots for the VGAT-VGluT2 expression separately
gridExtra::grid.arrange(plotColData(PAG_sceset, x = "cell.type", y = "log2_total_counts_VGAT", colour_by = "use") + 
                          labs(title = "VGAT expression", x = NULL, y = "log2 raw expression"),
                        plotColData(PAG_sceset, x = "cell.type", y = "log2_total_counts_VGluT2", colour_by = "use") + 
                          labs(title = "VGluT2 expression", x = NULL, y = "log2 raw expression"),
                        ncol = 2)
```

## Step 2.5 | Gene QC
In addition to removing cells with poor quality, it is usually a good idea to exclude genes where we suspect that technical artefacts may have skewed the results, or genes that are not informative (have a lot of 0 in many cells). The optimal choice of filtering strategy depends on the downstream application, and the best practice is to filter at each step as needed, rather than applying a single filter for the entire analysis. We will see different filtering options, but in the end we will only remove the genes that are not expressed in any cell, as they don't provide any information and would be removed by any filtering strategy. This will ensure that the most appropriate filter is used in each type of analysis and we don't remove now genes that we might need later if we do DE analysis, for example.

_NB_: keep in mind that genes must be filtered after cell filtering since some genes may only be detected in poor quality cells. Use `PAG_sceset[ , colData(PAG_sceset)$use]` to select only the filtered cells. Here we will apply the filters both in the whole dataset and after filtering low quality cells to assess its impact.

### 2.5.1 | Filtering low-abundance genes
Low-abundance genes are problematic as zero or near-zero counts do not contain enough information for reliable statistical inference (Bourgon et al. 2010) and are likely to be dominated by drop-out events (Brennecke et al. 2013), which limits their usefulness in later analyses. Several metrics can be used to define low-abundance genes, one being the average count for each gene computed across all cells in the dataset. We can calculate this using the `calcAverage()` function, which can also perform some adjustment for library size differences between cells.
```{r}
library(scater)
# We can define low-abundance genes as those with an average count below a filter threshold of 1, as they are likely to be dominated by drop-out events.
all_ave_counts <- calculateAverage(PAG_sceset)
summary(all_ave_counts)

# Do the same using the filtered cells:
use_ave_counts <- calculateAverage(PAG_sceset[ , colData(PAG_sceset)$use])
summary(use_ave_counts)
```

We can check whether a chosen threshold would be suitable by examining the distribution of log-mean counts across all genes. The peak represents the bulk of moderately expressed genes while the rectangular component corresponds to lowly expressed genes. The filter threshold should cut the distribution at some point along the rectangular component to remove the majority of low-abundance genes.
```{r}
# Using the whole dataset:
hist(log10(all_ave_counts),
     breaks = 200,
     main = "", 
     col = "grey80", 
     xlab = expression(Log[10]~"average count (all)"),
     xlim = c(-10,10))
abline(v = 1, col = "blue", lwd = 2, lty = 2)

# After removing low-quality cells:
hist(log10(use_ave_counts), 
     breaks = 200,
     main = "", 
     col = "grey80", 
     xlab = expression(Log[10]~"average count (use)"),
     xlim = c(-10,10))
abline(v = 1, col = "blue", lwd = 2, lty = 2)
```

After looking at the histograms we could apply a minimum threshold to this average to filter out genes that are lowly expressed, and see how many genes we would be left with.
```{r}
filter_low_abundance_genes_all <- all_ave_counts >= 1 
summary(filter_low_abundance_genes_all)

filter_low_abundance_genes_use <- use_ave_counts >= 1 
summary(filter_low_abundance_genes_use)
```

### 2.5.2 | Filtering uninteresting genes
An alternative approach to gene filtering is to select genes that have non-zero counts in at least n cells. This provides some more protection against genes with outlier expression patterns, i.e., strong expression in only one or two cells. Such outliers are typically uninteresting as they can arise from amplification artifacts that are not replicable across cells. (The exception is for studies involving rare cells where the outliers may be biologically relevant.) We can thus have a look at the number of cells expressing each gene.
```{r}
# Count the number of non-zero counts (or any value set by the detection_limit) in each row (per feature) or column (per cell). With byrow=TRUE we count the number of cells that express each gene more than certain number of times.
all_numcells <- nexprs(PAG_sceset, detection_limit = 0, byrow = TRUE) 
summary(all_numcells)

# Same after removing low-quality cells:
use_numcells <- nexprs(PAG_sceset[ , colData(PAG_sceset)$use], detection_limit = 0, byrow = TRUE)
summary(use_numcells)
```

The number of cells expressing each gene is usually well-correlated to the average expression of each gene, as expression in many cells will result in a higher average.
```{r}
# Plot the number of expressing cells against the log-mean expression for each gene in the dataset.
smoothScatter(log10(all_ave_counts), 
              all_numcells, 
              xlab = expression(Log[10]~"average count"), 
              ylab = "Number of expressing cells",
              xlim = c(-2,5))
#control_features_all <- isSpike(PAG_sceset[ , colData(PAG_sceset)$use]) # isSpike is deprecated
#points(log10(use_ave_counts[control_features_all]), use_numcells[control_features_all], col = "red", pch = 16, cex = 0.5)

# After removing low-quality cells:
smoothScatter(log10(use_ave_counts), 
              use_numcells, 
              xlab = expression(Log[10]~"average count"), 
              ylab = "Number of expressing cells",
              xlim = c(-2,5))
#control_features_use <- isSpike(PAG_sceset[ , colData(PAG_sceset)$use]) # isSpike is deprecated
#points(log10(use_ave_counts[control_features_use]), use_numcells[control_features_use], col = "red", pch = 16, cex = 0.5)
```

As we already mentioned, genes expressed in very few cells are often uninteresting as they might be driven by amplification artifacts (though they may also also arise from rare populations). We could thus remove genes that are expressed in fewer than n cells. 
```{r}
# Filter the genes not expressed in at least n cells
filter_low_abundance_genes_alternative_all <- all_numcells >= 5
summary(filter_low_abundance_genes_alternative_all)

filter_low_abundance_genes_alternative_use <- use_numcells >= 5
summary(filter_low_abundance_genes_alternative_use)
```

### 2.5.3 | Identities of the most highly expressed genes
It is often instructive to consider the number of reads consumed by the top 50 expressed genes. This should generally be dominated by constitutively expressed transcripts, such as those for ribosomal or mitochondrial proteins, Malat1, or actin. The presence of other classes of features may be cause for concern if they are not consistent with expected biology. Many spike-in transcripts in the top most expressed genes suggests that too much spike-in RNA was added during library preparation, while the absence of ribosomal proteins and/or the presence of pseudogenes are indicative of suboptimal alignment.
```{r}
# Plot the total counts consumed by the top 50 expressed genes in the whole dataset and after filtering low quality cells:
plotHighestExprs(PAG_sceset, n = 50, colour_cells_by = "cell.type", exprs_values = "counts")
plotHighestExprs(PAG_sceset[ , colData(PAG_sceset)$use], n = 50, colour_cells_by = "cell.type", exprs_values = "counts")
```

### 2.5.4 | Apply chosen gene-filtering approach
In general, the mean-based filter tends to be less aggressive. A gene will be retained as long as it has sufficient expression in any subset of cells. Genes expressed in fewer cells require higher levels of expression in those cells to be retained, but this is not undesirable as it avoids selecting uninformative genes (with low expression in few cells) that contribute little to downstream analyses such as HVG detection or clustering.

In contrast, the "at least n" filter depends heavily on the choice of `n`. With `n = 10`, a gene expressed in a subset of 9 cells would be filtered out, regardless of the level of expression in those cells. This may result in the failure to detect rare subpopulations that are present at frequencies below `n`.

The safest option will be to apply these filters at each step rather than applying them globally by subsetting the `SingleCellExperiment` object. This ensures that the most appropriate filter is used in each application. For now, we only remove genes that are expressed in less than 1% of the cells to reduce computational work in downstream steps. Genes not detected in any cell provide no information and would be removed by any filtering strategy. We thus use the result from the `nexprs` function with a `detection_limit = 0` and `num_cells > 3`. Note that the `detection_limit` is a numeric scalar providing the value above which observations are deemed to be expressed. We will also remove all predicted genes from the dataset, which can be identified by starting with "Gm" (Gene model). 
```{r}
# Set the filter with the chosen parameters:
use_numcells <- nexprs(PAG_sceset[ , colData(PAG_sceset)$use], detection_limit = 0, byrow = TRUE) # `byrow=TRUE` - count the number of detected cells per feature
rowData(PAG_sceset)$genes_expressed <- use_numcells > 3 # This will leave genes expressed in less than X number of cells as FALSE
summary(rowData(PAG_sceset)$genes_expressed)

# Find predicted genes (Gm stands for gene model)
rowData(PAG_sceset)$not_predicted_gene <- !grepl("^Gm", rownames(PAG_sceset)) # This will leave predicted genes as FALSE
summary(rowData(PAG_sceset)$not_predicted_gene)
```

We next add the list of genes to use to a slow in our `rowData` so that we can subset the current `SingleCellExperiment` object to generate the QCed one:
```{r}
# Assign the chosen list of filtered genes to $use slot corresponding to the rows (genes):
rowData(PAG_sceset)$use <- (rowData(PAG_sceset)$genes_expressed & rowData(PAG_sceset)$not_predicted_gene) 
# We will keep only the genes that are both expressed in at least X cells and NOT predicted genes.
table(rowData(PAG_sceset)$use)
dim(PAG_sceset) # We haven't changed anything in the SingleCellExperiment object yet.
```

Now, the `colData(PAG_sceset)$use` should point to the _samples_ that have passed our QC, whereas the `rowData(PAG_sceset)$use` should point to the _genes_ that have passed our QC.

## Step 2.6 | Save the QCed SingleCellExperiment object
We have now QCed our dataset. Before we proceed to normalization and downstream analyis, we save our progress.
```{r}
# We could remove the saved PCA results from the reducedDim slot, but we can also just keep them in the reducedDim slot:
PAG_sceset # Full dataset containing all the filters

# Save the dataset with the filters before applying them:
saveRDS(PAG_sceset, file = "PAG_sceset_filters.rds")
```

Once everything we have done is saved, we use the `PAG_sceset$use` slot, which points to the filtered and QCed data, to set the dimensions of a new `SingleCellExperiment` object, which we will call `PAG_sceset_qc` and use for downstream analysis. 
```{r}
# Use the filtered dataset to set the dimensions of a QCed dataset:
PAG_sceset_qc <- PAG_sceset[rowData(PAG_sceset)$use, colData(PAG_sceset)$use]
dim(PAG_sceset)
dim(PAG_sceset_qc)
PAG_sceset_qc # QCed dataset
table(PAG_sceset_qc$PAG.arearegistration)

# Save the filtered and QCed dataset:
saveRDS(PAG_sceset_qc, file = "PAG_sceset_qc.rds")
print("Part 2 - Done!")
```

_IMP_: once we have filtered out low-quality cells and stored the resulting dataset into a QCed one, we continue to use the QCed for the following steps.

```{r}
sessionInfo()
```
---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Part VIII: seurat"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***
This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al. Nature Protocols 2014). 

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/release/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/release/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/release/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources are Bioconductor (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarty et al., Bioinformatics 2017), `scran` (Lun et al. F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008).

***

# STEP 12 | Seurat
[Seurat](https://satijalab.org/seurat/) is an R package designed for QC, analysis, and exploration of single-cell RNA-seq data. Seurat aims to enable users to identify and interpret sources of heterogeneity from single-cell transcriptomic measurements, and to integrate diverse types of single-cell data. For more info see Butler et al. 2018 and Stuart, Butler et al. 2018.

_IMP:_ Before starting this, run Part I again.

Setting up a Seurat object:
```{r}
library(Seurat)
library(dplyr)
PAG_seurat <- CreateSeuratObject(counts = PAG_data,
                                 project = "PAG_seurat_analysis",
                                 min.cells = 1,
                                 min.features = 2000,
                                 meta.data = PAG_metadata)
```

## Step 12.1 | Pre-processing, data QC and normalization
Selection and filtration of cells based on QC metrics, data normalization and scaling, and detection of highly variable features.
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
PAG_seurat[["percent.mt"]] <- PercentageFeatureSet(PAG_seurat, pattern = "^MT-")
PAG_seurat[["percent.ercc"]] <- PercentageFeatureSet(PAG_seurat, pattern = "^ERCC-")
head(PAG_seurat@meta.data, 5) # Metadata for the first 5 cells
```

Visualize QC metrics using a violin plot:
```{r}
VlnPlot(PAG_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ercc"), ncol = 4)
```

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(PAG_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(PAG_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
```

Filter the dataset according to specific quality  metrics:
```{r}
PAG_seurat <- subset(PAG_seurat, subset = nFeature_RNA > 2000 & percent.mt < 5)
```

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method `LogNormalize` that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in `SeuratObject[["RNA"]]@data`.
```{r}
PAG_seurat <- NormalizeData(PAG_seurat, normalization.method = "LogNormalize", scale.factor = 10000)
PAG_seurat <- NormalizeData(PAG_seurat)
```

## Step 12.2 | Feature selection: identify highly variable features
The next step consists on calculating a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. Seurat directly models the mean-variance relationship inherent in single-cell data and implements in in the `FindVariableFeatures` function, returning 2000 features per dataset by default.
```{r}
PAG_seurat <- FindVariableFeatures(PAG_seurat, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(PAG_seurat), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(PAG_seurat)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1, plot2))
```

## Step 12.3 | Scaling the data, peforming dimensionality reduction and determining the dimensionality of the dataset
Linear transformation (scaling) is a standard pre-processing step prior to dimensionality reduction techniques like PCA. The `ScaleData` function:

* Shifts the expression of each gene, so that the mean expression across cells is 0
* Scales the expression of each gene, so that the variance across cells is and highly-expressed genes do not dominate
* Stores the resuts in `SeuratObject[["RNA"]]@scale.data`
```{r}
all.genes <- rownames(PAG_seurat)
PAG_seurat <- ScaleData(PAG_seurat, features = all.genes)

# Scaling is an essential step in the Seurat workflow, but only on genes that will be used as input to PCA. To speed things up, the default in  ScaleData is only to perform scaling on the previously identified variable features (2,000 by default). To do this, omit the  features argument in the previous function call.
```

We can now perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using `features` argument if you wish to choose a different subset.
```{r}
PAG_seurat <- RunPCA(PAG_seurat, features = VariableFeatures(object = PAG_seurat))
```

Seurat provides several useful ways of visualizing both cells and features that define the PCA, including `VizDimReduction`, `DimPlot`, and `DimHeatmap`.
```{r}
# Examine and visualize PCA results a few different ways
print(PAG_seurat[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(PAG_seurat, dims = 1:2, reduction = "pca")
DimPlot(PAG_seurat, reduction = "pca")
```

`DimHeatmap` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting cells to a number plots the extreme cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, this is a valuable tool for exploring correlated feature sets.
```{r}
DimHeatmap(PAG_seurat, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(PAG_seurat, dims = 1:15, cells = 500, balanced = TRUE)
```

To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a metafeature that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100?

In Macosko et al, they implemented a resampling test inspired by the JackStraw procedure. They randomly permuted a subset of the data (1% by default) and rerun PCA, constructing a null distribution of feature scores, and repeat this procedure. They then identify significant PCs as those with a strong enrichment of low p-value features.
```{r}
# NOTE: This process can take a long time for big datasets.
# Other techniques such as those implemented in ElbowPlot() can be used to reduce computation time
PAG_seurat <- JackStraw(PAG_seurat, num.replicate = 100)
PAG_seurat <- ScoreJackStraw(PAG_seurat, dims = 1:20)
```

The `JackStrawPlot` function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). Significant PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line).
```{r}
JackStrawPlot(PAG_seurat, dims = 1:15)
```

An alternative heuristic method generates an `Elbow plot`: a ranking of principle components based on the percentage of variance explained by each one (`ElbowPlot` function). The elbow suggests a point by which the majority of true signal is captured.
```{r}
ElbowPlot(PAG_seurat)
```

Identifying the true dimensionality of a dataset can be challenging/uncertain for the user. It is therefore a good idea to try the three different methods described above. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff. The third is a heuristic that is commonly used, and can be calculated instantly. It is also good practice to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). Although the results often do not differ dramatically, it is best to err on the higher side when choosing this parameter.

## Step 12.4 | Clustering
Seurat v3 applies a graph-based clustering approach. It first constructs a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors` function, and takes as input the previously defined dimensionality of the dataset.

To cluster the cells, Seurat next applies modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters` function implements this procedure, and contains a resolution parameter that sets the "granularity" of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the `Idents` function.
```{r}
PAG_seurat <- FindNeighbors(PAG_seurat, dims = 1:10)
PAG_seurat <- FindClusters(PAG_seurat, resolution = 0.5)
head(Idents(PAG_seurat), 5) # Look at cluster IDs of the first 5 cells
```

## Step 12.5 | Non-linear dimensionality reduction (UMAP and t-SNE)
Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in a low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. Ideally use the same PCs input to the clustering analysis as input to the UMAP and tSNE.
```{r}
PAG_seurat <- RunTSNE(PAG_seurat, dims = 1:10)
DimPlot(PAG_seurat, reduction = "tsne")
```

You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.
```{r}
saveRDS(PAG_seurat, file = "../output/PAG_seurat_analysis.rds")
```

## Step 12.6 | Finding differentially expressed features (cluster biomarkers)
Seurat can help find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. `FindAllMarkers` automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

The `min.pct` argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the `thresh.test` argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, `max.cells.per.ident` can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top.
```{r}
# find all markers of cluster 1
cluster1.markers <- FindMarkers(PAG_seurat, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
```

```{r}
# find all markers distinguishing cluster 3 from clusters 0 and 2
cluster3.markers <- FindMarkers(PAG_seurat, ident.1 = 3, ident.2 = c(0, 1, 2), min.pct = 0.25)
head(cluster3.markers, n = 10)
```

```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
PAG_seurat.markers <- FindAllMarkers(PAG_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
PAG_seurat.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
```

Seurat has several tests for differential expression which can be set with the `test.use` parameter. For example, the ROC test returns the "classification power" for any individual marker (ranging from 0 - random, to 1 - perfect).
```{r}
cluster1.markers <- FindMarkers(PAG_seurat, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
```

There are several tools for visualizing marker expression. `VlnPlot` (shows expression probability distributions across clusters), and `FeaturePlot` (visualizes feature expression on a tSNE or PCA plot) are the most commonly used visualizations, but additional methods are `RidgePlot`, `CellScatter`, and `DotPlot`.
```{r}
VlnPlot(PAG_seurat, features = c("Sst", "Npy"))

# you can plot raw counts as well
VlnPlot(PAG_seurat, features = c("Sst", "Npy"), slot = "counts", log = TRUE)

FeaturePlot(PAG_seurat, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
    "CD8A"))
```

`DoHeatmap` generates an expression heatmap for given cells and features.
```{r}
top10 <- PAG_seurat.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(PAG_seurat, features = top10$gene) + NoLegend()
```

## Step 12.7 |Assigning cell type identity to clusters
Finally, we can rename/assign an identity to the clusters we have been able to identify based on the data.
```{r}
new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", 
                     "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(PAG_seurat)
PAG_seurat <- RenameIdents(PAG_seurat, new.cluster.ids)
DimPlot(PAG_seurat, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

Save the complete analysis:
```{r}
saveRDS(PAG_seurat, file = "../output/PAG_seurat_analysis_final.rds")
```
---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Part VII: differential expression analysis"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***

This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al., Nature Protocols 2014).

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://bioconductor.org/books/release/OSCA/) by Robert Amezquita, Aaron Lun, Stephanie Hicks, and Raphael Gottardo, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/3.10/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/3.10/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/3.10/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources include [Bioconductor](http://www.bioconductor.org/) (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarthy et al., Bioinformatics 2017), `scran` (Lun et al., F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `edgeR` (Robinson et al., Bioinformatics 2010), `MAST` (Finak, McDavid, Yajima et al., Genome Biology 2015), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008), `UMAP` (McInnes et al., arXiv 2018), and the [Mathematical Statistics and Machine Learning for Life Sciences](https://towardsdatascience.com/tagged/stats-ml-life-sciences) column by Nikolay Oskolkov.

***

# STEP 7 | Differential Expression Analysis
One of the most common types of analyses when working with bulk RNA-seq data is to identify differentially expressed genes. By comparing the genes that change between two conditions, e.g. mutant and wild-type or stimulated and unstimulated, it is possible to characterize the molecular mechanisms underlying the change. Several methods, e.g. `DESeq2` and `edgeR`, have been developed for bulk RNA-seq. 

In scRNA-seq we usually do not have a defined set of experimental conditions. Instead, we can identify the cell groups by using an unsupervised clustering approach. Once the groups have been identified one can find differentially expressed genes either by comparing the differences in variance between the groups (like the Kruskal-Wallis test implemented in `SC3`), or by comparing gene expression between clusters in a pairwise manner. In our case, in addition to clusters we have experimental conditions we can test, namely the cell type or PAG subdivision from where the cells were collected, which makes it possible for us to follow either approach.

We continue using the `PAG_sceset_qc_norm_filt_corr_clust` after normalisation, filtering, batch correction, and clustering. We should thus have a `corrected` slot in `assays`:
```{r}
# Set the directory where your data and scripts are:
setwd("D:/Dropbox (UCL - SWC)/Project_transcriptomics/analysis/PAG_scRNAseq_analysis")

# Set the path to save figures from this Part:
path_for_figures <- "D:/Dropbox (UCL - SWC)/Project_transcriptomics/figures/R_figures_Part7_DE/"
date <- Sys.Date()
date <- gsub("-", "_", date)

# Load packages:
library(tidyverse)
library(SingleCellExperiment)
library(scater)
library(scran)
library(ggplot2)
library(pheatmap)
library(DESeq2)
library(edgeR)
library(limma)
library(monocle)
library(MAST)
library(ROCR)
library(patchwork)
library(extrafont)
```

```{r}
# If starting from stored results, load saved filtered dataset from previous Step:
options(stringsAsFactors = FALSE)

PAG_sceset_qc_norm_filt_corr_clust <- readRDS("PAG_sceset_qc_norm_filt_corr_clust.rds") # Contains filtered cells and genes, log-normalised, filtered, corrected, and clustered data
assayNames(PAG_sceset_qc_norm_filt_corr_clust)
reducedDimNames(PAG_sceset_qc_norm_filt_corr_clust)
```

We first check we have the relevant metadata, making sure the key annotations are `factor`:
```{r}
# Check you have the relevant metadata as factors:
tail(colnames(colData(PAG_sceset_qc_norm_filt_corr_clust)))

class(PAG_sceset_qc_norm_filt_corr_clust$mouse.id)
class(PAG_sceset_qc_norm_filt_corr_clust$cell.type)
class(PAG_sceset_qc_norm_filt_corr_clust$PAG.area)
levels(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)
```

## Step 7.0 | Recap of clustering results
To remind ourselves about which clustering results we have available, we can look at the names of the `colData` slot:
```{r}
names(colData(PAG_sceset_qc_norm_filt_corr_clust)[grep("cluster", names(colData(PAG_sceset_qc_norm_filt_corr_clust)))])
```

If we wanted to export the cluster IDs of each cell in our dataset for a particuler clustering approach, we could do it as follows:
```{r}
#groups <- as.data.frame(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k5)
#rownames(groups) <- PAG_sceset_qc_norm_filt_corr_clust$cell.id
#groups
#write.csv(groups, file = str_c(path_for_figures, "SNN_clusters/", "cluster_ids.csv"), quote = FALSE, row.names = TRUE)
```

We can also replot the results of our chosen clustering solution before we attempt to find marker genes:
```{r}
# Set theme parameters
theme_args_SNN_clustering <- theme(plot.title = element_text(size = 11, face = "bold"),
                                   axis.title = element_text(size = 11, face = "plain"),
                                   axis.text = element_text(size = 10, face = "plain"), 
                                   legend.text = element_text(size = 9, face = "plain"), 
                                   strip.text = element_text(size = 10, face = "plain"))


### Using UMAP (CV2) - 15_neighbors_0.01_min_dist ###
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                  dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "PAG.area", shape_by = "cell.type",
                                                  point_alpha = 0.6, point_size = 2, theme_size = 11
                                                  ) + labs(title = "PAG subdivisions", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

# Using HVG from CV2 with rank-based weights
UMAP_cv2_15_001_RankWalktrap_k7 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                  dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "SNN_clusters_cv2_rank_k7", shape_by = "cell.type", text_by = "SNN_clusters_cv2_rank_k7",
                                                  point_alpha = 0.6, point_size = 2, theme_size = 11
                                                  ) + labs(title = "Rank-Walktrap (k = 7)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

UMAP_cv2_15_001_RankWalktrap_k12 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                  dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "SNN_clusters_cv2_rank_k12", shape_by = "cell.type", text_by = "SNN_clusters_cv2_rank_k12",
                                                  point_alpha = 0.6, point_size = 2, theme_size = 11
                                                  ) + labs(title = "Rank-Walktrap (k = 12)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

# Using HVG from CV2 with jaccard-based weights
UMAP_cv2_15_001_JaccardLouvain_k5 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                    dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                    colour_by = "SNN_clusters_cv2_jaccard_k5", shape_by = "cell.type", text_by = "SNN_clusters_cv2_jaccard_k5",
                                                    point_alpha = 0.6, point_size = 2, theme_size = 11
                                                    ) + labs(title = "Jaccard-Louvain (k = 5)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

UMAP_cv2_15_001_JaccardLouvain_k8 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                    dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                    colour_by = "SNN_clusters_cv2_jaccard_k8", shape_by = "cell.type", text_by = "SNN_clusters_cv2_jaccard_k8",
                                                    point_alpha = 0.6, point_size = 2, theme_size = 11
                                                    ) + labs(title = "Jaccard-Louvain (k = 8)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

UMAP_cv2_15_001_JaccardLouvain_k9 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                    dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                    colour_by = "SNN_clusters_cv2_jaccard_k9", shape_by = "cell.type", text_by = "SNN_clusters_cv2_jaccard_k9",
                                                    point_alpha = 0.6, point_size = 2, theme_size = 11
                                                    ) + labs(title = "Jaccard-Louvain (k = 9)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

UMAP_cv2_15_001_JaccardLouvain_k13 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, 
                                                    dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                    colour_by = "SNN_clusters_cv2_jaccard_k13", shape_by = "cell.type", text_by = "SNN_clusters_cv2_jaccard_k13",
                                                    point_alpha = 0.6, point_size = 2, theme_size = 11
                                                    ) + labs(title = "Jaccard-Louvain (k = 13)", x = "UMAP 1", y = "UMAP 2") + theme_args_SNN_clustering

# Prepare and save composed plots
library(patchwork)

UMAP_SNN_RankWalktrap_k7 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_RankWalktrap_k7) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_RankWalktrap_k7

UMAP_SNN_RankWalktrap_k12 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_RankWalktrap_k12) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_RankWalktrap_k12

UMAP_SNN_JaccardLouvain_k5 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_JaccardLouvain_k5) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_JaccardLouvain_k5

UMAP_SNN_JaccardLouvain_k8 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_JaccardLouvain_k8) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_JaccardLouvain_k8

UMAP_SNN_JaccardLouvain_k9 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_JaccardLouvain_k9) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_JaccardLouvain_k9

UMAP_SNN_JaccardLouvain_k13 <- (UMAP_cv2_15_001_PAGsubdivisions + UMAP_cv2_15_001_JaccardLouvain_k13) +
  plot_annotation(title = "Graph-based clustering on UMAP (CV2)", tag_levels = "A", 
                  theme = theme(plot.title = element_text(size = 12, face = "bold"), plot.tag = element_text(size = 11))) + 
  plot_layout(ncol = 2, guides = "collect")
UMAP_SNN_JaccardLouvain_k13

ggsave(filename = str_c(date, "_UMAP_SNN_rank_k7_clusters.pdf"),
       plot = UMAP_SNN_RankWalktrap_k7,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )

ggsave(filename = str_c(date, "_UMAP_SNN_rank_k12_clusters.pdf"),
       plot = UMAP_SNN_RankWalktrap_k12,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )

ggsave(filename = str_c(date, "_UMAP_SNN_jaccard_k5_clusters.pdf"),
       plot = UMAP_SNN_JaccardLouvain_k5,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )

ggsave(filename = str_c(date, "_UMAP_SNN_jaccard_k8_clusters.pdf"),
       plot = UMAP_SNN_JaccardLouvain_k8,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )

ggsave(filename = str_c(date, "_UMAP_SNN_jaccard_k9_clusters.pdf"),
       plot = UMAP_SNN_JaccardLouvain_k9,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )

ggsave(filename = str_c(date, "_UMAP_SNN_jaccard_k13_clusters.pdf"),
       plot = UMAP_SNN_JaccardLouvain_k13,
       device = "pdf", # or one of "eps", "ps", "tex" (pictex), "pdf", "jpeg", "tiff", "png", "bmp", "svg" or "wmf" (windows only).
       path = path_for_figures,
       width = 8, height = 4, units = "in", dpi = 300,
       family = "Arial", bg = "transparent"
       )
```

Before we begin with the differential expression analysis, we will remove the cells assigned to the macrophage-enriched cluster from the dataset so that they don't affect the results. As we saw in the previous section, there should be 12 cells with high levels of expression for macrophage and immune response markers like "Cd33", "Plaur", "Cxcl16", or "Cd68".
```{r}
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_rank_k7==8), " cells in SNN_var_rank_k7 method")
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_rank_k12==7), " cells in SNN_var_rank_k12 method")
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k5==10), " cells in SNN_cv2_jaccard_k5 method")
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k8==1), " cells in SNN_cv2_jaccard_k8 method")
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k9==3), " cells in SNN_cv2_jaccard_k9 method")
paste0("Macrophage cluster has ", sum(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k13==7), " cells in SNN_cv2_jaccard_k13 method")
```

```{r}
# Create a new SingleCellExperiment object by subsetting to leave out the cells from the macrophage-enriched cluster:
PAG_sceset_qc_norm_filt_corr_clust_de <- PAG_sceset_qc_norm_filt_corr_clust[, PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k5!=10]
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

## Step 7.1 | Identifying marker genes between subpopulations
To interpret the clustering results, we can identify the genes that drive separation between clusters. These marker genes allow us to assign biological meaning to each cluster based on their functional annotation. In the most obvious case, the marker genes for each cluster are a priori associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity. The same principle can be applied to discover more subtle differences between clusters (e.g., changes in activation or differentiation state) based on the behavior of genes in the affected pathways.

Identification of marker genes is usually based around the retrospective detection of differential expression between clusters. Genes that are more strongly DE are more likely to have caused separate clustering of cells in the first place. Several different statistical tests are available to quantify the differences in expression profiles, and different approaches can be used to consolidate test results into a single ranking of genes for each cluster.

### 7.1.0 | Overview of approaches
#### Using pairwise t-tests
The Welch t-test is a statistical method that allows us to *test for differences in expression between clusters*. It is quickly computed and has good statistical properties for large numbers of cells (Soneson and Robinson 2018). The `findMarkers()` function from the `scran` package provides a convenience wrapper for marker gene identification between groups of cells, based on running `pairwiseTTests` or related functions and passing the result to `combineMarkers()`. We can use the `findMarkers()` function to perform pairwise comparisons between clusters for each gene (the function performs Welch t-tests on the normalised log-expression values for every gene and between every pair of clusters), which returns a list of `DataFrame`s containing ranked candidate markers for each cluster. The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters. Importantly, besides looking at the clustering results, we can also apply this approach to identify genes driving differences between other factors of our metadata, such as `cell.type` or `PAG.area`, by explicitly supplying them via the `groups=` argument.

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table. The relevant `DataFrame` contains log2-fold changes of expression in cluster X over each other cluster, along with several statistics obtained by combining p-values (Simes 1986) across the pairwise comparisons involving X. This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters. For example, to construct a marker set for cluster X from the top 10 genes of each comparison, we could filter `marker_set` to retain rows with `Top` less than or equal to 10. Other statistics are also reported for each gene, including the adjusted p-values and the log-fold changes relative to every other cluster.

Of particular interest is the `Top` field. The set of genes with `Top ≤ X` is the union of the top X genes (ranked by p-value) from each pairwise comparison involving our chosen cluster. For example, the set of all genes with `Top` values of 1 contains the gene with the lowest p-value from each comparison. Similarly, the set of genes with `Top` values less than or equal to 10 contains the top 10 genes from each comparison. The `Top` field represents `findMarkers()`’s approach to consolidating multiple pairwise comparisons into a single ranking for each cluster; each `DataFrame` produced by `findMarkers()` will order genes based on the `Top` value by default. We can thus use the `Top` field to identify a set of genes that is guaranteed to distinguish cluster X from any other cluster. If we take all genes with `Top <= 6`, this is equivalent to the union of the top 6 genes from each pairwise comparison.

Each `DataFrame` also contains several other statistics that may be of interest. The `p.value` field contains the combined p-value that is obtained by applying Simes’s method to the pairwise p-values for each gene and represents the evidence against the joint null hypothesis, i.e., that the gene is not DE between cluster X and any other cluster. In a future version of `scran`, the `summary.logFC` field provides a convenient summary of the direction and effect size for each gene, and is defined here as the log-fold change from the comparison with the lowest p-value. Examination of these statistics permits a quick evaluation of the suitability of a candidate marker; if both of these metrics are poor (small log-fold change, large p-value), the gene can most likely be dismissed.

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells. The latter approach is sensitive to the population composition, potentially resulting in substantially different sets of markers when cell type abundances change in different contexts. In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations. Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by each gene.

#### Focusing on up or downregulated genes and using the log-fold change
_Focusing on up or downregulated genes_
The previous `findMarkers()` call considers both up- and downregulated genes to be potential markers. However, downregulated genes are less appealing as markers as it is more difficult to interpret and experimentally validate an absence of expression. To focus on up-regulated markers, we can instead perform a one-sided t-test to identify genes that are upregulated in each cluster compared to the others. This is achieved by setting `direction = "up"` in the `findMarkers()` call.

_Using the log-fold change_
The t-test also allows us to specify a non-zero log-fold change as the null hypothesis. This allows us to consider the magnitude of the log-fold change in our p-value calculations, in a manner that is more rigorous than simply filtering directly on the log-fold changes (McCarthy and Smyth 2009). (Specifically, a simple threshold does not consider the variance and can enrich for genes that have both large log-fold changes and large variances.) We perform this by setting `lfc=` in our `findMarkers()` call - when combined with `direction=`, this tests for genes with log-fold changes that are significantly greater than 1.

These two settings yield a more focused set of candidate marker genes that are upregulated in cluster X. This increased stringency, however, is not without cost. If only upregulated genes are requested from `findMarkers()`, any cluster defined by downregulation of a marker gene will not contain that gene among the top set of features in its `DataFrame`. This is occasionally relevant for subtypes or other states that are distinguished by high versus low expression of particular genes. Similarly, setting an excessively high log-fold change threshold may discard otherwise useful genes. For example, a gene upregulated in a small proportion of cells of a cluster will have a small log-fold change but can still be an effective marker if the focus is on specificity rather than sensitivity.

#### Choosing which pairwise comparisons to performm
The choice of `pval.type` determines whether the highly ranked genes are those that are DE between the current group and: (1) any other group ("any"), (2) all other groups ("all"), or (3) some other groups ("some"). The result is a named list of `DataFrame`s, each of which contains a sorted marker gene list for the corresponding group. In each `DataFrame`, the top genes are chosen to enable separation of that group from all other groups. Log-fold changes are reported as differences in average x between groups (usually in base 2, depending on the transformation applied to x).

By default, `findMarkers()` will give a high ranking to genes that are differentially expressed in any pairwise comparison. This is because a gene only needs a very low p-value in a single pairwise comparison to achieve a low `Top` value. A more stringent approach would only consider genes that are differentially expressed in all pairwise comparisons involving the cluster of interest. To achieve this, we set `pval.type="all"` in `findMarkers()` to use an intersection-union test (Berger and Hsu 1996) where the combined p-value for each gene is the maximum of the p-values from all pairwise comparisons. A gene will only achieve a low combined p-value if it is strongly DE in all comparisons to other clusters. Combined with `direction="up"`, this can be used to identify unique markers for each cluster. However, this is sensitive to overclustering, as unique marker genes will no longer exist if a cluster is split into two smaller subclusters.

This strategy will only report genes that are highly specific to the cluster of interest. When it works, it can be highly effective as it generates a small focused set of candidate markers. However, any gene that is expressed at the same level in two or more clusters will simply not be detected. This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation (such as different clusters within a cell type). To give a concrete example, consider a mixed population of CD4+-only, CD8+-only, double-positive and double-negative T cells. With `pval.type="all"`, neither Cd4 or Cd8 would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations. In comparison, `pval.type="any"` will detect both of these genes as they will be DE between at least one pair of subpopulations.

If `pval.type="all"` is too stringent yet `pval.type="any"` is too generous, a compromise is to set `pval.type="some"`. For each gene, we apply the Holm-Bonferroni correction across its p-values and take the middle-most value as the combined p-value. This effectively tests the global null hypothesis that at least 50% of the individual pairwise comparisons exhibit no DE. We then rank the genes by their combined p-values to obtain an ordered set of marker candidates. The aim is to improve the conciseness of the top markers for defining a cluster while mitigating the risk of discarding useful genes that are not DE to all other clusters. The downside is that taking this compromise position sacrifices the theoretical guarantees offered at the other two extremes.

_Only relevant for the newer `scran` version, which returns a column with `summary.logFC`._ In both cases, a different method is used to compute the summary effect size compared to `pval.type="any"`. For `pval.type="all"`, the summary log-fold change is defined as that corresponding to the pairwise comparison with the largest p-value, while for `pval.type="some"`, it is defined as the log-fold change for the comparison with the middle-most p-value. This reflects the calculation of the combined p-value and avoids focusing on genes with strong changes in only one comparison.

#### Handling blocking factors
_Using the `block=` argument_
Large studies may contain factors of variation that are known and not interesting (e.g., batch effects, sex differences). If these are not modelled, they can interfere with marker gene detection - most obviously by inflating the variance within each cluster, but also by distorting the log-fold changes if the cluster composition varies across levels of the blocking factor. To avoid these issues, we can set the `block=` argument in the `findMarkers()` call.

For each gene, each pairwise comparison between clusters is performed separately in each level of the blocking factor. The function will then combine p-values from different blocking levels using Stouffer’s Z method to obtain a single p-value per pairwise comparison. (These p-values are further combined across comparisons to obtain a single p-value per gene, using either Simes’s method or an intersection-union test depending on the value of` pval.type=`.) This approach favours genes that exhibit consistent DE in the same direction in each plate.

The `block=` argument works with all tests shown above and is robust to difference in the log-fold changes or variance between batches. However, it assumes that each pair of clusters is present in at least one batch. In scenarios where cells from two clusters never co-occur in the same batch, the comparison will be impossible and NAs will be reported in the output. 

_Using the `design=` argument_
Another approach is to define a design matrix containing the batch of origin as the sole factor. `findMarkers()` will then fit a linear model to the log-expression values, similar to the use of `limma` for bulk RNA sequencing data (Ritchie et al. 2015). This handles situations where multiple batches contain unique clusters, as comparisons can be implicitly performed via shared cell types in each batch. There is also a slight increase in power when information is shared across clusters for variance estimation.

The use of a linear model makes some strong assumptions, necessitating some caution when interpreting the results. If the batch effect is not consistent across clusters, the variance will be inflated and the log-fold change estimates will be distorted. Variances are also assumed to be equal across groups, which is not true in general. In particular, the presence of clusters in which a gene is silent will shrink the residual variance towards zero, preventing the model from penalizing genes with high variance in other clusters. Thus, it is generally recommended to use `block=` where possible.

#### Using the wilcoxon rank sum test
The Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test) is another widely used method for pairwise comparisons between groups of observations. Its strength lies in the fact that *it directly assesses separation between the expression distributions of different clusters*. The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster. In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the t-test only does so indirectly via the difference in the means and the intra-group variance.

We can perform WMW tests using the `findMarkers()` function, setting `test="wilcox"`. This returns a list of `DataFrames` containing ranked candidate markers for each cluster. The `direction=`, `lfc=` and `pval.type=` arguments can be specified and have the same interpretation as described for t-tests. The interpretation of `Top` is the same as described for t-tests, and Simes’s method is again used to combine p-values across pairwise comparisons. If we want more focused sets, we can also change `pval.type=` as previously described.

Again, to explore the results in more detail, we can focus on the `DataFrame` for group X. The `DataFrame` contains the AUCs from comparing group X to every other group. A value greater than 0.5 indicates that the gene is upregulated in the current cluster compared to the other cluster, while values less than 0.5 correspond to downregulation. We would typically expect AUCs of 0.7-0.8 for a strongly upregulated candidate marker.

One practical advantage of the WMW test over the Welch t-test is that it is symmetric with respect to differences in the size of the groups being compared. This means that, all else being equal, the top-ranked genes on each side of a DE comparison will have similar expression profiles regardless of the number of cells in each group. In contrast, the t-test will favor genes where the larger group has the higher relative variance as this increases the estimated degrees of freedom and decreases the resulting p-value. This can lead to unappealing rankings when the aim is to identify genes upregulated in smaller groups. The WMW test is not completely immune the variance effects - for example, it will slightly favor detection of DEGs at low average abundance where the greater number of ties at zero deflates the approximate variance of the rank sum statistic - but this is relatively benign as the selected genes are still fairly interesting.

The main disadvantage of the WMW test is that the AUCs are much slower to compute compared to t-statistics. This may be inconvenient for interactive analyses involving multiple iterations of marker detection. We can mitigate this to some extent by parallelizing these calculations using the `BPPARAM=` argument in `findMarkers()`.

#### Using the binomial test
The binomial test *identifies genes that differ in the proportion of expressing cells between clusters*. This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero. The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle “tuning” effects from changing the expression of an active gene. From a practical perspective, a binary measure of presence/absence is easier to validate.

We can perform pairwise binomial tests between clusters using the `findMarkers()` function with `test="binom"`. This returns a list of `DataFrames` containing marker statistics for each cluster such as the `Top` rank and its p-value. Here, the effect size is reported as the log-fold change in this proportion between each pair of clusters. Large positive log-fold changes indicate that the gene is more frequently expressed in one cluster compared to the other. We can focus on genes that are upregulated in each cluster compared to the others by setting `direction="up"`.

The disadvantage of the binomial test is that its increased stringency can lead to the loss of good candidate markers. Another property of the binomial test is that it will not respond to scaling normalisation. Systematic differences in library size between clusters will not be considered when computing p-values or effect sizes. This is not necessarily problematic for marker gene detection - users can treat this as retaining information about the total RNA content, analogous to spike-in normalisation.

#### Using custom DE methods
It is also possible to perform marker gene detection based on precomputed DE statistics, which allows us to take advantage of more sophisticated tests in dedicated DE analysis packages in the Bioconductor ecosystem. Count-based statistical methods such as _DESeq2_ (Love, Huber, and Anders 2014), _edgeR_ (Robinson, McCarthy, and Smyth 2009), _limma_ with the _voom_ method (Law et al. 2014), can be used to that purpose.

By default, we do not use custom DE methods to perform marker detection, for several reasons. Many of these methods rely on empirical Bayes shrinkage to share information across genes in the presence of limited replication. However, this is unnecessary when there are large numbers of “replicate” cells in each group. These methods also make stronger assumptions about the data (e.g., equal variances for linear models, the distribution of variances during empirical Bayes) that are more likely to be violated in noisy scRNA-seq contexts. From a practical perspective, they require more work to set up and take more time to run. Nonetheless, some custom methods (e.g., MAST) may provide a useful point of difference from the simpler tests.

_MAST_ is an R/Bioconductor package for managing and analyzing qPCR and sequencing-based single-cell gene expression data, as well as data from other types of single-cell assays. Apart from reading and storing single-cell assay data, the package also provides functionality for significance testing of differential expression using a Hurdle model, gene set enrichment, facilities for visualizing patterns in residuals indicative of differential expression, and power calculations. _MAST_ is based on a zero-inflated negative binomial model. It tests for differential expression using a Hurdle model to combine tests of discrete (0 vs not zero) and continuous (non-zero values) aspects of gene expression. Similar to `DESeq2` and `edgeR`, it uses a linear modelling framework to enable complex models to be considered.

#### Some comments on p-values and DE analysis
_Data dredging_
All of our DE strategies for detecting marker genes between clusters are statistically flawed to some extent. The DE analysis is performed on the same data used to obtain the clusters, which represents “data dredging” (also known as fishing or data snooping). The hypothesis of interest - are there differences between clusters? - is formulated from the data, so we are more likely to get a positive result when we re-use the data set to test that hypothesis.

The practical effect of data dredging is best illustrated with a simple simulation. If we simulate i.i.d. normal values, perform k-means clustering and test for DE between clusters of cells with `findMarkers()`, the resulting distribution of p-values is heavily skewed towards low values. Thus, we can detect “significant” differences between clusters even in the absence of any real substructure in the data. This effect arises from the fact that clustering, by definition, yields groups of cells that are separated in expression space. Testing for DE genes between clusters will inevitably yield some significant results as that is how the clusters were defined.

For marker gene detection, this effect is largely harmless as the p-values are used only for ranking. However, it becomes an issue when the p-values are used to define “significant differences” between clusters with respect to an error rate threshold. Meaningful interpretation of error rates require consideration of the long-run behaviour, i.e., the rate of incorrect rejections if the experiment were repeated many times. The concept of statistical significance for differences between clusters is not applicable if clusters and their interpretations are not stably reproducible across (hypothetical) replicate experiments.

_Nature of replication_
The naive application of DE analysis methods will treat counts from the same cluster of cells as replicate observations. This is not the most relevant level of replication when cells are derived from the same biological sample (i.e., cell culture, animal or patient). DE analyses that treat cells as replicates fail to properly model the sample-to-sample variability (Lun and Marioni 2017). The latter is arguably the more important level of replication as different samples will necessarily be generated if the experiment is to be replicated. Indeed, the use of cells as replicates only masks the fact that the sample size is actually one in an experiment involving a single biological sample. This reinforces the inappropriateness of using the marker gene p-values to perform statistical inference.

We strongly recommend selecting some markers for use in validation studies with an independent replicate population of cells. A typical strategy is to identify a corresponding subset of cells that express the upregulated markers and do not express the downregulated markers. Ideally, a different technique for quantifying expression would also be used during validation, e.g., fluorescent in situ hybridisation or quantitative PCR. This confirms that the subpopulation genuinely exists and is not an artifact of the scRNA-seq protocol or the computational analysis.

_Further comments_
One consequence of the DE analysis strategy is that markers are defined relative to subpopulations in the same dataset. Biologically meaningful genes will not be detected if they are expressed uniformly throughout the population, e.g., T cell markers will not be detected if only T cells are present in the dataset. In practice, this is usually only a problem when the experimental data are provided without any biological context - certainly, we would hope to have some a priori idea about what cells have been captured. For most applications, it is actually desirable to avoid detecting such genes as we are interested in characterizing heterogeneity within the context of a known cell population. Continuing from the example above, the failure to detect T cell markers is of little consequence if we already know we are working with T cells.

Alternatively, marker detection can be performed by treating gene expression as a predictor variable for cluster assignment. For a pair of clusters, we can find genes that discriminate between them by performing inference with a logistic model where the outcome for each cell is whether it was assigned to the first cluster and the lone predictor is the expression of each gene. Treating the cluster assignment as the dependent variable is more philosophically pleasing in some sense, as the clusters are indeed defined from the expression data rather than being known in advance. (Note that this does not solve the data snooping problem.) In practice, this approach effectively does the same task as a Wilcoxon rank sum test in terms of quantifying separation between clusters. Logistic models have the advantage in that they can easily be extended to block on multiple nuisance variables, though this is not typically necessary in most use cases. Even more complex strategies use machine learning methods to determine which features contribute most to successful cluster classification, but this is probably unnecessary for routine analyses.

### 7.1.1 | Identify cluster-specific marker genes
We first take a look at the main parameters we will need for our call to `findMarkers()` and reset them to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We can run the following chunk of code several times, changing the parameters for the `test.type`, `pval.type`, `direction`, `lfc`, and others to extract the results of the comparison we want into a .csv file. We also assign the results to separate variables so we can plot them later on.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k8

# Set the string to be added to the filename when saving the results:
results_name <- "SNN_clusters_cv2_jaccard_k8_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
SNN_clusters_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "SNN_clusters/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]]
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
        
        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set) # Assign the results to the created variable
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "SNN_clusters/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        # Populate the summary data.frame:        
        SNN_clusters_marker_set_summary = rbind(SNN_clusters_marker_set_summary,
                                                data.frame(marker_set = marker_set,
                                                           group = levels(groups)[chosen_group],
                                                           test = test,
                                                           comparisons = comparisons,
                                                           direction = direction,
                                                           genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                           genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
      }
    }
  }
}

# Check out the summary: 
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="t",]
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="wilcox",]
SNN_clusters_marker_set_summary[SNN_clusters_marker_set_summary$test=="binom",]
```

If you do all loops you get 297 files. Remove direction "any" as it is the same as having "up" and "down" separately to get 198.

### 7.1.2 | Marker genes for cell type
Once we have performed pairwise comparisons between the identified clusters, we can move on to perform comparisons according to our experimental design. For this, we will continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_marker_set_summary = rbind(celltype_marker_set_summary,
                                        data.frame(marker_set = marker_set,
                                                   group = levels(groups)[chosen_group],
                                                   test = test,
                                                   comparisons = comparisons,
                                                   direction = direction,
                                                   genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                   genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_marker_set_summary
```

```{r}
#names(metadata(PAG_sceset_qc_norm_filt_corr_clust_de))

VGAT_de_genes <- rownames(marker_set_VGAT_wilcox_all_up[marker_set_VGAT_wilcox_all_up$FDR<0.1, ]) 
VGluT2_de_genes <- rownames(marker_set_VGluT2_wilcox_all_up[marker_set_VGluT2_wilcox_all_up$FDR<0.1, ]) 

print("Ion Channels")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]

print("Neuromodulators and Neuropeptides")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]

print("Monoamines")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]

print("Neurotransmitters")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]

print("Transporters")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]

print("Transcription Factors")
VGAT_de_genes[VGAT_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
VGluT2_de_genes[VGluT2_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
```

### 7.1.3 | Marker genes for cell type within PAG sudivision
_We can repeat the same strategy used for `PAG.area`, but this time using only either VGAT+ or VGluT2+ neurons. This will test for differences across subdivisions within a particular cell type, thus highlighting genes relevant to either inhibitory or excitatory neurons, which will be less stringent than taking all the groups together._

#### Marker genes for cell type in dmPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_dmpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_dmpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dmpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_dmpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_dmpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_dmpag_marker_set_summary = rbind(celltype_dmpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_dmpag_marker_set_summary
```

_Subsetting like this gives the same as using restrict_
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$celltype_PAGarea
restrict <- c("dmpag_VGAT", "dmpag_VGluT2") # the levels of groups for which to perform pairwise comparisons.

#### Marker genes for cell type in dlPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_dlpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_dlpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="dlpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_dlpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_dlpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_dlpag_marker_set_summary = rbind(celltype_dlpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_dlpag_marker_set_summary
```

#### Marker genes for cell type in lPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_lpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_lpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="lpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_lpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_lpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_lpag_marker_set_summary = rbind(celltype_lpag_marker_set_summary,
                                             data.frame(marker_set = marker_set,
                                                        group = levels(groups)[chosen_group],
                                                        test = test,
                                                        comparisons = comparisons,
                                                        direction = direction,
                                                        genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                        genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_lpag_marker_set_summary
```

#### Marker genes for cell type in vlPAG neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `cell.type` comparisons, we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want.
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"]$cell.type

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_vlpag_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_vlpag_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  
  # Set the remaining parameters:
  comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
  direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
  lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
  block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"]$mouse.sex # factor specifying the blocking level for each cell.
  design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
  restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
  exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
  
  # Run findMarkers:
  marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area=="vlpag"],
                              groups = groups,
                              test.type = test,
                              pval.type = comparisons,
                              direction = direction,
                              lfc = lfc,
                              assay.type = "logcounts",
                              block = block,
                              restrict = restrict,
                              exclude = exclude)
  
  # Save results:
  saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_vlpag/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
  
  # Create a variable with a value for each group name to iterate through:
  range_of_groups <- 1:paste(length(levels(groups)))
  
  # Create and export a separate table of results for each group:
  for (chosen_group in range_of_groups) {
    # Compose name of variable where results will be assigned to:
    marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
    
    # Assign results of marker genes for current group to a temp variable:
    temp_marker_set <- marker_genes[[chosen_group]]
    
    #print(marker_set) # Print variable name of current group
    #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
    #print(temp_marker_set[1:5, 1:3]) # Print top results for current group
    
    # Assign the results to the created variable:
    assign(marker_set, temp_marker_set)
    
    # Export the results to a .csv file:
    write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_vlpag/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
    
    # Populate the summary data.frame:
    celltype_vlpag_marker_set_summary = rbind(celltype_vlpag_marker_set_summary,
                                              data.frame(marker_set = marker_set,
                                                         group = levels(groups)[chosen_group],
                                                         test = test,
                                                         comparisons = comparisons,
                                                         direction = direction,
                                                         genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                         genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
    }
}

# Check out the summary: 
celltype_vlpag_marker_set_summary
```

### 7.1.4 | Marker genes for PAG subdivisions
We will now perform pairwise comparisons to identify marker genes for PAG subdivisions. For this, we continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `PAG.area` comparisons, 

_we only need to iterate through the different statistical tests. The fact that we only have two groups (VGAT and VGluT2 cells) means that all options in `pval.type` will yield the same results, and `direction = "up"` in one `cell.type` will be equivalent to `direction = "down"` in the other `cell.type` and viceversa, so by setting `direction = "up"` we will get already obtain all the results we want._
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_marker_set_summary = rbind(PAGarea_marker_set_summary,
                                           data.frame(marker_set = marker_set,
                                                      group = levels(groups)[chosen_group],
                                                      test = test,
                                                      comparisons = comparisons,
                                                      direction = direction,
                                                      genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                      genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
      }
    }
  }
}

# Check out the summary: 
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="t",]
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="wilcox",]
PAGarea_marker_set_summary[PAGarea_marker_set_summary$test=="binom",]
```

```{r}
dmpag_de_genes <- rownames(marker_set_dmpag_wilcox_some_up[marker_set_dmpag_wilcox_some_up$FDR<0.05, ])
dlpag_de_genes <- rownames(marker_set_dlpag_wilcox_some_up[marker_set_dlpag_wilcox_some_up$FDR<0.05, ])
lpag_de_genes <- rownames(marker_set_lpag_wilcox_some_up[marker_set_lpag_wilcox_some_up$FDR<0.05, ])
vlpag_de_genes <- rownames(marker_set_vlpag_wilcox_some_up[marker_set_vlpag_wilcox_some_up$FDR<0.05, ])


print("Ion Channels")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.ionchannels]

print("Neuromodulators and Neuropeptides")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.NeuromodulatorsPeptides]

print("Monoamines")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Monoamines]

print("Neurotransmitters")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Neurotransmitters]

print("Transporters")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transporters]

print("Transcription Factors")
dmpag_de_genes[dmpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
dlpag_de_genes[dlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
lpag_de_genes[lpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
vlpag_de_genes[vlpag_de_genes %in% metadata(PAG_sceset_qc_norm_filt_corr_clust_de)$genes.Transcriptionfactors]
```

### 7.1.5 | Marker genes for PAG subdivision within cell type
We can repeat the same strategy used for `PAG.area`, but this time using only either VGAT+ or VGluT2+ neurons. This will test for differences across subdivisions within a particular cell type, thus highlighting genes relevant to either inhibitory or excitatory neurons, which will be less stringent than taking all the groups together.

#### Marker genes for PAG subdivision in VGAT+ neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We first check, __FILL WITH SOMETHING MEANINGFUL__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"]$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_vgat_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_VGAT_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"]$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGAT"],
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea_vgat/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea_vgat/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_VGAT_marker_set_summary = rbind(PAGarea_VGAT_marker_set_summary,
                                                data.frame(marker_set = marker_set,
                                                           group = levels(groups)[chosen_group],
                                                           test = test,
                                                           comparisons = comparisons,
                                                           direction = direction,
                                                           genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                           genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="t",]
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="wilcox",]
PAGarea_VGAT_marker_set_summary[PAGarea_VGAT_marker_set_summary$test=="binom",]
```

#### Marker genes for PAG subdivision in VGluT2+ neurons
To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

We first check, __FILL WITH SOMETHING MEANINGFUL__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"]$PAG.area

# Set the string to be added to the filename when saving the results:
results_name <- "PAGarea_vglut2_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
PAGarea_VGluT2_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"]$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de[,PAG_sceset_qc_norm_filt_corr_clust_de$cell.type=="VGluT2"],
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "PAGarea_vglut2/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "PAGarea_vglut2/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        PAGarea_VGluT2_marker_set_summary = rbind(PAGarea_VGluT2_marker_set_summary,
                                                  data.frame(marker_set = marker_set,
                                                             group = levels(groups)[chosen_group],
                                                             test = test,
                                                             comparisons = comparisons,
                                                             direction = direction,
                                                             genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                             genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="t",]
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="wilcox",]
PAGarea_VGluT2_marker_set_summary[PAGarea_VGluT2_marker_set_summary$test=="binom",]
```

### 7.1.6 | Marker genes for celltype_PAGarea
We will now perform pairwise comparisons to identify marker genes for `celltype_PAGarea`. For this, we continue with the `SingleCellExperiment` object we created after excluding the cells assigned to the macrophage-enriched cluster:
```{r}
dim(PAG_sceset_qc_norm_filt_corr_clust)
dim(PAG_sceset_qc_norm_filt_corr_clust_de)
```

To make sure we don't carry any variables from previous runs, we reset all the parameters to their default values:
```{r}
library(scran)
# Parameters defaults:
groups <- NULL # clustering results or group for each cell.

test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

block <- NULL # factor specifying the blocking level for each cell.
design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

For the `celltype_PAGarea` comparisons, __FILL IN__
```{r}
# Set the groups to be compared (cluster IDs or metadata slot of interest):
groups <- PAG_sceset_qc_norm_filt_corr_clust_de$celltype_PAGarea

# Set the string to be added to the filename when saving the results:
results_name <- "celltype_PAGarea_" # one of "SNN_clusters_cv2_jaccard_k8_", "celltype_", "PAGarea_", "celltype_PAGarea_", "celltype_PAGAPaxis_", "VGAT_VGluT2_expression"

# Create a variable with the tests you want to run:
desired_tests <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
desired_comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
desired_directions <- c("up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".

# Initialise an empty data.frame to populate with a summary of marker genes:
celltype_PAGarea_marker_set_summary <- data.frame()

# Perform comparisons of chosen groups with a set of statistical tests and store/export all the results:
for (test_choice in desired_tests){
  test <- test_choice
  for (comparison_choice in desired_comparisons){
    comparisons <- comparison_choice
    for (direction_choice in desired_directions){
      direction <- direction_choice
      
      # Set the remaining parameters:
      lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.
      block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
      design <- NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
      restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
      exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.
      
      # Run findMarkers:  
      marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                                  groups = groups,
                                  test.type = test,
                                  pval.type = comparisons,
                                  direction = direction,
                                  lfc = lfc,
                                  assay.type = "logcounts",
                                  block = block,
                                  restrict = restrict,
                                  exclude = exclude)
      
      # Save results:
      saveRDS(marker_genes, file = str_c(path_for_figures, "celltype_PAGarea/", results_name, "marker_genes_", test, "_", comparisons, "_", direction, ".rds"))
      
      # Create a variable with a value for each group name to iterate through:
      range_of_groups <- 1:paste(length(levels(groups)))
      
      # Create and export a separate table of results for each group:
      for (chosen_group in range_of_groups) {
        # Compose name of variable where results will be assigned to:
        marker_set <- str_c("marker_set_", levels(groups)[chosen_group], "_", test, "_", comparisons, "_", direction)
        
        # Assign results of marker genes for current group to a temp variable:
        temp_marker_set <- marker_genes[[chosen_group]] # Assign results of marker genes for current group to a temp variable
        
        #print(marker_set) # Print variable name of current group
        #print(sum(temp_marker_set$FDR<0.05)) # Print the number of genes with a FDR below 0.05
        #print(temp_marker_set[1:5, 1:3]) # Print top results for current group

        # Assign the results to the created variable:
        assign(marker_set, temp_marker_set)
        
        # Export the results to a .csv file:
        write.csv(temp_marker_set, file = str_c(path_for_figures, "celltype_PAGarea/", "PAG_DE_results_", results_name, marker_set, ".csv"), quote = FALSE, row.names = TRUE)
        
        # Populate the summary data.frame:
        celltype_PAGarea_marker_set_summary = rbind(celltype_PAGarea_marker_set_summary,
                                                    data.frame(marker_set = marker_set,
                                                               group = levels(groups)[chosen_group],
                                                               test = test,
                                                               comparisons = comparisons,
                                                               direction = direction,
                                                               genes_FDR_005 = sum(temp_marker_set$FDR<0.05),
                                                               genes_FDR_01 = sum(temp_marker_set$FDR<0.1)))
        }
    }
  }
}

# Check out the summary: 
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="t",]
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="wilcox",]
celltype_PAGarea_marker_set_summary[celltype_PAGarea_marker_set_summary$test=="binom",]
```

### 7.1.7 | Marker genes for PAG AP axis

### 7.1.8 | Marker genes for cell type along AP axis

### 7.1.9 | Marker genes for cell type according to VGAT or VGluT2 expression

### 0.0.0 | TO ADD - HEATMAPS - Tricks and comments
```{r}
library(pheatmap)
best_set_up_all_clusters_cluster_4 <- marker_set_up_all_clusters_cluster_4[1:30,]
best_set_up_all_clusters_cluster_4_names <- rownames(best_set_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | all | up)")
```

https://bioinformatics-core-shared-training.github.io/cruk-summer-school-2018/SingleCell/practical/crukBioinfoSummerSchoolJuly2018_scRnaSeqCellPopId_practical_run.html#19_clustering_cells_into_putative_subpopulations
```{r}
# select some top genes:
top.markers <- rownames(marker.set)[marker.set$Top <= 10]

# have matrix to annotate sample with cluster and sample:
tmpData <- logcounts(nz.sce)[top.markers,]
# concat sample and barcode names to make unique name across the whole data set
tmpCellNames <- paste(colData(nz.sce)$Sample, colData(nz.sce)$Barcode, sep="_")
# use these to namecolumn of matrix the show as heatmap:
colnames(tmpData) <- tmpCellNames # colData(nz.sce)$Barcode                    

# columns annotation with cell name:
mat_col <- data.frame(cluster = nz.sce$cluster, sample = nz.sce$Sample)
rownames(mat_col) <- colnames(tmpData)
rownames(mat_col) <- tmpCellNames # colData(nz.sce)$Barcode

# Prepare colours for clusters:
colourCount = length(unique(nz.sce$cluster))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))

mat_colors <- list(group = getPalette(colourCount))
names(mat_colors$group) <- unique(nz.sce$cluster)

# plot heatmap:
pheatmap(tmpData,
         border_color      = NA,
         show_colnames     = FALSE,
         show_rownames     = FALSE,
         drop_levels       = TRUE,
         annotation_col    = mat_col,
         annotation_colors = mat_colors
         )

# One can sort both the gene and sample dendrograms to improve the heatmap.

library(dendsort)

mat <- tmpData
mat_cluster_cols <- hclust(dist(t(mat)))

sort_hclust <- function(...) as.hclust(dendsort(as.dendrogram(...)))

mat_cluster_cols <- sort_hclust(mat_cluster_cols)
#plot(mat_cluster_cols, main = "Sorted Dendrogram", xlab = "", sub = "")

mat_cluster_rows <- sort_hclust(hclust(dist(mat)))

pheatmap(tmpData,
         border_color      = NA,
         show_colnames     = FALSE,
         show_rownames     = FALSE,
         drop_levels       = TRUE,
         annotation_col    = mat_col,
         annotation_colors = mat_colors,
         cluster_cols      = mat_cluster_cols,
         cluster_rows      = mat_cluster_rows
         )
```

### 7.1.1 | Using pairwise t-tests
The Welch t-test is a statistical method that allows us to test for differences in expression between clusters. It is quickly computed and has good statistical properties for large numbers of cells (Soneson and Robinson 2018). The `findMarkers()` function from the `scran` package provides a convenience wrapper for marker gene identification between groups of cells, based on running `pairwiseTTests` or related functions and passing the result to `combineMarkers()`. We can use the `findMarkers()` function to perform pairwise comparisons between clusters for each gene (the function performs Welch t-tests on the normalised log-expression values for every gene and between every pair of clusters), which returns a list of `DataFrame`s containing ranked candidate markers for each cluster. The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters. Importantly, besides looking at the clustering results, we can also apply this approach to identify genes driving differences between other factors of our metadata, such as `cell.type` or `PAG.area`.

The choice of `pval.type` determines whether the highly ranked genes are those that are DE between the current group and: (1) any other group ("any"), (2) all other groups ("all"), or (3) some other groups ("some"). The result is a named list of `DataFrame`s, each of which contains a sorted marker gene list for the corresponding group. In each `DataFrame`, the top genes are chosen to enable separation of that group from all other groups. Log-fold changes are reported as differences in average x between groups (usually in base 2, depending on the transformation applied to x).
```{r}
library(scran)
marker_genes_standard <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                     groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10#, # clustering results or any other group assignements for each cell.
                                     #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                     #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                     #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                                     #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                     #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                     #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                     #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                     #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                     #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                     #get.spikes = FALSE,
                                     #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                     #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                     #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                     #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                     #direction = c("any", "up", "down"), # the direction of log-fold changes to be considered in the alternative hypothesis.
                                     #lfc = 0, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                     #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                     #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                     )
marker_genes_standard
```

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table. The relevant `DataFrame` contains log2-fold changes of expression in cluster X over each other cluster, along with several statistics obtained by combining p-values (Simes 1986) across the pairwise comparisons involving X. This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters. For example, to construct a marker set for cluster X from the top 10 genes of each comparison, we could filter `marker_set` to retain rows with `Top` less than or equal to 10. Other statistics are also reported for each gene, including the adjusted p-values and the log-fold changes relative to every other cluster.
```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_standard[[chosen_group]]
  print(paste0("marker_set_standard_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_standard_cluster_", chosen_group)
  assign(marker_set, marker_genes_standard[[chosen_group]])
}
```

Of particular interest is the `Top` field. The set of genes with `Top ≤ X` is the union of the top X genes (ranked by p-value) from each pairwise comparison involving our chosen cluster. For example, the set of all genes with `Top` values of 1 contains the gene with the lowest p-value from each comparison. Similarly, the set of genes with `Top` values less than or equal to 10 contains the top 10 genes from each comparison. The `Top` field represents `findMarkers()`’s approach to consolidating multiple pairwise comparisons into a single ranking for each cluster; each `DataFrame` produced by `findMarkers()` will order genes based on the `Top` value by default.
```{r}
colnames(marker_set_standard_cluster_4)

# Check what Top represents:
marker_set_standard_cluster_4[marker_set_standard_cluster_4$Top <= 1,]
marker_set_standard_cluster_4[1:10, 1:5]
```

We can use the `Top` field to identify a set of genes that is guaranteed to distinguish cluster X from any other cluster. If we take all genes with `Top <= 6`, this is equivalent to the union of the top 6 genes from each pairwise comparison.
```{r}
library(pheatmap)
best_set_standard_cluster_4 <- marker_set_standard_cluster_4[marker_set_standard_cluster_4$Top <= 6,]
#best_set_standard_cluster_4
logFCs_standard <- as.matrix(best_set_standard_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_standard
colnames(logFCs_standard) <- sub("logFC.", "", colnames(logFCs_standard)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_standard

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_standard, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | any)")

# Alternative plot - will plot expression of the marker genes
best_set_standard_cluster_4_names <- rownames(best_set_standard_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_standard_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | any)")
```

Each `DataFrame` also contains several other statistics that may be of interest. The `p.value` field contains the combined p-value that is obtained by applying Simes’s method to the pairwise p-values for each gene and represents the evidence against the joint null hypothesis, i.e., that the gene is not DE between cluster X and any other cluster. In a future version of `scran`, the `summary.logFC` field provides a convenient summary of the direction and effect size for each gene, and is defined here as the log-fold change from the comparison with the lowest p-value. Examination of these statistics permits a quick evaluation of the suitability of a candidate marker; if both of these metrics are poor (small log-fold change, large p-value), the gene can most likely be dismissed.

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells. The latter approach is sensitive to the population composition, potentially resulting in substantially different sets of markers when cell type abundances change in different contexts. In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations. Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by each gene.

### 7.1.2 | Using the log-fold change
The previous `findMarkers()` call considers both up- and downregulated genes to be potential markers. However, downregulated genes are less appealing as markers as it is more difficult to interpret and experimentally validate an absence of expression. To focus on up-regulated markers, we can instead perform a one-sided t-test to identify genes that are upregulated in each cluster compared to the others. This is achieved by setting `direction = "up"` in the `findMarkers()` call.
```{r}
marker_genes_up <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                               groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results or any other group assignements for each cell.
                               #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                               #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                               #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                               #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                               #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                               #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                               #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                               #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                               #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                               #get.spikes = FALSE,
                               #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                               #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                               #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                               #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                               direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                               #lfc = 0, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                               #std.lfc = FALSE, # whether log-fold changes should be standardized.
                               #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                               )
marker_genes_up
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up[[chosen_group]]
  print(paste0("marker_set_up_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_cluster_", chosen_group)
  assign(marker_set, marker_genes_up[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_cluster_4 <- marker_set_up_cluster_4[marker_set_up_cluster_4$Top <= 6,]
#best_set_up_cluster_4
logFCs_up <- as.matrix(best_set_up_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_up
colnames(logFCs_up) <- sub("logFC.", "", colnames(logFCs_up)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_up

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_up, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | up)")

# Alternative plot - will plot expression of the marker genes
best_set_up_cluster_4_names <- rownames(best_set_up_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | up)")
```

The t-test also allows us to specify a non-zero log-fold change as the null hypothesis. This allows us to consider the magnitude of the log-fold change in our p-value calculations, in a manner that is more rigorous than simply filtering directly on the log-fold changes (McCarthy and Smyth 2009). (Specifically, a simple threshold does not consider the variance and can enrich for genes that have both large log-fold changes and large variances.) We perform this by setting `lfc=` in our `findMarkers()` call - when combined with `direction=`, this tests for genes with log-fold changes that are significantly greater than 1:
```{r}
marker_genes_up_logFC <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                     groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results or any other group assignements for each cell.
                                     #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                     #pval.type = c("any", "some", "all"), # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                     #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise defaults to zero.
                                     #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                     #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                     #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                     #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                     #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                     #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                     #get.spikes = FALSE,
                                     #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                     #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                     #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                     #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                     direction = "up", # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                     lfc = 1#, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                     #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                     #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                     )
marker_genes_up_logFC
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_logFC[[chosen_group]]
  print(paste0("marker_set_up_logFC_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_logFC_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_logFC[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_logFC_cluster_4 <- marker_set_up_logFC_cluster_4[marker_set_up_logFC_cluster_4$Top <= 6,]
#best_set_up_logFC_cluster_4
logFCs_up_logFC <- as.matrix(best_set_up_logFC_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#logFCs_up_logFC
colnames(logFCs_up_logFC) <- sub("logFC.", "", colnames(logFCs_up_logFC)) # Remove "logFC." from the colnames, to leave the cluster number alone
#logFCs_up_logFC

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(logFCs_up_logFC, breaks = seq(-5, 5, length.out = 101),
         main = "Heatmap for Cluster 4 log-fold changes (t-test | any | up logFC)")

# Alternative plot - will plot expression of the marker genes
best_set_up_logFC_cluster_4_names <- rownames(best_set_up_logFC_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_logFC_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | any | up logFC)")
```

These two settings yield a more focused set of candidate marker genes that are upregulated in cluster X. This increased stringency, however, is not without cost. If only upregulated genes are requested from `findMarkers()`, any cluster defined by downregulation of a marker gene will not contain that gene among the top set of features in its `DataFrame`. This is occasionally relevant for subtypes or other states that are distinguished by high versus low expression of particular genes. Similarly, setting an excessively high log-fold change threshold may discard otherwise useful genes. For example, a gene upregulated in a small proportion of cells of a cluster will have a small log-fold change but can still be an effective marker if the focus is on specificity rather than sensitivity.

### 7.1.3 | Finding cluster-specific markers
By default, `findMarkers()` will give a high ranking to genes that are differentially expressed in any pairwise comparison. This is because a gene only needs a very low p-value in a single pairwise comparison to achieve a low `Top` value. A more stringent approach would only consider genes that are differentially expressed in all pairwise comparisons involving the cluster of interest. To achieve this, we set `pval.type="all"` in `findMarkers()` to use an intersection-union test (Berger and Hsu 1996) where the combined p-value for each gene is the maximum of the p-values from all pairwise comparisons. A gene will only achieve a low combined p-value if it is strongly DE in all comparisons to other clusters. Combined with `direction="up"`, this can be used to identify unique markers for each cluster. However, this is sensitive to overclustering, as unique marker genes will no longer exist if a cluster is split into two smaller subclusters.

This strategy will only report genes that are highly specific to the cluster of interest. When it works, it can be highly effective as it generates a small focused set of candidate markers. However, any gene that is expressed at the same level in two or more clusters will simply not be detected. This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation (such as different clusters within a cell type). To give a concrete example, consider a mixed population of CD4+-only, CD8+-only, double-positive and double-negative T cells. With `pval.type="all"`, neither Cd4 or Cd8 would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations. In comparison, `pval.type="any"` will detect both of these genes as they will be DE between at least one pair of subpopulations.

If `pval.type="all"` is too stringent yet `pval.type="any"` is too generous, a compromise is to set `pval.type="some"`. For each gene, we apply the Holm-Bonferroni correction across its p-values and take the middle-most value as the combined p-value. This effectively tests the global null hypothesis that at least 50% of the individual pairwise comparisons exhibit no DE. We then rank the genes by their combined p-values to obtain an ordered set of marker candidates. The aim is to improve the conciseness of the top markers for defining a cluster while mitigating the risk of discarding useful genes that are not DE to all other clusters. The downside is that taking this compromise position sacrifices the theoretical guarantees offered at the other two extremes.

_Only relevant for the newer `scran` version, which returns a column with `summary.logFC`._ In both cases, a different method is used to compute the summary effect size compared to `pval.type="any"`. For `pval.type="all"`, the summary log-fold change is defined as that corresponding to the pairwise comparison with the largest p-value, while for `pval.type="some"`, it is defined as the log-fold change for the comparison with the middle-most p-value. This reflects the calculation of the combined p-value and avoids focusing on genes with strong changes in only one comparison.

We can prepare code for our different comparisons and then modify the `pval.type` to compare the different approaches.

#### pval.type = "all"
##### Across clusters
We can first look at cluster-specific markers:
```{r}
marker_genes_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_all_clusters[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_all_clusters_cluster_4 <- marker_set_up_all_clusters_cluster_4[1:30,]
best_set_up_all_clusters_cluster_4_names <- rownames(best_set_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | all | up)")
```

##### Across cell types
We can next look at cell-type-specific markers:
```{r}
marker_genes_up_all_celltype <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$cell.type, # clustering results or any other group assignements for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise to zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_celltype
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_celltype <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                           colour_by = "cell.type") + labs(title = "UMAP (cv2) - Cell type", 
                                                                                                              x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_celltype)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$cell.type)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype[[chosen_group]])
}
```

```{r}
library(pheatmap)
# VGAT cells
best_set_up_all_celltype_VGAT <- marker_set_up_all_celltype_1[1:30,]
best_set_up_all_celltype_VGAT_names <- rownames(best_set_up_all_celltype_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGAT marker genes (t-test | all | up)")

# VGluT2 cells
best_set_up_all_celltype_VGluT2 <- marker_set_up_all_celltype_2[1:30,]
best_set_up_all_celltype_VGluT2_names <- rownames(best_set_up_all_celltype_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGluT2 marker genes (t-test | all | up)")
```

##### Across PAG subdivisions
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_PAGareas <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$PAG.area, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_PAGareas
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "PAG.area", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$PAG.area)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_PAGareas[[chosen_group]]
  print(paste0("marker_set_up_all_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_PAGareas[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG
best_set_up_all_PAGareas_dm <- marker_set_up_all_PAGarea_1[1:30,]
best_set_up_all_PAGareas_dm_names <- rownames(best_set_up_all_PAGareas_dm)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dm_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG marker genes (t-test | all | up)")

# dlPAG
best_set_up_all_PAGareas_dl <- marker_set_up_all_PAGarea_2[1:30,]
best_set_up_all_PAGareas_dl_names <- rownames(best_set_up_all_PAGareas_dl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG marker genes (t-test | all | up)")

# lPAG
best_set_up_all_PAGareas_l <- marker_set_up_all_PAGarea_3[1:30,]
best_set_up_all_PAGareas_l_names <- rownames(best_set_up_all_PAGareas_l)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_l_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG marker genes (t-test | all | up)")

# vlPAG
best_set_up_all_PAGareas_vl <- marker_set_up_all_PAGarea_4[1:30,]
best_set_up_all_PAGareas_vl_names <- rownames(best_set_up_all_PAGareas_vl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_vl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG marker genes (t-test | all | up)")
```

##### Across celltype_PAGarea
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_celltype_PAGarea <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                                    groups = PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea, # clustering results for each cell.
                                                    #test.type = c("t", "wilcox", "binom"), # t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                                    pval.type = "all", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                                    #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                                    #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                                    #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                                    #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                                    #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each output DataFrames.
                                                    #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                                    #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                                    #get.spikes = FALSE,
                                                    #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                                    #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                                    #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                                    #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                                    direction = "up"#, # direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                                    #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                                    #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                                    #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                                    )
marker_genes_up_all_celltype_PAGarea
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "celltype_PAGarea", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions and cell types", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype_PAGarea[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype_PAGarea[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG_VGAT
best_set_up_all_dmPAG_VGAT<- marker_set_up_all_celltype_PAGarea_1[1:30,]
best_set_up_all_dmPAG_VGAT_names <- rownames(best_set_up_all_dmPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGAT marker genes (t-test | all | up)")

# dlPAG_VGAT
best_set_up_all_dlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_2[1:30,]
best_set_up_all_dlPAG_VGAT_names <- rownames(best_set_up_all_dlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGAT marker genes (t-test | all | up)")

# lPAG_VGAT
best_set_up_all_lPAG_VGAT<- marker_set_up_all_celltype_PAGarea_3[1:30,]
best_set_up_all_lPAG_VGAT_names <- rownames(best_set_up_all_lPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGAT marker genes (t-test | all | up)")

# vlPAG_VGAT
best_set_up_all_vlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_4[1:30,]
best_set_up_all_vlPAG_VGAT_names <- rownames(best_set_up_all_vlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGAT marker genes (t-test | all | up)")

# dmPAG_VGluT2
best_set_up_all_dmPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_5[1:30,]
best_set_up_all_dmPAG_VGluT2_names <- rownames(best_set_up_all_dmPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGluT2 marker genes (t-test | all | up)")

# dlPAG_VGluT2
best_set_up_all_dlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_6[1:30,]
best_set_up_all_dlPAG_VGluT2_names <- rownames(best_set_up_all_dlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGluT2 marker genes (t-test | all | up)")

# lPAG_VGluT2
best_set_up_all_lPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_7[1:30,]
best_set_up_all_lPAG_VGluT2_names <- rownames(best_set_up_all_lPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGluT2 marker genes (t-test | all | up)")

# vlPAG_VGluT2
best_set_up_all_vlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_8[1:30,]
best_set_up_all_vlPAG_VGluT2_names <- rownames(best_set_up_all_vlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGluT2 marker genes (t-test | all | up)")
```

#### pval.type = "some"
##### Across clusters
We can first look at cluster-specific markers:
```{r}
marker_genes_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, marker_genes_up_all_clusters[[chosen_group]])
}
```

```{r}
library(pheatmap)
best_set_up_all_clusters_cluster_4 <- marker_set_up_all_clusters_cluster_4[1:30,]
best_set_up_all_clusters_cluster_4_names <- rownames(best_set_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for Cluster 4 marker genes (t-test | all | up)")
```

##### Across cell types
We can next look at cell-type-specific markers:
```{r}
marker_genes_up_all_celltype <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$cell.type, # clustering results or any other group assignements for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise to zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_celltype
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_celltype <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                           colour_by = "cell.type") + labs(title = "UMAP (cv2) - Cell type", 
                                                                                                              x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_celltype)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$cell.type)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype[[chosen_group]])
}
```

```{r}
library(pheatmap)
# VGAT cells
best_set_up_all_celltype_VGAT <- marker_set_up_all_celltype_1[1:30,]
best_set_up_all_celltype_VGAT_names <- rownames(best_set_up_all_celltype_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGAT marker genes (t-test | all | up)")

# VGluT2 cells
best_set_up_all_celltype_VGluT2 <- marker_set_up_all_celltype_2[1:30,]
best_set_up_all_celltype_VGluT2_names <- rownames(best_set_up_all_celltype_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_celltype_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for VGluT2 marker genes (t-test | all | up)")
```

##### Across PAG subdivisions
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_PAGareas <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                            groups = PAG_sceset_qc_norm_filt_corr_clust$PAG.area, # clustering results for each cell.
                                            #test.type = c("t", "wilcox", "binom"), # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                            pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                            #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                            #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                            #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                            #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                            #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                            #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                            #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                            #get.spikes = FALSE,
                                            #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                            #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                            #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                            #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                            direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                            #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                            #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                            #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                            )
marker_genes_up_all_PAGareas
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "PAG.area", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$PAG.area)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_PAGareas[[chosen_group]]
  print(paste0("marker_set_up_all_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_PAGareas[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG
best_set_up_all_PAGareas_dm <- marker_set_up_all_PAGarea_1[1:30,]
best_set_up_all_PAGareas_dm_names <- rownames(best_set_up_all_PAGareas_dm)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dm_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG marker genes (t-test | all | up)")

# dlPAG
best_set_up_all_PAGareas_dl <- marker_set_up_all_PAGarea_2[1:30,]
best_set_up_all_PAGareas_dl_names <- rownames(best_set_up_all_PAGareas_dl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_dl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG marker genes (t-test | all | up)")

# lPAG
best_set_up_all_PAGareas_l <- marker_set_up_all_PAGarea_3[1:30,]
best_set_up_all_PAGareas_l_names <- rownames(best_set_up_all_PAGareas_l)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_l_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG marker genes (t-test | all | up)")

# vlPAG
best_set_up_all_PAGareas_vl <- marker_set_up_all_PAGarea_4[1:30,]
best_set_up_all_PAGareas_vl_names <- rownames(best_set_up_all_PAGareas_vl)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_PAGareas_vl_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$PAG.area), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG marker genes (t-test | all | up)")
```

##### Across celltype_PAGarea
We can also look at subdivision-specific markers:
```{r}
marker_genes_up_all_celltype_PAGarea <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                                    groups = PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea, # clustering results for each cell.
                                                    #test.type = c("t", "wilcox", "binom"), # t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                                    pval.type = "some", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
                                                    #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                                    #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                                    #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                                    #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                                    #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each output DataFrames.
                                                    #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                                    #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                                    #get.spikes = FALSE,
                                                    #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                                    #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                                    #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                                    #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                                    direction = "up"#, # direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                                    #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                                    #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                                    #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                                    )
marker_genes_up_all_celltype_PAGarea
```

We can quickly replot the UMAP coloured by PAG subdivision:
```{r}
UMAP_cv2_15_001_PAGsubdivisions <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                  colour_by = "celltype_PAGarea", shape_by = "cell.type") + labs(title = "UMAP (cv2) - PAG subdivisions and cell types", 
                                                                                                                     x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_PAGsubdivisions)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes_up_all_celltype_PAGarea[[chosen_group]]
  print(paste0("marker_set_up_all_celltype_PAGarea_", chosen_group))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- paste0("marker_set_up_all_celltype_PAGarea_", chosen_group)
  assign(marker_set, marker_genes_up_all_celltype_PAGarea[[chosen_group]])
}
```

```{r}
library(pheatmap)
# dmPAG_VGAT
best_set_up_all_dmPAG_VGAT<- marker_set_up_all_celltype_PAGarea_1[1:30,]
best_set_up_all_dmPAG_VGAT_names <- rownames(best_set_up_all_dmPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGAT marker genes (t-test | all | up)")

# dlPAG_VGAT
best_set_up_all_dlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_2[1:30,]
best_set_up_all_dlPAG_VGAT_names <- rownames(best_set_up_all_dlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGAT marker genes (t-test | all | up)")

# lPAG_VGAT
best_set_up_all_lPAG_VGAT<- marker_set_up_all_celltype_PAGarea_3[1:30,]
best_set_up_all_lPAG_VGAT_names <- rownames(best_set_up_all_lPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGAT marker genes (t-test | all | up)")

# vlPAG_VGAT
best_set_up_all_vlPAG_VGAT<- marker_set_up_all_celltype_PAGarea_4[1:30,]
best_set_up_all_vlPAG_VGAT_names <- rownames(best_set_up_all_vlPAG_VGAT)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGAT_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGAT marker genes (t-test | all | up)")

# dmPAG_VGluT2
best_set_up_all_dmPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_5[1:30,]
best_set_up_all_dmPAG_VGluT2_names <- rownames(best_set_up_all_dmPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dmPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dmPAG_VGluT2 marker genes (t-test | all | up)")

# dlPAG_VGluT2
best_set_up_all_dlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_6[1:30,]
best_set_up_all_dlPAG_VGluT2_names <- rownames(best_set_up_all_dlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_dlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for dlPAG_VGluT2 marker genes (t-test | all | up)")

# lPAG_VGluT2
best_set_up_all_lPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_7[1:30,]
best_set_up_all_lPAG_VGluT2_names <- rownames(best_set_up_all_lPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_lPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for lPAG_VGluT2 marker genes (t-test | all | up)")

# vlPAG_VGluT2
best_set_up_all_vlPAG_VGluT2<- marker_set_up_all_celltype_PAGarea_8[1:30,]
best_set_up_all_vlPAG_VGluT2_names <- rownames(best_set_up_all_vlPAG_VGluT2)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_up_all_vlPAG_VGluT2_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$celltype_PAGarea), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("PAG.area", "cell.type", "celltype_PAGarea"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
            main = "Heatmap for vlPAG_VGluT2 marker genes (t-test | all | up)")
```

### 7.1.4 | Using the Wilcoxon rank sum test
The Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test) is another widely used method for pairwise comparisons between groups of observations. Its strength lies in the fact that it directly assesses separation between the expression distributions of different clusters. The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster. In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the t-test only does so indirectly via the difference in the means and the intra-group variance.

We can perform WMW tests using the `findMarkers()` function, setting `test="wilcox"`. This returns a list of `DataFrames` containing ranked candidate markers for each cluster. The `direction=`, `lfc=` and `pval.type=` arguments can be specified and have the same interpretation as described for t-tests. Again, to explore the results in more detail, we can focus on the `DataFrame` for group X. The interpretation of `Top` is the same as described for t-tests, and Simes’s method is again used to combine p-values across pairwise comparisons. If we want more focused sets, we can also change `pval.type=` as previously described.

We can first look at cluster-specific markers:
```{r}
markers_wilcox_up_all_clusters <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust,
                                              groups = PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10, # clustering results for each cell.
                                              test.type = "wilcox", # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
                                              pval.type = "any", # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
                                              #min.prop = NULL, # minimum proportion of significant comparisons per gene, Defaults to 0.5 when pval.type="some", otherwise zero.
                                              #log.p = FALSE, # whether log-transformed p-values/FDRs should be returned.
                                              #full.stats = FALSE, # whether all statistics in de.lists should be stored in the output for each pairwise comparison.
                                              #sorted = TRUE, # whether each output DataFrame should be sorted by a statistic relevant to pval.type.
                                              #row.data = NULL, # a DataFrame containing additional row metadata for each gene in x, to be included in each of the output DataFrames.
                                              #subset.row = NULL, # perform calculations only on a subset of rows of the SingleCellExperiment object.
                                              #assay.type = "logcounts", # The function expects normalised log-expression values for most tests.
                                              #get.spikes = FALSE,
                                              #block = PAG_sceset_qc_norm_filt_corr_clust$batch.processing, # factor specifying the blocking level for each cell.
                                              #design = NULL, # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
                                              #restrict = NULL, # the levels of groups for which to perform pairwise comparisons.
                                              #exclude = NULL, # the levels of groups for which NOT to perform pairwise comparisons.
                                              direction = "up"#, # the direction of log-fold changes to be considered in the alternative hypothesis. Can be "any", "up", or "down".
                                              #lfc = 1, # positive numeric scalar specifying the log-fold change threshold to be tested against.
                                              #std.lfc = FALSE, # whether log-fold changes should be standardized.
                                              #gene.names = rownames(x), # character vector of gene names with one value for each row of x.
                                              )
markers_wilcox_up_all_clusters
```

We can quickly replot the UMAP with the clustering results:
```{r}
UMAP_cv2_15_001_JaccardLouvain_k10 <- plotReducedDim(PAG_sceset_qc_norm_filt_corr_clust, dimred = "UMAP_cv2_corrected_15_neighbors_0.01_min_dist",
                                                     colour_by = "SNN_clusters_cv2_jaccard_k10", shape_by = "cell.type",
                                                     text_by = "SNN_clusters_cv2_jaccard_k10") + labs(title = "UMAP (cv2) - Jaccard-Louvain (k=10)", x = "UMAP 1", y = "UMAP 2")
plot(UMAP_cv2_15_001_JaccardLouvain_k10)
```

```{r}
# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10)))
# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- markers_wilcox_up_all_clusters[[chosen_group]]
  print(paste0("marker_set_wilcox_up_all_clusters_cluster_", chosen_group))
  print(temp_marker_set[1:10, 1:3])
  marker_set <- paste0("marker_set_wilcox_up_all_clusters_cluster_", chosen_group)
  assign(marker_set, markers_wilcox_up_all_clusters[[chosen_group]])
}
```

The `DataFrame` contains the AUCs from comparing group X to every other group. A value greater than 0.5 indicates that the gene is upregulated in the current cluster compared to the other cluster, while values less than 0.5 correspond to downregulation. We would typically expect AUCs of 0.7-0.8 for a strongly upregulated candidate marker.
```{r}
library(pheatmap)
best_set_wilcox_up_all_clusters_cluster_4 <- marker_set_wilcox_up_all_clusters_cluster_4[marker_set_wilcox_up_all_clusters_cluster_4$Top <= 6,]
#best_set_wilcox_up_all_clusters_cluster_4
AUCs_wilcox_up <- as.matrix(best_set_wilcox_up_all_clusters_cluster_4[,-(1:3)]) # leave only the columns containing logFC values for each comparison
#AUCs_wilcox_up
colnames(AUCs_wilcox_up) <- sub("AUC.", "", colnames(AUCs_wilcox_up)) # Remove "AUC." from the colnames, to leave the cluster number alone
#AUCs_wilcox_up

# Plot the logFCs - will plot one column for each comparison, and the top marker genes for the selected group should have a high value for each comparison
pheatmap(AUCs_wilcox_up, breaks = seq(0, 1, length.out = 21), color = viridis::viridis(21),
         main = "Heatmap for Cluster 4 AUCs (wilcoxon | all | up)")

# Alternative plot - will plot expression of the marker genes
best_set_wilcox_up_all_clusters_cluster_4_names <- rownames(best_set_wilcox_up_all_clusters_cluster_4)
plotHeatmap(PAG_sceset_qc_norm_filt_corr_clust,
            features = best_set_wilcox_up_all_clusters_cluster_4_names, # vector of row names specifying rows of object to show in the heatmap.
            columns = order(PAG_sceset_qc_norm_filt_corr_clust$SNN_clusters_cv2_jaccard_k10), 
            # subset of columns to show in heatmap (or column order if cluster_cols=FALSE and order_columns_by=NULL). Defaults to NULL.
            exprs_values = "logcounts", # assay of object to be used as expression values for colouring the heatmap.
            center = TRUE, # whether each row should have its mean expression centered at zero prior to plotting. Useful for examining logFC from the average across all cells.
            zlim = c(-5, 5), # upper and lower bounds for the expression values (after centering). Defaults to the range of the expression matrix.
            # Preserves the dynamic range of colours in the presence of outliers. Defaults to NULL.
            symmetric = TRUE, # If TRUE, make zlim symmetric around zero (compute the maximum absolute value of zlim and multipy by c(-1, 1) to redefine zlim). Default is FALSE.
            color = NULL, # defaults to heatmap color palette: colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
            colour_columns_by = c("SNN_clusters_cv2_jaccard_k10", "cell.type", "PAG.area"), # how the columns should be annotated with colours.
            show_rownames = TRUE, show_colnames = FALSE,
            cluster_rows = TRUE, cluster_cols = FALSE,
             main = "Heatmap for Cluster 4 marker genes (wilcoxon | all | up)")
```

One practical advantage of the WMW test over the Welch t-test is that it is symmetric with respect to differences in the size of the groups being compared. This means that, all else being equal, the top-ranked genes on each side of a DE comparison will have similar expression profiles regardless of the number of cells in each group. In contrast, the t-test will favor genes where the larger group has the higher relative variance as this increases the estimated degrees of freedom and decreases the resulting p-value. This can lead to unappealing rankings when the aim is to identify genes upregulated in smaller groups. The WMW test is not completely immune the variance effects - for example, it will slightly favor detection of DEGs at low average abundance where the greater number of ties at zero deflates the approximate variance of the rank sum statistic - but this is relatively benign as the selected genes are still fairly interesting.
```{r}
marker.lawlor.t <- findMarkers(sce.lawlor, groups=sce.lawlor$`cell type`, 
                               direction="up", restrict=c("Alpha", "Gamma/PP"))
marker.lawlor.w <- findMarkers(sce.lawlor, groups=sce.lawlor$`cell type`, 
                               direction="up", restrict=c("Alpha", "Gamma/PP"), test.type="wilcox")

# Upregulated in alpha:
marker.alpha.t <- marker.lawlor.t$Alpha
marker.alpha.w <- marker.lawlor.w$Alpha
chosen.alpha.t <- rownames(marker.alpha.t)[1:20]
chosen.alpha.w <- rownames(marker.alpha.w)[1:20]
u.alpha.t <- setdiff(chosen.alpha.t, chosen.alpha.w)
u.alpha.w <- setdiff(chosen.alpha.w, chosen.alpha.t)

# Upregulated in gamma:
marker.gamma.t <- marker.lawlor.t$`Gamma/PP`
marker.gamma.w <- marker.lawlor.w$`Gamma/PP`
chosen.gamma.t <- rownames(marker.gamma.t)[1:20]
chosen.gamma.w <- rownames(marker.gamma.w)[1:20]
u.gamma.t <- setdiff(chosen.gamma.t, chosen.gamma.w)
u.gamma.w <- setdiff(chosen.gamma.w, chosen.gamma.t)

# Examining all uniquely detected markers in each direction.
library(scater)
subset <- sce.lawlor[,sce.lawlor$`cell type` %in% c("Alpha", "Gamma/PP")]
gridExtra::grid.arrange(plotExpression(subset, x="cell type", features=u.alpha.t, ncol=2) +
                          ggtitle("Upregulated in alpha, t-test-only"),
                        plotExpression(subset, x="cell type", features=u.alpha.w, ncol=2) +
                          ggtitle("Upregulated in alpha, WMW-test-only"),
                        plotExpression(subset, x="cell type", features=u.gamma.t, ncol=2) +
                          ggtitle("Upregulated in gamma, t-test-only"),
                        plotExpression(subset, x="cell type", features=u.gamma.w, ncol=2) +
                          ggtitle("Upregulated in gamma, WMW-test-only"),
                        ncol=2
                        )
```

The main disadvantage of the WMW test is that the AUCs are much slower to compute compared to t-statistics. This may be inconvenient for interactive analyses involving multiple iterations of marker detection. We can mitigate this to some extent by parallelizing these calculations using the `BPPARAM=` argument in `findMarkers()`.

### 7.1.5 | Using the binomial test
The binomial test *identifies genes that differ in the proportion of expressing cells between clusters*. This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero. The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle “tuning” effects from changing the expression of an active gene. From a practical perspective, a binary measure of presence/absence is easier to validate.

We can perform pairwise binomial tests between clusters using the `findMarkers()` function with `test="binom"`. This returns a list of `DataFrames` containing marker statistics for each cluster such as the `Top` rank and its p-value. Here, the effect size is reported as the log-fold change in this proportion between each pair of clusters. Large positive log-fold changes indicate that the gene is more frequently expressed in one cluster compared to the other. We can focus on genes that are upregulated in each cluster compared to the others by setting `direction="up"`.

The disadvantage of the binomial test is that its increased stringency can lead to the loss of good candidate markers. Another property of the binomial test is that it will not respond to scaling normalisation. Systematic differences in library size between clusters will not be considered when computing p-values or effect sizes. This is not necessarily problematic for marker gene detection - users can treat this as retaining information about the total RNA content, analogous to spike-in normalisation.

```{r}
library(scran)
# Parameters defaults:
test <- c("t", "wilcox", "binom") # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
direction <- c("any", "up", "down") # the direction of log-fold changes to be considered in the alternative hypothesis.
comparisons <- c("any", "some", "all") # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all.
lfc = 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

groups = NULL # clustering results or group for each cell.
block = NULL # factor specifying the blocking level for each cell.
design = NULL # numeric matrix with blocking terms for uninteresting factors (not be confounded with groups).
restrict = NULL # the levels of groups for which to perform pairwise comparisons.
exclude = NULL # the levels of groups for which NOT to perform pairwise comparisons.
```

Find cell type specific markers:
```{r}
# Set the parameters:
results_name <- "cell_type_" # String to be added to the filename when saving the results.
# "SNN_jaccard_k8_cluster_", "PAG_subdivisions_", "celltype_", "celltype_PAGarea_", "celltype_PAGAPaxis_"

test <- "binom" # Pairwise test to perform: t-test "t", Wilcoxon rank sum test "wilcox", binomial test "binom".
comparisons <- "all" # how p-values are to be combined across pairwise comparisons for a given group: "any", "some", or "all".
direction <- "up" # the direction of log-fold changes to be considered in the alternative hypothesis: "any", "up", "down".
lfc <- 0 # positive numeric scalar specifying the log-fold change threshold to be tested against.

groups <- PAG_sceset_qc_norm_filt_corr_clust_de$cell.type # clustering results or group for each cell.
block <- PAG_sceset_qc_norm_filt_corr_clust_de$mouse.sex # factor specifying the blocking level for each cell.
restrict <- NULL # the levels of groups for which to perform pairwise comparisons.
exclude <- NULL # the levels of groups for which NOT to perform pairwise comparisons.

# Run findMarkers:
marker_genes <- findMarkers(PAG_sceset_qc_norm_filt_corr_clust_de,
                            groups = groups,
                            test.type = test,
                            pval.type = comparisons,
                            direction = direction,
                            lfc = lfc,
                            assay.type = "logcounts",
                            block = block,
                            restrict = restrict,
                            exclude = exclude
                            )
marker_genes

# Create a variable with a value for each group name to iterate through:
range_of_groups <- 1:paste(length(levels(groups)))

# Create a separate table of results for each group and print the top 10 marker genes:
for (chosen_group in range_of_groups) {
  temp_marker_set <- marker_genes[[chosen_group]]
  print(str_c("marker_set_", test, "_", comparisons, "_", direction, "_", levels(groups)[chosen_group]))
  print(temp_marker_set[1:10, 1:2])
  marker_set <- str_c("marker_set_", test, "_", comparisons, "_", direction, "_", levels(groups)[chosen_group])
  assign(marker_set, temp_marker_set)
  write.csv(temp_marker_set, file = str_c(path_for_figures, "PAG_DE_results_", test, "_", comparisons, "_", direction, "_", results_name, levels(groups)[chosen_group], ".csv"),
            quote = FALSE, row.names = TRUE)
}
```

```{r}
library(scater)
top_VGAT_genes <- head(rownames(marker_set_binom_all_up_VGAT))
plotExpression(PAG_sceset_qc_norm_filt_corr_clust_de, x = "cell.type", features = top_VGAT_genes)

top_VGluT2_genes <- head(rownames(marker_set_binom_all_up_VGluT2))
plotExpression(PAG_sceset_qc_norm_filt_corr_clust_de, x = "cell.type", features = top_VGluT2_genes)
```

### 7.1.6 | Using custom DE methods
It is also possible to perform marker gene detection based on precomputed DE statistics, which allows us to take advantage of more sophisticated tests in dedicated DE analysis packages in the Bioconductor ecosystem. To demonstrate, consider the `voom()` approach from the limma package (Law et al. 2014). We first process our `SingleCellExperiment` to obtain a `fit` object as shown below.
```{r}
library(limma)
library(scran)
design <- model.matrix(~0 + cluster + Plate, data=colData(sce.pbmc))
colnames(design)

# Removing very low-abundance genes.
keep <- calculateAverage(sce.pbmc) > 0.1 
summary(keep)

y <- convertTo(sce.pbmc, subset.row=keep)
v <- voom(y, design)
fit <- lmFit(v, design)
```

We then perform pairwise comparisons between clusters using the TREAT strategy (McCarthy and Smyth 2009) to test for log-fold changes that are significantly greater than 0.5. For each comparison, we store the corresponding data frame of statistics in `all.results`, along with the identities of the clusters involved in `all.pairs`.
```{r}
nclust <- length(unique(sce.pbmc$cluster))
all.results <- all.pairs <- list()
counter <- 1L

# Iterating across the first 'nclust' coefficients in design,
# and comparing them to each other in a pairwise manner.
for (x in seq_len(nclust)) {
    for (y in seq_len(x-1L)) {
        con <- integer(ncol(design))
        con[x] <- 1
        con[y] <- -1
        fit2 <- contrasts.fit(fit, con)
        fit2 <- treat(fit2, robust=TRUE, lfc=0.5)

        res <- topTreat(fit2, n=Inf, sort.by="none")
        all.results[[counter]] <- res
        all.pairs[[counter]] <- colnames(design)[c(x, y)]
        counter <- counter+1L

        # Also filling the reverse comparison.
        res$logFC <- -res$logFC
        all.results[[counter]] <- res
        all.pairs[[counter]] <- colnames(design)[c(y, x)]
        counter <- counter+1L
    }
}
```

These custom results are consolidated into a single marker list for each cluster with the `combineMarkers()` function. This combines test statistics across all pairwise comparisons involving a single cluster, yielding a per-cluster `DataFrame` that can be interpreted in the same manner as discussed previously.
```{r}
all.pairs <- do.call(rbind, all.pairs)
combined <- combineMarkers(all.results, all.pairs, pval.field="P.Value")

# Inspecting results for our cluster of interest again.
interesting.voom <- combined[[paste0("cluster", chosen)]] 
colnames(interesting.voom)

head(interesting.voom[,1:3])
```

By default, we do not use custom DE methods to perform marker detection, for several reasons. Many of these methods rely on empirical Bayes shrinkage to share information across genes in the presence of limited replication. However, this is unnecessary when there are large numbers of “replicate” cells in each group. These methods also make stronger assumptions about the data (e.g., equal variances for linear models, the distribution of variances during empirical Bayes) that are more likely to be violated in noisy scRNA-seq contexts. From a practical perspective, they require more work to set up and take more time to run. Nonetheless, some custom methods (e.g., MAST) may provide a useful point of difference from the simpler tests, in which case they can be converted into a marker detection scheme as described above.

## Step 7.END | Save the SingleCellExperiment object
```{r}
# UPDATE
# saveRDS(PAG_sceset_qc_norm_filt_corr, file = "PAG_sceset_qc_norm_filt_corr_clust.rds")
print("Part 7 - Done!")
```

```{r}
sessionInfo()
```
---
title: "Topographic, single-cell gene expression profiling of Periaqueductal Gray neurons"
subtitle: "Part III: normalization"
author:
  - name: "Oriol Pavon Arocas, Sarah F. Olesen, and Tiago Branco"
    affiliation: "Sainsbury Wellcome Centre for Neural Circuits and Behaviour, University College London, UK"
    email: "oriol.pavon.16@ucl.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    highlight: pygments
    number_sections: FALSE
    theme: lumen
    toc: TRUE
    toc_float: TRUE

#output: rmdformats::readthedown:
  #highlight: pygments
---

***

This is a pipeline to analyse single-cell RNA sequencing data from Periaqueductal Gray neurons (1) isolated from acute midbrain slices of transgenic mice using visually guided aspiration via patch pipettes and (2) processed using SMART-seq2 (Picelli et al., Nature Protocols 2014). 

This pipeline has been generated after attending the [EMBL-EBI RNA-Sequence Analysis Course](https://www.ebi.ac.uk/training/events/2019/rna-sequence-analysis) and [attending](https://training.csx.cam.ac.uk/bioinformatics/event/2823386) and following the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group). Many other resources have been used, including the [Orchestrating Single-Cell Analysis with Bioconductor book](https://osca.bioconductor.org/) by Robert Amezquita and Stephanie Hicks, the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun, the [rnaseqGene workflow](https://bioconductor.org/packages/3.10/workflows/html/rnaseqGene.html) maintained by Michael Love, the [RNAseq123 workflow](https://bioconductor.org/packages/3.10/workflows/html/RNAseq123.html) maintained by Matthew Ritchie, and the [EGSEA123 workflow](https://bioconductor.org/packages/3.10/workflows/html/EGSEA123.html) maintained by Matthew Ritchie.

Other key resources include [Bioconductor](http://www.bioconductor.org/) (Huber et al., Nature Methods 2015), [scRNA-tools](https://www.scrna-tools.org/), `scater` (McCarthy et al., Bioinformatics 2017), `scran` (Lun et al., F1000Res 2016), `SC3` (Kiselev et al., Nature Methods 2017), `Seurat` (Butler et al., Nature Biotechnology 2018), `clusterExperiment` (Risso et al., PLOS Computational Biology 2018), `limma` (Ritchie et al., Nucleic Acids Research 2015), `DESeq2` (Love et al., Genome Biology 2014), `edgeR` (Robinson et al., Bioinformatics 2010), `MAST` (Finak, McDavid, Yajima et al., Genome Biology 2015), `iSEE` (Rue-Albrecht & Marini et al., F1000Research 2018), `t-SNE` (van der Maaten & Hinton, Journal of Machine Learning Research 2008), `UMAP` (McInnes et al., arXiv 2018), and the [Mathematical Statistics and Machine Learning for Life Sciences](https://towardsdatascience.com/tagged/stats-ml-life-sciences) column by Nikolay Oskolkov.

***

# STEP 3 | Normalization of cell-specific biases
Systematic differences in sequencing coverage between libraries are often observed in single-cell RNA sequencing data (Stegle, Teichmann, and Marioni 2015). They typically arise from technical differences in cDNA capture or PCR amplification efficiency across cells, attributable to the difficulty of achieving consistent library preparation with minimal starting material. Normalization aims to remove these differences such that they do not interfere with comparisons of the expression profiles between cells. This ensures that any observed heterogeneity or differential expression within the cell population are driven by biology and not technical biases.

Scaling normalization is the simplest and most commonly used class of normalization strategies. It involves dividing all counts for each cell by a cell-specific scaling factor, often called a “size factor” (Anders and Huber 2010). The assumption here is that any cell-specific bias (e.g., in capture or amplification efficiency) affects all genes equally via scaling of the expected mean count for that cell. The size factor for each cell represents the estimate of the relative bias in that cell, so division of its counts by its size factor should remove that bias. The resulting “normalized expression values” can then be used for downstream analyses such as clustering and dimensionality reduction.

_The following theory has been summarised from the online course on [Analysis of single cell RNA-seq data](https://github.com/hemberg-lab/scRNA.seq.course) by the [Hemberg Lab](https://www.sanger.ac.uk/science/groups/hemberg-group)._

Library sizes vary because scRNA-seq data is often sequenced on highly multiplexed platforms and the total reads which are derived from each cell may differ substantially. Library size must be corrected for by multiplying or dividing each column of the expression matrix by a normalization factor which is an estimate of the library size relative to the other cells. Many methods to correct for library size have been developped for bulk RNA-seq (e.g. UQ, SF, CPM, RPKM, FPKM, TPM).

* __Upperquartile (UQ)__: In the upperquartile method (Bullard et al. 2010), each column is divided by the 75% quantile of the counts for each library. Often the calculated quantile is scaled by the median across cells to keep the absolute level of expression relatively consistent. A drawback to this method is that for low-depth scRNASeq experiments the large number of undetected genes may result in the 75% quantile being zero (or close to it). This limitation can be overcome by generalizing the idea and using a higher quantile (eg. the 99% quantile is the default in scater) or by excluding zeros prior to calculating the 75% quantile.

* __Relative log expression (RLE) size factor (SF)__: The size factor (SF) was proposed and popularized by DESeq (Anders and Huber 2010). First the geometric mean of each gene across all cells is calculated. The size factor for each cell is the median across genes of the ratio of the expression to the gene geometric mean. A drawback to this method is that since it uses the geometric mean only genes with non-zero expression values across all cells can be used in its calculation, making it unadvisable for large low-depth scRNASeq experiments.

* __CPM (counts per million)__: The simplest way to normalize RNAseq data is to convert it to counts per million (CPM) by dividing each column by its total then multiplying by 1,000,000. __RPKM__ (read per kilobase per milion), __FPKM__ (fragment per kilobase per million) and __TPM__ (transcripts per million) are variants on CPM which further adjust counts by the length of the respective gene/transcript. 
    + Spike-ins should be excluded from the calculation of total expression in order to correct for total cell RNA content (we should only use endogenous genes).
    + One potential drawback of CPM is if your sample contains genes that are both very highly expressed and differentially expressed across the cells. In this case, the total molecules in the cell may depend of whether such genes are on/off in the cell and normalizing by total molecules may hide the differential expression of those genes and/or falsely create differential expression for the remaining genes.  

* __scran (scRNAseq specific)__: The `scran` package implements a variant on CPM specialized for single-cell data (Lun et al. Genome Biology 2016). Briefly, this method deals with the problem of vary large numbers of zero values per cell by pooling cells together calculating a normalization factor (similar to CPM) for the sum of each pool. Since each cell is found in many different pools, cell-specific factors can be deconvoluted from the collection of pool-specific factors using linear algebra.

* __SCnorm (scRNAseq specific)__: Another method developed to normalize scRNAseq data (Bacher et al. Nature Methods 2017).

***
__A note on scaling normalization strategies__ from the [simpleSingleCell workflow in Bioconductor](https://bioconductor.org/packages/3.9/workflows/html/simpleSingleCell.html) maintained by Aaron Lun.

Scaling normalization strategies for scRNA-seq data can be broadly divided into two classes. The first class assumes that there exists a subset of genes that are not DE between samples. The second class uses the fact that the same amount of spike-in RNA was added to each cell, and therefore differences in the coverage of the spike-in transcripts can only be due to cell-specific biases (e.g., in capture efficiency or sequencing depth). Scaling normalization is then applied to equalize spike-in coverage across cells.

The choice between these two normalization strategies depends on the biology of the cells and the features of interest. If the majority of genes are expected to be DE and there is no reliable house-keeping set, spike-in normalization may be the only option for removing cell-specific biases. Spike-in normalization should also be used if differences in the total RNA content of individual cells are of interest. In any particular cell, an increase in the amount of endogenous RNA will not increase spike-in coverage (with or without library quantification). Thus, the former will not be represented as part of the bias in the latter, which means that the effects of total RNA content on expression will not be removed upon scaling. With non-DE normalization, an increase in RNA content will systematically increase the expression of all genes in the non-DE subset, such that it will be treated as bias and removed.

In our case, we expect our dataset to contain a homogeneous population of neurons, with the majority of genes not differentially expressed between samples. Therefore, we will compute size factors for endogenous genes. We will not use spike-in transcripts as we did not add them in sufficient concentration to be used reliably.

## Step 3.1 | Compute size factors for endogenous genes
We will use `scran` to calculate size factors for our samples and then use them for normalization. Importantly, see Vallejos et al., Nature Methods 2017 for an explanation of why it is not a good idea to use CPM normalization on scRNAseq data.
```{r}
# If starting from stored results, load saved filtered dataset from previous Step:
set.seed(1991)
options(stringsAsFactors = FALSE)
library(SingleCellExperiment)
library(scater)
library(scran)

PAG_sceset_qc <- readRDS("PAG_sceset_qc.rds") # Contains filtered cells and genes
assayNames(PAG_sceset_qc)
```

We should __not__ include spike-ins in the normalization step, as we want to normalize by the genes each cell endogenously expressed. We can later calculate separate size factors for the spike-in transcripts.
```{r}
# For large datasets of highly heterogeneous data with multiple cell types we should run a preclustering step:
# qclust <- quickCluster(PAG_sceset_qc, min.size = 30)
# PAG_sceset_qc <- computeSumFactors(PAG_sceset_qc, sizes = 15, clusters = qclust)
# PAG_sceset_qc <- logNormCounts(PAG_sceset_qc)

# For small datasets like ours (< 1000 samples), the quickCluster step above can be ommited and we can run computeSumFactors straight away.
PAG_sceset_qc <- computeSumFactors(PAG_sceset_qc, min.mean = 1, sizes = seq(21, 201, 5), assay.type = "counts")
summary(sizeFactors(PAG_sceset_qc))
```

`scran` sometimes calculates negative or zero size factors. These will completely distort the normalized expression matrix. If you find `scran` has calculated negative size factors try increasing the cluster and pool sizes until they are all positive.

Plotting the size factors against the library sizes should show some positive correlation.
```{r}
plot(PAG_sceset_qc$total/1e6, 
     sizeFactors(PAG_sceset_qc),
     log = "xy", 
     xlab = "Library size (millions)", 
     ylab = "Size factor", 
     col = c(rgb(255, 119, 124, 255/2, maxColorValue = 255), rgb(0, 156, 181, 255/3, maxColorValue = 255))[factor(PAG_sceset_qc$cell.type)], 
     type = "p", pch = 19, cex = 1.25)
legend("bottomright", col = c(rgb(255, 119, 124, 255/2, maxColorValue = 255), rgb(0, 156, 181, 255/3, maxColorValue = 255)), pch = 19, cex = 1.25,  bty = "n",
       legend = levels(factor(PAG_sceset_qc$cell.type)))
```

The size factors are tightly correlated with the library sizes for all cells. This suggests that the systematic differences between cells are primarily driven by differences in capture efficiency or sequencing depth. Any DE between cells would yield a non-linear trend between the total count and size factor, and/or increased scatter around the trend. This does not occur here as strong DE is unlikely to exist within a homogeneous population of cells.

As we mentioned, we will not normalise using Spike-ins size factors, as we did not add a high enough concentration of ERCCs to achieve a sampling distribution/sequencing coverage constant across cells. If both the deconvolution size factors and the spike-in size factors captured similar technical biases in sequencing depth and capture efficiency, we should observe a positive correlation between them. However, if we plot one against the other, we can clearly see that this is not the case, and spike-in size factors are very low in most cells, reflecting the fact that for most cells the percentage of reads allocated to spike-ins was not high enough to use them for normalisation purposes.
```{r}
PAG_sceset_qc_spikes <- PAG_sceset_qc # Make a copy of the SingleCellExperiment object
PAG_sceset_qc_spikes <- computeSpikeFactors(PAG_sceset_qc_spikes, "ERCC", assay.type = "counts")
to.plot <- data.frame(DeconvFactor = sizeFactors(PAG_sceset_qc),
                      SpikeFactor = sizeFactors(PAG_sceset_qc_spikes),
                      CellType = PAG_sceset_qc$cell.type)

ggplot(to.plot, aes(x = DeconvFactor, y = SpikeFactor, color = CellType)) +
    geom_point() + scale_x_log10() + 
    scale_y_log10() + geom_abline(intercept = 0, slope = 1, color = "red")
```

We will thus use spike-ins for QC only, and we will normalise our dataset using the deconvolution size factors.

## Step 3.2 | Apply the size factors to normalize gene expression
We will calculate normalized expression values using the `logNormCounts()` method from `scater` (McCarthy et al., 2017). This will use the deconvolution size factors for the endogenous genes, and the spike-in-based size factors for the spike-in transcripts. Each expression value can be interpreted as a log-transformed “normalized count”, and can be used in downstream applications like clustering or dimensionality reduction.

The count data are used to compute normalized log-expression values for use in downstream analyses. Each value is defined as the log2-ratio of each count to the size factor for the corresponding cell, after adding a pseudo-count of 1 to avoid undefined values at zero counts. Division of the counts for each gene by its appropriate size factor ensures that any cell-specific biases are removed. If spike-in-specific size factors are present in `SingleCellExperiment`, they will be automatically applied to normalize the spike-in transcripts separately from the endogenous genes.

The log-transformation provides some measure of variance stabilization (Law et al., 2014), so that high-abundance genes with large variances do not dominate downstream analyses. The computed values are stored as an expression matrix in addition to the other assay elements.
```{r}
PAG_sceset_qc <- logNormCounts(PAG_sceset_qc)
assayNames(PAG_sceset_qc)
```

The log-transformation is useful as differences in the log-values represent log-fold changes in expression. This is important in downstream procedures based on Euclidean distances, which includes many forms of clustering and dimensionality reduction. By operating on log-transformed data, we ensure that these procedures are measuring distances between cells based on log-fold changes in expression.

### 3.2.1 | TPM Normalization
Data from full length protocols may benefit from normalization methods that take into account gene length (Patel et al, 2014; Kowalczyk et al, 2015; Soneson & Robinson, 2018). A commonly used normalization method for full-length scRNA-seq data is TPM normalization (Li et al, 2009), which comes from bulk RNA-seq analysis.

Given that we have full-length read data, we could use the gene lengths we computed at the begining to apply TPM normalization:
```{r}
assay(PAG_sceset_qc, "TPM") <- calculateTPM(PAG_sceset_qc,
                                            lengths = rowData(PAG_sceset_qc_norm)$gene_length,
                                            exprs_values = "counts",
                                            size_factors = sizeFactors(PAG_sceset_qc))
assayNames(PAG_sceset_qc)
```

However, according to this post by [Nikolay Oskolkov](https://towardsdatascience.com/pitfalls-of-data-normalization-bf05d65f1f4c), TPM counts for a given sample sum up to one million, which is a Simplex Space constraint. This means that TPM counts are not better than Library Size normalized counts as they also suffer from the Simplex Space bias, and one should not naively apply e.g. PCA on those counts. For a clearer explanation read the full post on the link above.

## Step 3.3 | Compare the effects of different normalization strategies
To compare the efficiency of different normalization methods we can use visual inspection of PCA plots and calculation of cell-wise relative log expression via scater's `plotRLE()` function. Namely, cells with many (few) reads have higher (lower) than median expression for most genes resulting in a positive (negative) RLE across the cell, whereas normalized cells have an RLE close to zero.

If we look at the RLE plot, the graph shows a box plot of the RLE values for each cell (each line is a boxplot), the circles indicate the median (nearly all should be at 0 after normalization), and the line indicates the interquartile range.
```{r}
library(ggplot2)
library(sgeostat)
library(mvoutlier)

# Without log-transformation
p1 <- plotRLE(PAG_sceset_qc, 
              exprs_values = "counts",
              exprs_logged = TRUE,
              style = "full",
              legend = TRUE,
              colour_by = "mouse.id"
              ) + ggtitle("Raw counts")

# With log-transformation
p2 <- plotRLE(PAG_sceset_qc, 
              exprs_values = "logcounts_raw",
              exprs_logged = TRUE,
              style = "full",
              legend = TRUE,
              colour_by = "mouse.id"
              ) + ggtitle("Logcounts Raw")

# After scran normalization
p3 <- plotRLE(PAG_sceset_qc, 
              exprs_values = "logcounts",
              exprs_logged = TRUE,
              style = "full",
              legend = TRUE,
              colour_by = "mouse.id"
              ) + ggtitle("scran")

# This might be too heavy to plot at once, so plot each graph one at a time:
#plot(p1)
#plot(p2)
#plot(p3)
```

## Step 3.5 | Save a normalized SingleCellExperiment object
```{r}
# Save the normalized data:
saveRDS(PAG_sceset_qc, file = "PAG_sceset_qc_norm.rds")
print("Part 3 - Done!")
```

```{r}
sessionInfo()
```